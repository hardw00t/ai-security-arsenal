#!/usr/bin/env python3
"""
Vulnerability Tester
Comprehensive vulnerability testing engine for DAST.
"""

import argparse
import json
import sys
from pathlib import Path
from datetime import datetime

class VulnerabilityTester:
    """
    Comprehensive vulnerability testing engine

    Tests for: XSS, CSRF, IDOR, Open Redirect, Info Disclosure, etc.
    """

    def __init__(self, crawl_results_file):
        self.crawl_results = self.load_crawl_results(crawl_results_file)
        self.findings = []

        # Test configuration
        self.xss_payloads = [
            '<script>alert(document.domain)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '" autofocus onfocus=alert(1) x="',
            "';alert(String.fromCharCode(88,83,83))//",
            '<iframe src="javascript:alert(1)">',
            '<body onload=alert(1)>',
            '<<SCRIPT>alert("XSS");//<</SCRIPT>',
            '<IMG SRC=javascript:alert("XSS")>',
            '<IMG """><SCRIPT>alert("XSS")</SCRIPT>">',
        ]

        self.sqli_payloads = [
            "' OR '1'='1'--",
            "' OR '1'='1'/*",
            "' UNION SELECT NULL--",
            "admin'--",
            "' OR 1=1#",
            "') OR ('1'='1",
            "' AND SLEEP(5)--",
            "1' WAITFOR DELAY '00:00:05'--",
        ]

        self.redirect_payloads = [
            'https://evil.com',
            '//evil.com',
            '///evil.com',
            '/\\evil.com',
            'javascript:alert(1)',
            'data:text/html,<script>alert(1)</script>'
        ]

    def load_crawl_results(self, results_file):
        """Load crawl results"""
        try:
            with open(results_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"[!] Error loading crawl results: {e}")
            sys.exit(1)

    def test_all(self):
        """Run all vulnerability tests"""
        print("[*] Starting comprehensive vulnerability testing\n")

        print("[*] Testing for XSS...")
        self.test_xss()

        print("[*] Testing for CSRF...")
        self.test_csrf()

        print("[*] Testing for Open Redirects...")
        self.test_open_redirect()

        print("[*] Testing for SQL Injection...")
        self.test_sqli()

        print("[*] Testing for Information Disclosure...")
        self.test_info_disclosure()

        print(f"\n[+] Testing complete: {len(self.findings)} findings")

        return self.findings

    def test_xss(self):
        """
        Test for XSS vulnerabilities

        NOTE: Actual testing performed by Claude Code via Playwright MCP
        """

        # Get all forms and inputs from crawl results
        forms = self.crawl_results.get('forms', [])
        inputs = self.crawl_results.get('inputs', [])

        for form in forms:
            url = form['url']
            fields = form.get('fields', [])

            for field in fields:
                field_name = field.get('name')

                # Test each XSS payload in each field
                for payload in self.xss_payloads:
                    # Claude Code will:
                    # 1. Navigate to form URL
                    # 2. Fill field with payload
                    # 3. Submit form
                    # 4. Check for payload execution:
                    #    - Monitor alert dialogs
                    #    - Check DOM for unescaped payload
                    #    - Verify in response body
                    # 5. If vulnerable, create finding

                    # Example finding:
                    vulnerable = False  # Claude Code determines this

                    if vulnerable:
                        finding = {
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'HIGH',
                            'url': url,
                            'parameter': field_name,
                            'payload': payload,
                            'description': f'Reflected XSS vulnerability in {field_name} parameter',
                            'evidence': f'Payload {payload} executed without sanitization',
                            'impact': 'Attackers can execute arbitrary JavaScript in victims\' browsers',
                            'remediation': 'Implement output encoding and Content-Security-Policy header',
                            'cwe': 'CWE-79',
                            'owasp': 'A03:2021 - Injection',
                            'cvss': 7.1,
                            'references': [
                                'https://owasp.org/www-community/attacks/xss/',
                                'https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html'
                            ]
                        }
                        self.findings.append(finding)

        # Test URL parameters for reflected XSS
        urls = self.crawl_results.get('urls', [])
        for url in urls:
            if '?' in url:
                # Test parameters in URL
                pass

    def test_csrf(self):
        """Test for CSRF vulnerabilities"""

        forms = self.crawl_results.get('forms', [])

        for form in forms:
            method = form.get('method', 'GET').upper()

            # Only test state-changing methods
            if method not in ['POST', 'PUT', 'DELETE', 'PATCH']:
                continue

            url = form['url']
            has_csrf_token = form.get('has_csrf_token', False)

            # Claude Code will:
            # 1. Capture legitimate request with CSRF token
            # 2. Test request without token
            # 3. Test request with invalid token
            # 4. Test request from different origin
            # 5. Verify if CSRF protection is effective

            if not has_csrf_token:
                finding = {
                    'type': 'Cross-Site Request Forgery (CSRF)',
                    'severity': 'MEDIUM',
                    'url': url,
                    'method': method,
                    'description': 'Missing CSRF protection on state-changing operation',
                    'evidence': 'No anti-CSRF token found in form',
                    'impact': 'Attackers can perform unauthorized actions on behalf of authenticated users',
                    'remediation': 'Implement CSRF tokens (synchronizer token pattern) and SameSite cookie attribute',
                    'cwe': 'CWE-352',
                    'owasp': 'A01:2021 - Broken Access Control',
                    'cvss': 6.5,
                    'references': [
                        'https://owasp.org/www-community/attacks/csrf',
                        'https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html'
                    ]
                }
                self.findings.append(finding)

    def test_open_redirect(self):
        """Test for open redirect vulnerabilities"""

        urls = self.crawl_results.get('urls', [])

        # Common redirect parameters
        redirect_params = ['url', 'redirect', 'next', 'return_url', 'continue', 'dest', 'destination', 'redir']

        for url in urls:
            if '?' in url:
                # Claude Code will:
                # 1. Parse URL parameters
                # 2. Identify potential redirect parameters
                # 3. Test with malicious redirect URLs
                # 4. Verify if redirect occurs

                # Example finding:
                vulnerable = False  # Claude Code determines

                if vulnerable:
                    finding = {
                        'type': 'Open Redirect',
                        'severity': 'MEDIUM',
                        'url': url,
                        'parameter': 'redirect',
                        'payload': 'https://evil.com',
                        'description': 'Unvalidated redirect allows redirection to arbitrary external sites',
                        'evidence': 'Successfully redirected to attacker-controlled domain',
                        'impact': 'Phishing attacks, credential theft via trusted domain abuse',
                        'remediation': 'Validate redirect destinations against whitelist, use relative URLs only',
                        'cwe': 'CWE-601',
                        'owasp': 'A01:2021 - Broken Access Control',
                        'cvss': 5.4,
                        'references': [
                            'https://owasp.org/www-community/attacks/Unvalidated_Redirects_and_Forwards_Cheat_Sheet'
                        ]
                    }
                    self.findings.append(finding)

    def test_sqli(self):
        """Test for SQL Injection"""

        forms = self.crawl_results.get('forms', [])

        for form in forms:
            url = form['url']
            fields = form.get('fields', [])

            for field in fields:
                field_name = field.get('name')

                for payload in self.sqli_payloads:
                    # Claude Code will:
                    # 1. Submit form with SQL injection payload
                    # 2. Analyze response for:
                    #    - SQL error messages
                    #    - Time delays (for blind SQLi)
                    #    - Data extraction (for UNION-based)
                    #    - Boolean changes (for boolean-based)

                    vulnerable = False  # Claude Code determines

                    if vulnerable:
                        finding = {
                            'type': 'SQL Injection',
                            'severity': 'CRITICAL',
                            'url': url,
                            'parameter': field_name,
                            'payload': payload,
                            'description': f'SQL injection vulnerability in {field_name} parameter',
                            'evidence': 'SQL error message exposed / Time-based delay confirmed',
                            'impact': 'Complete database compromise, data extraction, authentication bypass',
                            'remediation': 'Use parameterized queries (prepared statements), input validation, principle of least privilege for DB user',
                            'cwe': 'CWE-89',
                            'owasp': 'A03:2021 - Injection',
                            'cvss': 9.8,
                            'references': [
                                'https://owasp.org/www-community/attacks/SQL_Injection',
                                'https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html'
                            ]
                        }
                        self.findings.append(finding)

    def test_info_disclosure(self):
        """Test for information disclosure"""

        urls = self.crawl_results.get('urls', [])

        sensitive_patterns = [
            ('Stack Trace', r'(Traceback|at .*\\.java:|File ".*", line \\d+)'),
            ('SQL Error', r'(SQL syntax|mysql_|PostgreSQL|ORA-|SQLite|ODBC)'),
            ('PHP Error', r'(Warning: |Fatal error: |Parse error: )'),
            ('ASP.NET Error', r'(Server Error|ASP\\.NET|System\\.Web)'),
            ('Debug Info', r'(DEBUG|debug_backtrace|var_dump|print_r)'),
            ('Internal IP', r'(10\\.\\d+\\.\\d+\\.\\d+|172\\.(1[6-9]|2[0-9]|3[0-1])\\.\\d+\\.\\d+|192\\.168\\.\\d+\\.\\d+)'),
            ('API Key', r'(api[_-]?key|apikey)["\']?\\s*[:=]\\s*["\']?[a-zA-Z0-9]{20,}'),
            ('AWS Key', r'AKIA[0-9A-Z]{16}'),
        ]

        for url in urls:
            # Claude Code will:
            # 1. Navigate to URL
            # 2. Capture response body and headers
            # 3. Search for sensitive patterns
            # 4. Check comments in source code

            # Example finding:
            for pattern_name, pattern_regex in sensitive_patterns:
                found = False  # Claude Code determines with regex

                if found:
                    finding = {
                        'type': 'Information Disclosure',
                        'severity': 'MEDIUM',
                        'url': url,
                        'description': f'{pattern_name} exposed in response',
                        'evidence': f'Pattern matched: {pattern_name}',
                        'impact': 'Sensitive information leakage aids further attacks',
                        'remediation': 'Disable debug mode, implement custom error pages, remove sensitive data from responses',
                        'cwe': 'CWE-200',
                        'owasp': 'A04:2021 - Insecure Design',
                        'cvss': 5.3,
                        'references': [
                            'https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url'
                        ]
                    }
                    self.findings.append(finding)

    def export_findings(self, output_file):
        """Export findings to JSON"""
        results = {
            'metadata': {
                'test_time': datetime.now().isoformat(),
                'total_findings': len(self.findings)
            },
            'findings': self.findings,
            'summary': self.get_summary()
        }

        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)

        print(f"[+] Findings exported to: {output_file}")

    def get_summary(self):
        """Get findings summary by severity"""
        summary = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0,
            'INFO': 0
        }

        for finding in self.findings:
            severity = finding.get('severity', 'INFO')
            summary[severity] = summary.get(severity, 0) + 1

        return summary

    def print_summary(self):
        """Print findings summary"""
        summary = self.get_summary()

        print(f"\n{'='*60}")
        print("Vulnerability Testing Summary")
        print(f"{'='*60}\n")

        print(f"Total Findings: {len(self.findings)}\n")

        print("By Severity:")
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
            count = summary.get(severity, 0)
            if count > 0:
                print(f"  {severity}: {count}")

def main():
    parser = argparse.ArgumentParser(
        description="Vulnerability Testing Engine",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Test vulnerabilities from crawl results
  %(prog)s --crawl-results crawl.json --output findings.json

Note: This script works WITH Claude Code's Playwright MCP integration.
      Claude Code orchestrates actual testing operations.
        """
    )

    parser.add_argument('--crawl-results', '-c', required=True,
                       help='Crawl results JSON file')
    parser.add_argument('--output', '-o', required=True,
                       help='Output findings JSON file')

    args = parser.parse_args()

    print(f"\n{'='*60}")
    print("Vulnerability Testing Engine")
    print(f"{'='*60}\n")

    # Initialize tester
    tester = VulnerabilityTester(args.crawl_results)

    # Run all tests
    findings = tester.test_all()

    # Export findings
    tester.export_findings(args.output)

    # Print summary
    tester.print_summary()

if __name__ == '__main__':
    main()
