/**
 * iOS Keychain Monitoring
 * Hooks keychain operations to log stored/retrieved data
 */

if (ObjC.available) {
    console.log("[*] iOS Keychain Hooks loaded");

    // Keychain accessibility constants
    var accessibilityLabels = {
        "ak": "kSecAttrAccessibleWhenUnlocked",
        "ck": "kSecAttrAccessibleAfterFirstUnlock",
        "dk": "kSecAttrAccessibleAlways",
        "aku": "kSecAttrAccessibleWhenUnlockedThisDeviceOnly",
        "cku": "kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly",
        "dku": "kSecAttrAccessibleAlwaysThisDeviceOnly",
        "akpu": "kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly"
    };

    // Hook SecItemAdd
    try {
        var SecItemAdd = Module.findExportByName("Security", "SecItemAdd");
        if (SecItemAdd) {
            Interceptor.attach(SecItemAdd, {
                onEnter: function(args) {
                    var query = new ObjC.Object(args[0]);
                    console.log("\n[KEYCHAIN ADD]");
                    console.log("    Query: " + query.toString());

                    // Extract common attributes
                    if (query.objectForKey_) {
                        var service = query.objectForKey_("svce");
                        var account = query.objectForKey_("acct");
                        var data = query.objectForKey_("v_Data");
                        var accessible = query.objectForKey_("pdmn");

                        if (service) console.log("    Service: " + service);
                        if (account) console.log("    Account: " + account);
                        if (accessible) {
                            var label = accessibilityLabels[accessible.toString()] || accessible.toString();
                            console.log("    Accessibility: " + label);
                        }
                        if (data) {
                            try {
                                var nsdata = new ObjC.Object(data);
                                var str = nsdata.bytes().readUtf8String(nsdata.length());
                                console.log("    Data: " + str);
                            } catch (e) {
                                console.log("    Data: [binary data]");
                            }
                        }
                    }
                },
                onLeave: function(retval) {
                    var status = retval.toInt32();
                    console.log("    Result: " + (status === 0 ? "Success" : "Error " + status));
                }
            });
        }
    } catch (e) {
        console.log("[-] SecItemAdd hook failed: " + e);
    }

    // Hook SecItemCopyMatching
    try {
        var SecItemCopyMatching = Module.findExportByName("Security", "SecItemCopyMatching");
        if (SecItemCopyMatching) {
            Interceptor.attach(SecItemCopyMatching, {
                onEnter: function(args) {
                    this.resultPtr = args[1];
                    var query = new ObjC.Object(args[0]);
                    console.log("\n[KEYCHAIN READ]");

                    if (query.objectForKey_) {
                        var service = query.objectForKey_("svce");
                        var account = query.objectForKey_("acct");

                        if (service) console.log("    Service: " + service);
                        if (account) console.log("    Account: " + account);
                    }
                },
                onLeave: function(retval) {
                    var status = retval.toInt32();
                    if (status === 0 && this.resultPtr) {
                        try {
                            var result = new ObjC.Object(this.resultPtr.readPointer());

                            if (result.$className === '__NSDictionaryM' || result.$className === '__NSDictionaryI') {
                                var data = result.objectForKey_("v_Data");
                                if (data) {
                                    try {
                                        var nsdata = new ObjC.Object(data);
                                        var str = nsdata.bytes().readUtf8String(nsdata.length());
                                        console.log("    Retrieved: " + str);
                                    } catch (e) {
                                        console.log("    Retrieved: [binary data]");
                                    }
                                }
                            } else if (result.$className === 'NSData' || result.$className === '_NSInlineData') {
                                try {
                                    var str = result.bytes().readUtf8String(result.length());
                                    console.log("    Retrieved: " + str);
                                } catch (e) {
                                    console.log("    Retrieved: [binary data]");
                                }
                            }
                        } catch (e) {
                            // Silently fail on parsing errors
                        }
                    } else {
                        console.log("    Result: " + (status === -25300 ? "Item not found" : "Error " + status));
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] SecItemCopyMatching hook failed: " + e);
    }

    // Hook SecItemUpdate
    try {
        var SecItemUpdate = Module.findExportByName("Security", "SecItemUpdate");
        if (SecItemUpdate) {
            Interceptor.attach(SecItemUpdate, {
                onEnter: function(args) {
                    var query = new ObjC.Object(args[0]);
                    var update = new ObjC.Object(args[1]);
                    console.log("\n[KEYCHAIN UPDATE]");
                    console.log("    Query: " + query.toString());
                    console.log("    Update: " + update.toString());
                },
                onLeave: function(retval) {
                    var status = retval.toInt32();
                    console.log("    Result: " + (status === 0 ? "Success" : "Error " + status));
                }
            });
        }
    } catch (e) {
        console.log("[-] SecItemUpdate hook failed: " + e);
    }

    // Hook SecItemDelete
    try {
        var SecItemDelete = Module.findExportByName("Security", "SecItemDelete");
        if (SecItemDelete) {
            Interceptor.attach(SecItemDelete, {
                onEnter: function(args) {
                    var query = new ObjC.Object(args[0]);
                    console.log("\n[KEYCHAIN DELETE]");
                    console.log("    Query: " + query.toString());
                },
                onLeave: function(retval) {
                    var status = retval.toInt32();
                    console.log("    Result: " + (status === 0 ? "Success" : "Error " + status));
                }
            });
        }
    } catch (e) {
        console.log("[-] SecItemDelete hook failed: " + e);
    }

    console.log("[*] Keychain hooks installed");

} else {
    console.log("[-] Objective-C runtime not available");
}
