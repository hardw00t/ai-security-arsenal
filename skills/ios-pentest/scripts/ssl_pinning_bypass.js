/*
 * iOS SSL Pinning Bypass - Universal Script
 * Supports: NSURLSession, AFNetworking, TrustKit, Alamofire, Custom implementations
 */

if (ObjC.available) {
    console.log("[*] iOS SSL Pinning Bypass loaded");

    // ============= NSURLSession =============
    try {
        var NSURLSession = ObjC.classes.NSURLSession;
        var NSURLSessionConfiguration = ObjC.classes.NSURLSessionConfiguration;

        // Hook URLSession:didReceiveChallenge:completionHandler:
        var resolver = new ApiResolver('objc');

        resolver.enumerateMatches('*[* URLSession:didReceiveChallenge:completionHandler:]', {
            onMatch: function(match) {
                console.log("[+] Found NSURLSession delegate: " + match.name);

                Interceptor.attach(match.address, {
                    onEnter: function(args) {
                        var challenge = new ObjC.Object(args[3]);
                        var protectionSpace = challenge.protectionSpace();
                        var authMethod = protectionSpace.authenticationMethod().toString();

                        if (authMethod === "NSURLAuthenticationMethodServerTrust") {
                            console.log("[SSL] Bypassing server trust challenge for: " + protectionSpace.host());

                            var completionHandler = new ObjC.Block(args[4]);
                            var credential = ObjC.classes.NSURLCredential.credentialForTrust_(protectionSpace.serverTrust());

                            completionHandler.implementation = function(disposition, cred) {
                                completionHandler.invoke(0, credential); // UseCredential = 0
                            };
                        }
                    }
                });
            },
            onComplete: function() {}
        });

        // Hook URLSession:task:didReceiveChallenge:completionHandler:
        resolver.enumerateMatches('*[* URLSession:task:didReceiveChallenge:completionHandler:]', {
            onMatch: function(match) {
                console.log("[+] Found NSURLSession task delegate: " + match.name);

                Interceptor.attach(match.address, {
                    onEnter: function(args) {
                        var challenge = new ObjC.Object(args[4]);
                        var protectionSpace = challenge.protectionSpace();
                        var authMethod = protectionSpace.authenticationMethod().toString();

                        if (authMethod === "NSURLAuthenticationMethodServerTrust") {
                            console.log("[SSL] Bypassing task server trust challenge");

                            var completionHandler = new ObjC.Block(args[5]);
                            var credential = ObjC.classes.NSURLCredential.credentialForTrust_(protectionSpace.serverTrust());

                            completionHandler.implementation = function(disposition, cred) {
                                completionHandler.invoke(0, credential);
                            };
                        }
                    }
                });
            },
            onComplete: function() {}
        });

    } catch (e) {
        console.log("[-] NSURLSession hooks failed: " + e);
    }

    // ============= AFNetworking =============
    try {
        var AFSecurityPolicy = ObjC.classes.AFSecurityPolicy;
        if (AFSecurityPolicy) {
            console.log("[+] AFNetworking detected");

            // Hook setSSLPinningMode:
            Interceptor.attach(AFSecurityPolicy['- setSSLPinningMode:'].implementation, {
                onEnter: function(args) {
                    console.log("[SSL] AFNetworking: Setting pinning mode to None");
                    args[2] = ptr(0); // AFSSLPinningModeNone = 0
                }
            });

            // Hook setAllowInvalidCertificates:
            Interceptor.attach(AFSecurityPolicy['- setAllowInvalidCertificates:'].implementation, {
                onEnter: function(args) {
                    console.log("[SSL] AFNetworking: Allowing invalid certificates");
                    args[2] = ptr(1);
                }
            });

            // Hook evaluateServerTrust:forDomain:
            if (AFSecurityPolicy['- evaluateServerTrust:forDomain:']) {
                Interceptor.attach(AFSecurityPolicy['- evaluateServerTrust:forDomain:'].implementation, {
                    onLeave: function(retval) {
                        console.log("[SSL] AFNetworking: Bypassing evaluateServerTrust");
                        retval.replace(1);
                    }
                });
            }
        }
    } catch (e) {
        console.log("[-] AFNetworking hooks failed: " + e);
    }

    // ============= TrustKit =============
    try {
        var TrustKit = ObjC.classes.TrustKit;
        if (TrustKit) {
            console.log("[+] TrustKit detected");

            // Hook pinningValidator:shouldPinURL:
            if (TrustKit['+ pinningValidator:shouldPinURL:']) {
                Interceptor.attach(TrustKit['+ pinningValidator:shouldPinURL:'].implementation, {
                    onLeave: function(retval) {
                        console.log("[SSL] TrustKit: Bypassing shouldPinURL");
                        retval.replace(0);
                    }
                });
            }

            // Disable TrustKit logger
            if (TrustKit['+ setLoggerBlock:']) {
                Interceptor.attach(TrustKit['+ setLoggerBlock:'].implementation, {
                    onEnter: function(args) {
                        console.log("[SSL] TrustKit: Disabling logger");
                        args[2] = NULL;
                    }
                });
            }
        }

        var TSKPinningValidator = ObjC.classes.TSKPinningValidator;
        if (TSKPinningValidator) {
            Interceptor.attach(TSKPinningValidator['- evaluateTrust:forHostname:'].implementation, {
                onLeave: function(retval) {
                    console.log("[SSL] TrustKit: Bypassing evaluateTrust");
                    retval.replace(0); // TSKTrustDecisionShouldAllowConnection = 0
                }
            });
        }
    } catch (e) {
        console.log("[-] TrustKit hooks failed: " + e);
    }

    // ============= Alamofire =============
    try {
        // Alamofire 5.x ServerTrustManager
        var ServerTrustManager = ObjC.classes.ServerTrustManager;
        if (ServerTrustManager) {
            console.log("[+] Alamofire ServerTrustManager detected");

            if (ServerTrustManager['- serverTrustEvaluator:forHost:']) {
                Interceptor.attach(ServerTrustManager['- serverTrustEvaluator:forHost:'].implementation, {
                    onLeave: function(retval) {
                        console.log("[SSL] Alamofire: Bypassing serverTrustEvaluator");
                        retval.replace(NULL);
                    }
                });
            }
        }
    } catch (e) {
        console.log("[-] Alamofire hooks failed: " + e);
    }

    // ============= Custom SecTrust =============
    try {
        // Hook SecTrustEvaluateWithError
        var SecTrustEvaluateWithError = Module.findExportByName('Security', 'SecTrustEvaluateWithError');
        if (SecTrustEvaluateWithError) {
            Interceptor.attach(SecTrustEvaluateWithError, {
                onLeave: function(retval) {
                    console.log("[SSL] SecTrustEvaluateWithError: Returning true");
                    retval.replace(1);
                }
            });
        }

        // Hook SecTrustEvaluate (deprecated but still used)
        var SecTrustEvaluate = Module.findExportByName('Security', 'SecTrustEvaluate');
        if (SecTrustEvaluate) {
            Interceptor.attach(SecTrustEvaluate, {
                onLeave: function(retval) {
                    console.log("[SSL] SecTrustEvaluate: Returning success");
                    retval.replace(0); // errSecSuccess = 0
                }
            });
        }

        // Hook SecTrustGetTrustResult
        var SecTrustGetTrustResult = Module.findExportByName('Security', 'SecTrustGetTrustResult');
        if (SecTrustGetTrustResult) {
            Interceptor.attach(SecTrustGetTrustResult, {
                onLeave: function(retval) {
                    // Set result to kSecTrustResultProceed
                    if (this.resultPtr) {
                        Memory.writeU32(this.resultPtr, 1);
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] SecTrust hooks failed: " + e);
    }

    // ============= BoringSSL (used by some apps) =============
    try {
        var SSL_CTX_set_custom_verify = Module.findExportByName(null, 'SSL_CTX_set_custom_verify');
        if (SSL_CTX_set_custom_verify) {
            Interceptor.attach(SSL_CTX_set_custom_verify, {
                onEnter: function(args) {
                    console.log("[SSL] BoringSSL: Bypassing custom verify");
                    // Set callback to always succeed
                    args[2] = new NativeCallback(function() {
                        return 0; // ssl_verify_ok
                    }, 'int', ['pointer', 'pointer']);
                }
            });
        }
    } catch (e) {
        console.log("[-] BoringSSL hooks failed: " + e);
    }

    console.log("[*] SSL Pinning Bypass active - all methods hooked");

} else {
    console.log("[-] Objective-C runtime not available");
}
