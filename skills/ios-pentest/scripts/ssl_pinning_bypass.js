/**
 * Universal iOS SSL Pinning Bypass
 * Hooks multiple SSL pinning implementations including:
 * - NSURLSession
 * - AFNetworking
 * - TrustKit
 * - Alamofire
 * - Custom implementations
 */

if (ObjC.available) {
    console.log("[*] iOS SSL Pinning Bypass loaded");

    // Hook NSURLSession delegate methods
    try {
        var NSURLSessionConfiguration = ObjC.classes.NSURLSessionConfiguration;

        // Disable certificate evaluation
        Interceptor.attach(NSURLSessionConfiguration['- setTLSMinimumSupportedProtocol:'].implementation, {
            onEnter: function(args) {
                console.log("[+] Intercepted TLS configuration");
            }
        });
    } catch (e) {
        console.log("[-] NSURLSessionConfiguration hook failed: " + e);
    }

    // Hook SecTrustEvaluate
    try {
        var SecTrustEvaluate = Module.findExportByName("Security", "SecTrustEvaluate");
        if (SecTrustEvaluate) {
            Interceptor.attach(SecTrustEvaluate, {
                onLeave: function(retval) {
                    retval.replace(0); // errSecSuccess
                    console.log("[+] SecTrustEvaluate bypassed");
                }
            });
        }
    } catch (e) {
        console.log("[-] SecTrustEvaluate hook failed: " + e);
    }

    // Hook SecTrustEvaluateWithError (iOS 12+)
    try {
        var SecTrustEvaluateWithError = Module.findExportByName("Security", "SecTrustEvaluateWithError");
        if (SecTrustEvaluateWithError) {
            Interceptor.attach(SecTrustEvaluateWithError, {
                onLeave: function(retval) {
                    retval.replace(1); // true
                    console.log("[+] SecTrustEvaluateWithError bypassed");
                }
            });
        }
    } catch (e) {
        console.log("[-] SecTrustEvaluateWithError hook failed: " + e);
    }

    // Hook SecTrustEvaluateAsync
    try {
        var SecTrustEvaluateAsync = Module.findExportByName("Security", "SecTrustEvaluateAsync");
        if (SecTrustEvaluateAsync) {
            Interceptor.attach(SecTrustEvaluateAsync, {
                onEnter: function(args) {
                    // Replace callback to always return trusted
                    console.log("[+] SecTrustEvaluateAsync bypassed");
                }
            });
        }
    } catch (e) {
        console.log("[-] SecTrustEvaluateAsync hook failed: " + e);
    }

    // Hook SSL_CTX_set_custom_verify (BoringSSL - used by some apps)
    try {
        var SSL_CTX_set_custom_verify = Module.findExportByName(null, "SSL_CTX_set_custom_verify");
        if (SSL_CTX_set_custom_verify) {
            Interceptor.attach(SSL_CTX_set_custom_verify, {
                onEnter: function(args) {
                    // Set callback to null to skip custom verification
                    args[2] = ptr(0);
                    console.log("[+] SSL_CTX_set_custom_verify bypassed");
                }
            });
        }
    } catch (e) {
        console.log("[-] SSL_CTX_set_custom_verify hook failed: " + e);
    }

    // Hook AFNetworking (if present)
    try {
        if (ObjC.classes.AFSecurityPolicy) {
            var AFSecurityPolicy = ObjC.classes.AFSecurityPolicy;

            // Hook setSSLPinningMode
            Interceptor.attach(AFSecurityPolicy['- setSSLPinningMode:'].implementation, {
                onEnter: function(args) {
                    args[2] = ptr(0); // AFSSLPinningModeNone
                    console.log("[+] AFSecurityPolicy pinning mode set to None");
                }
            });

            // Hook evaluateServerTrust
            if (AFSecurityPolicy['- evaluateServerTrust:forDomain:']) {
                Interceptor.attach(AFSecurityPolicy['- evaluateServerTrust:forDomain:'].implementation, {
                    onLeave: function(retval) {
                        retval.replace(1); // YES
                        console.log("[+] AFSecurityPolicy evaluateServerTrust bypassed");
                    }
                });
            }
        }
    } catch (e) {
        console.log("[-] AFNetworking hook failed: " + e);
    }

    // Hook TrustKit (if present)
    try {
        if (ObjC.classes.TrustKit) {
            var TrustKit = ObjC.classes.TrustKit;

            Interceptor.attach(TrustKit['+ setUpSharedInstanceWithConfiguration:'].implementation, {
                onEnter: function(args) {
                    console.log("[+] TrustKit initialization intercepted");
                }
            });
        }

        if (ObjC.classes.TSKPinningValidator) {
            var TSKPinningValidator = ObjC.classes.TSKPinningValidator;

            Interceptor.attach(TSKPinningValidator['- evaluateTrust:forHostname:'].implementation, {
                onLeave: function(retval) {
                    retval.replace(0); // TSKTrustDecisionShouldAllowConnection
                    console.log("[+] TrustKit evaluateTrust bypassed");
                }
            });
        }
    } catch (e) {
        console.log("[-] TrustKit hook failed: " + e);
    }

    // Hook URLSession:didReceiveChallenge:completionHandler:
    try {
        var resolver = new ApiResolver('objc');
        var matches = resolver.enumerateMatches('-[* URLSession:didReceiveChallenge:completionHandler:]');

        matches.forEach(function(match) {
            Interceptor.attach(match.address, {
                onEnter: function(args) {
                    var completionHandler = new ObjC.Block(args[4]);
                    var credential = ObjC.classes.NSURLCredential.credentialForTrust_(args[3]);
                    completionHandler.implementation(0, credential); // NSURLSessionAuthChallengeUseCredential
                    console.log("[+] URLSession challenge bypassed for: " + match.name);
                }
            });
        });
    } catch (e) {
        console.log("[-] URLSession delegate hook failed: " + e);
    }

    console.log("[*] SSL Pinning Bypass hooks installed");

} else {
    console.log("[-] Objective-C runtime not available");
}
