/**
 * iOS Cryptography Monitoring
 * Hooks CommonCrypto and Security framework operations
 */

if (ObjC.available) {
    console.log("[*] iOS Crypto Hooks loaded");

    // CCCrypt hook - symmetric encryption/decryption
    try {
        var CCCrypt = Module.findExportByName("libcommonCrypto.dylib", "CCCrypt");
        if (CCCrypt) {
            Interceptor.attach(CCCrypt, {
                onEnter: function(args) {
                    var operation = args[0].toInt32();
                    var algorithm = args[1].toInt32();
                    var options = args[2].toInt32();
                    var keyLength = args[4].toInt32();
                    var dataInLength = args[7].toInt32();

                    var operations = ["Encrypt", "Decrypt"];
                    var algorithms = ["AES128", "DES", "3DES", "CAST", "RC4", "RC2", "Blowfish", "AES"];

                    console.log("\n[CRYPTO] CCCrypt");
                    console.log("    Operation: " + (operations[operation] || operation));
                    console.log("    Algorithm: " + (algorithms[algorithm] || algorithm));
                    console.log("    Key Length: " + keyLength + " bytes");
                    console.log("    Data Length: " + dataInLength + " bytes");

                    // Options
                    var optionFlags = [];
                    if (options & 0x0001) optionFlags.push("PKCS7Padding");
                    if (options & 0x0002) optionFlags.push("ECBMode");
                    console.log("    Options: " + (optionFlags.length > 0 ? optionFlags.join(", ") : "None"));

                    // Log key (be careful with this in production)
                    if (keyLength > 0 && keyLength <= 256) {
                        var key = args[3].readByteArray(keyLength);
                        console.log("    Key: " + hexdump(key, {length: keyLength, header: false}));
                    }

                    // Store for onLeave
                    this.dataOut = args[8];
                    this.dataOutLength = args[10];
                },
                onLeave: function(retval) {
                    if (retval.toInt32() === 0 && this.dataOut && this.dataOutLength) {
                        try {
                            var outLen = this.dataOutLength.readU32();
                            if (outLen > 0 && outLen < 1024) {
                                var output = this.dataOut.readByteArray(outLen);
                                console.log("    Output: " + hexdump(output, {length: outLen, header: false}));
                            }
                        } catch (e) {}
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] CCCrypt hook failed: " + e);
    }

    // CCHmac hook - HMAC operations
    try {
        var CCHmac = Module.findExportByName("libcommonCrypto.dylib", "CCHmac");
        if (CCHmac) {
            Interceptor.attach(CCHmac, {
                onEnter: function(args) {
                    var algorithm = args[0].toInt32();
                    var keyLength = args[2].toInt32();
                    var dataLength = args[4].toInt32();

                    var algorithms = ["MD5", "SHA1", "SHA224", "SHA256", "SHA384", "SHA512"];

                    console.log("\n[CRYPTO] CCHmac");
                    console.log("    Algorithm: HMAC-" + (algorithms[algorithm] || algorithm));
                    console.log("    Key Length: " + keyLength);
                    console.log("    Data Length: " + dataLength);

                    if (keyLength > 0 && keyLength <= 256) {
                        var key = args[1].readByteArray(keyLength);
                        console.log("    Key: " + hexdump(key, {length: keyLength, header: false}));
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] CCHmac hook failed: " + e);
    }

    // CC_SHA256 hook
    try {
        var CC_SHA256 = Module.findExportByName("libcommonCrypto.dylib", "CC_SHA256");
        if (CC_SHA256) {
            Interceptor.attach(CC_SHA256, {
                onEnter: function(args) {
                    var dataLength = args[1].toInt32();
                    console.log("\n[CRYPTO] CC_SHA256");
                    console.log("    Data Length: " + dataLength);

                    if (dataLength > 0 && dataLength < 1024) {
                        try {
                            var data = args[0].readUtf8String(dataLength);
                            console.log("    Data: " + data);
                        } catch (e) {
                            console.log("    Data: [binary]");
                        }
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] CC_SHA256 hook failed: " + e);
    }

    // SecKeyEncrypt hook - RSA encryption
    try {
        var SecKeyEncrypt = Module.findExportByName("Security", "SecKeyEncrypt");
        if (SecKeyEncrypt) {
            Interceptor.attach(SecKeyEncrypt, {
                onEnter: function(args) {
                    var padding = args[1].toInt32();
                    var plainTextLen = args[3].toInt32();

                    var paddings = {
                        0: "None",
                        1: "PKCS1",
                        2: "OAEP"
                    };

                    console.log("\n[CRYPTO] SecKeyEncrypt (RSA)");
                    console.log("    Padding: " + (paddings[padding] || padding));
                    console.log("    Plaintext Length: " + plainTextLen);

                    if (plainTextLen > 0 && plainTextLen < 1024) {
                        try {
                            var plaintext = args[2].readUtf8String(plainTextLen);
                            console.log("    Plaintext: " + plaintext);
                        } catch (e) {
                            var data = args[2].readByteArray(plainTextLen);
                            console.log("    Plaintext: " + hexdump(data, {length: plainTextLen, header: false}));
                        }
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] SecKeyEncrypt hook failed: " + e);
    }

    // SecKeyDecrypt hook - RSA decryption
    try {
        var SecKeyDecrypt = Module.findExportByName("Security", "SecKeyDecrypt");
        if (SecKeyDecrypt) {
            Interceptor.attach(SecKeyDecrypt, {
                onEnter: function(args) {
                    var padding = args[1].toInt32();
                    var cipherTextLen = args[3].toInt32();

                    console.log("\n[CRYPTO] SecKeyDecrypt (RSA)");
                    console.log("    Ciphertext Length: " + cipherTextLen);

                    this.plainTextPtr = args[4];
                    this.plainTextLenPtr = args[5];
                },
                onLeave: function(retval) {
                    if (retval.toInt32() === 0 && this.plainTextPtr && this.plainTextLenPtr) {
                        try {
                            var len = this.plainTextLenPtr.readU32();
                            if (len > 0 && len < 1024) {
                                var plaintext = this.plainTextPtr.readUtf8String(len);
                                console.log("    Decrypted: " + plaintext);
                            }
                        } catch (e) {}
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] SecKeyDecrypt hook failed: " + e);
    }

    // Hook NSData base64 encoding/decoding
    try {
        var NSData = ObjC.classes.NSData;

        // base64EncodedStringWithOptions:
        Interceptor.attach(NSData['- base64EncodedStringWithOptions:'].implementation, {
            onEnter: function(args) {
                var data = new ObjC.Object(args[0]);
                console.log("\n[CRYPTO] Base64 Encode");
                console.log("    Length: " + data.length());
            }
        });

        // initWithBase64EncodedString:options:
        Interceptor.attach(NSData['- initWithBase64EncodedString:options:'].implementation, {
            onEnter: function(args) {
                var base64 = new ObjC.Object(args[2]);
                console.log("\n[CRYPTO] Base64 Decode");
                console.log("    Input: " + base64.toString());
            }
        });
    } catch (e) {
        console.log("[-] NSData Base64 hook failed: " + e);
    }

    console.log("[*] Crypto hooks installed");

} else {
    console.log("[-] Objective-C runtime not available");
}

// Helper function
function hexdump(buffer, options) {
    var hex = '';
    var bytes = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length && i < (options.length || bytes.length); i++) {
        hex += ('0' + bytes[i].toString(16)).slice(-2);
    }
    return hex;
}
