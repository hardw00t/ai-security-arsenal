/*
 * iOS Jailbreak Detection Bypass - Comprehensive Script
 * Bypasses common jailbreak detection methods
 */

if (ObjC.available) {
    console.log("[*] iOS Jailbreak Detection Bypass loaded");

    // ============= Known Jailbreak Paths =============
    var jailbreakPaths = [
        "/Applications/Cydia.app",
        "/Applications/Sileo.app",
        "/Applications/Zebra.app",
        "/Applications/Installer.app",
        "/Applications/Icy.app",
        "/Applications/blackra1n.app",
        "/Applications/FakeCarrier.app",
        "/Applications/SBSettings.app",
        "/Applications/MobileTerminal.app",
        "/Applications/RockApp.app",
        "/Applications/WinterBoard.app",
        "/Library/MobileSubstrate/MobileSubstrate.dylib",
        "/Library/MobileSubstrate/DynamicLibraries/",
        "/var/cache/apt",
        "/var/lib/apt",
        "/var/lib/cydia",
        "/var/log/syslog",
        "/var/tmp/cydia.log",
        "/bin/bash",
        "/bin/sh",
        "/usr/sbin/sshd",
        "/usr/bin/sshd",
        "/usr/libexec/sftp-server",
        "/usr/bin/ssh",
        "/etc/apt",
        "/etc/ssh/sshd_config",
        "/private/var/lib/apt/",
        "/private/var/lib/cydia",
        "/private/var/mobile/Library/SBSettings/Themes",
        "/private/var/stash",
        "/private/var/tmp/cydia.log",
        "/System/Library/LaunchDaemons/com.ikey.bbot.plist",
        "/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist",
        "/usr/libexec/cydia/",
        "/usr/bin/cycript",
        "/usr/local/bin/cycript",
        "/usr/lib/libcycript.dylib",
        "/usr/bin/frida-server",
        "/usr/local/bin/frida-server",
        "/.bootstrapped_electra",
        "/usr/lib/libjailbreak.dylib",
        "/jb/lzma",
        "/.cydia_no_stash",
        "/.installed_unc0ver",
        "/jb/offsets.plist",
        "/usr/share/jailbreak/injectme.plist",
        "/Library/MobileSubstrate/DynamicLibraries/Veency.plist",
        "/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist",
        "/System/Library/LaunchDaemons/com.ikey.bbot.plist",
        "/var/checkra1n.dmg",
        "/var/binpack"
    ];

    // ============= Jailbreak URL Schemes =============
    var jailbreakSchemes = [
        "cydia://",
        "sileo://",
        "zbra://",
        "filza://",
        "activator://"
    ];

    // ============= NSFileManager Hooks =============
    try {
        var NSFileManager = ObjC.classes.NSFileManager;

        // Hook fileExistsAtPath:
        Interceptor.attach(NSFileManager['- fileExistsAtPath:'].implementation, {
            onEnter: function(args) {
                this.path = new ObjC.Object(args[2]).toString();
            },
            onLeave: function(retval) {
                for (var i = 0; i < jailbreakPaths.length; i++) {
                    if (this.path.indexOf(jailbreakPaths[i]) !== -1) {
                        console.log("[JB] Hiding path: " + this.path);
                        retval.replace(0);
                        return;
                    }
                }
            }
        });

        // Hook fileExistsAtPath:isDirectory:
        Interceptor.attach(NSFileManager['- fileExistsAtPath:isDirectory:'].implementation, {
            onEnter: function(args) {
                this.path = new ObjC.Object(args[2]).toString();
            },
            onLeave: function(retval) {
                for (var i = 0; i < jailbreakPaths.length; i++) {
                    if (this.path.indexOf(jailbreakPaths[i]) !== -1) {
                        console.log("[JB] Hiding path (isDir): " + this.path);
                        retval.replace(0);
                        return;
                    }
                }
            }
        });

        // Hook isReadableFileAtPath:
        Interceptor.attach(NSFileManager['- isReadableFileAtPath:'].implementation, {
            onEnter: function(args) {
                this.path = new ObjC.Object(args[2]).toString();
            },
            onLeave: function(retval) {
                for (var i = 0; i < jailbreakPaths.length; i++) {
                    if (this.path.indexOf(jailbreakPaths[i]) !== -1) {
                        console.log("[JB] Hiding readable: " + this.path);
                        retval.replace(0);
                        return;
                    }
                }
            }
        });

        // Hook isWritableFileAtPath:
        Interceptor.attach(NSFileManager['- isWritableFileAtPath:'].implementation, {
            onEnter: function(args) {
                this.path = new ObjC.Object(args[2]).toString();
            },
            onLeave: function(retval) {
                for (var i = 0; i < jailbreakPaths.length; i++) {
                    if (this.path.indexOf(jailbreakPaths[i]) !== -1) {
                        console.log("[JB] Hiding writable: " + this.path);
                        retval.replace(0);
                        return;
                    }
                }
            }
        });

        console.log("[+] NSFileManager hooks installed");

    } catch (e) {
        console.log("[-] NSFileManager hooks failed: " + e);
    }

    // ============= UIApplication Hooks =============
    try {
        var UIApplication = ObjC.classes.UIApplication;

        // Hook canOpenURL:
        Interceptor.attach(UIApplication['- canOpenURL:'].implementation, {
            onEnter: function(args) {
                this.url = new ObjC.Object(args[2]).toString();
            },
            onLeave: function(retval) {
                for (var i = 0; i < jailbreakSchemes.length; i++) {
                    if (this.url.indexOf(jailbreakSchemes[i]) !== -1) {
                        console.log("[JB] Blocking URL scheme: " + this.url);
                        retval.replace(0);
                        return;
                    }
                }
            }
        });

        console.log("[+] UIApplication hooks installed");

    } catch (e) {
        console.log("[-] UIApplication hooks failed: " + e);
    }

    // ============= C Library Hooks =============
    try {
        // Hook stat()
        var stat = Module.findExportByName(null, "stat");
        if (stat) {
            Interceptor.attach(stat, {
                onEnter: function(args) {
                    this.path = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    for (var i = 0; i < jailbreakPaths.length; i++) {
                        if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                            console.log("[JB] stat() hiding: " + this.path);
                            retval.replace(-1);
                            return;
                        }
                    }
                }
            });
        }

        // Hook lstat()
        var lstat = Module.findExportByName(null, "lstat");
        if (lstat) {
            Interceptor.attach(lstat, {
                onEnter: function(args) {
                    this.path = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    for (var i = 0; i < jailbreakPaths.length; i++) {
                        if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                            console.log("[JB] lstat() hiding: " + this.path);
                            retval.replace(-1);
                            return;
                        }
                    }
                }
            });
        }

        // Hook access()
        var access = Module.findExportByName(null, "access");
        if (access) {
            Interceptor.attach(access, {
                onEnter: function(args) {
                    this.path = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    for (var i = 0; i < jailbreakPaths.length; i++) {
                        if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                            console.log("[JB] access() hiding: " + this.path);
                            retval.replace(-1);
                            return;
                        }
                    }
                }
            });
        }

        // Hook fopen()
        var fopen = Module.findExportByName(null, "fopen");
        if (fopen) {
            Interceptor.attach(fopen, {
                onEnter: function(args) {
                    this.path = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    for (var i = 0; i < jailbreakPaths.length; i++) {
                        if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                            console.log("[JB] fopen() hiding: " + this.path);
                            retval.replace(ptr(0));
                            return;
                        }
                    }
                }
            });
        }

        // Hook open()
        var open = Module.findExportByName(null, "open");
        if (open) {
            Interceptor.attach(open, {
                onEnter: function(args) {
                    this.path = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    for (var i = 0; i < jailbreakPaths.length; i++) {
                        if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                            console.log("[JB] open() hiding: " + this.path);
                            retval.replace(-1);
                            return;
                        }
                    }
                }
            });
        }

        console.log("[+] C library hooks installed");

    } catch (e) {
        console.log("[-] C library hooks failed: " + e);
    }

    // ============= Fork Detection =============
    try {
        var fork = Module.findExportByName(null, "fork");
        if (fork) {
            Interceptor.attach(fork, {
                onLeave: function(retval) {
                    console.log("[JB] Blocking fork()");
                    retval.replace(-1);
                }
            });
        }

        console.log("[+] Fork hook installed");

    } catch (e) {
        console.log("[-] Fork hook failed: " + e);
    }

    // ============= System() Detection =============
    try {
        var system = Module.findExportByName(null, "system");
        if (system) {
            Interceptor.attach(system, {
                onEnter: function(args) {
                    var cmd = args[0].readUtf8String();
                    console.log("[JB] system() called: " + cmd);
                },
                onLeave: function(retval) {
                    retval.replace(1); // Return 1 to indicate command not found
                }
            });
        }

        console.log("[+] System hook installed");

    } catch (e) {
        console.log("[-] System hook failed: " + e);
    }

    // ============= popen() Detection =============
    try {
        var popen = Module.findExportByName(null, "popen");
        if (popen) {
            Interceptor.attach(popen, {
                onEnter: function(args) {
                    var cmd = args[0].readUtf8String();
                    console.log("[JB] popen() called: " + cmd);
                },
                onLeave: function(retval) {
                    retval.replace(ptr(0));
                }
            });
        }

        console.log("[+] popen hook installed");

    } catch (e) {
        console.log("[-] popen hook failed: " + e);
    }

    // ============= dyld Detection =============
    try {
        var _dyld_get_image_name = Module.findExportByName(null, "_dyld_get_image_name");
        if (_dyld_get_image_name) {
            Interceptor.attach(_dyld_get_image_name, {
                onLeave: function(retval) {
                    var name = retval.readUtf8String();
                    if (name) {
                        var suspicious = ["Substrate", "cycript", "frida", "substitute"];
                        for (var i = 0; i < suspicious.length; i++) {
                            if (name.toLowerCase().indexOf(suspicious[i]) !== -1) {
                                console.log("[JB] Hiding dylib: " + name);
                                retval.replace(ptr(0));
                                return;
                            }
                        }
                    }
                }
            });
        }

        console.log("[+] dyld hook installed");

    } catch (e) {
        console.log("[-] dyld hook failed: " + e);
    }

    // ============= getenv Detection =============
    try {
        var getenv = Module.findExportByName(null, "getenv");
        if (getenv) {
            Interceptor.attach(getenv, {
                onEnter: function(args) {
                    this.name = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    var suspicious = ["DYLD_INSERT_LIBRARIES", "FRIDA"];
                    for (var i = 0; i < suspicious.length; i++) {
                        if (this.name && this.name.indexOf(suspicious[i]) !== -1) {
                            console.log("[JB] Hiding env: " + this.name);
                            retval.replace(ptr(0));
                            return;
                        }
                    }
                }
            });
        }

        console.log("[+] getenv hook installed");

    } catch (e) {
        console.log("[-] getenv hook failed: " + e);
    }

    console.log("[*] Jailbreak Detection Bypass active - all methods hooked");

} else {
    console.log("[-] Objective-C runtime not available");
}
