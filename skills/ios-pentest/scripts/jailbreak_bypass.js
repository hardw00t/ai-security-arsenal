/**
 * iOS Jailbreak Detection Bypass
 * Hooks common jailbreak detection methods including:
 * - File existence checks
 * - URL scheme checks
 * - Sandbox escape checks
 * - Fork detection
 * - Dylib detection
 */

if (ObjC.available) {
    console.log("[*] iOS Jailbreak Detection Bypass loaded");

    // Jailbreak-related paths to hide
    var jailbreakPaths = [
        "/Applications/Cydia.app",
        "/Applications/Sileo.app",
        "/Applications/Zebra.app",
        "/Applications/blackra1n.app",
        "/Applications/FakeCarrier.app",
        "/Applications/Icy.app",
        "/Applications/IntelliScreen.app",
        "/Applications/MxTube.app",
        "/Applications/RockApp.app",
        "/Applications/SBSettings.app",
        "/Applications/WinterBoard.app",
        "/Library/MobileSubstrate/DynamicLibraries",
        "/Library/MobileSubstrate/MobileSubstrate.dylib",
        "/bin/bash",
        "/bin/sh",
        "/etc/apt",
        "/etc/ssh/sshd_config",
        "/private/var/lib/apt",
        "/private/var/lib/cydia",
        "/private/var/mobile/Library/SBSettings/Themes",
        "/private/var/stash",
        "/private/var/tmp/cydia.log",
        "/usr/bin/cycript",
        "/usr/bin/ssh",
        "/usr/bin/sshd",
        "/usr/lib/libcycript.dylib",
        "/usr/libexec/sftp-server",
        "/usr/libexec/ssh-keysign",
        "/usr/sbin/frida-server",
        "/usr/sbin/sshd",
        "/var/cache/apt",
        "/var/lib/cydia",
        "/var/log/syslog",
        "/var/tmp/cydia.log",
        "/.installed_unc0ver",
        "/.bootstrapped_electra",
        "/jb"
    ];

    // Jailbreak URL schemes
    var jailbreakSchemes = [
        "cydia://",
        "sileo://",
        "zbra://",
        "filza://",
        "activator://"
    ];

    // Hook NSFileManager fileExistsAtPath:
    try {
        var NSFileManager = ObjC.classes.NSFileManager;
        var fileExistsAtPath = NSFileManager['- fileExistsAtPath:'];

        Interceptor.attach(fileExistsAtPath.implementation, {
            onEnter: function(args) {
                this.path = ObjC.Object(args[2]).toString();
            },
            onLeave: function(retval) {
                for (var i = 0; i < jailbreakPaths.length; i++) {
                    if (this.path.indexOf(jailbreakPaths[i]) !== -1) {
                        retval.replace(0); // NO
                        console.log("[+] Hiding path: " + this.path);
                        return;
                    }
                }
            }
        });
    } catch (e) {
        console.log("[-] NSFileManager hook failed: " + e);
    }

    // Hook stat/lstat
    try {
        var stat = Module.findExportByName(null, "stat");
        var lstat = Module.findExportByName(null, "lstat");

        [stat, lstat].forEach(function(func) {
            if (func) {
                Interceptor.attach(func, {
                    onEnter: function(args) {
                        this.path = args[0].readUtf8String();
                    },
                    onLeave: function(retval) {
                        for (var i = 0; i < jailbreakPaths.length; i++) {
                            if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                                retval.replace(-1);
                                console.log("[+] stat hiding: " + this.path);
                                return;
                            }
                        }
                    }
                });
            }
        });
    } catch (e) {
        console.log("[-] stat/lstat hook failed: " + e);
    }

    // Hook access()
    try {
        var access = Module.findExportByName(null, "access");
        if (access) {
            Interceptor.attach(access, {
                onEnter: function(args) {
                    this.path = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    for (var i = 0; i < jailbreakPaths.length; i++) {
                        if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                            retval.replace(-1);
                            console.log("[+] access hiding: " + this.path);
                            return;
                        }
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] access hook failed: " + e);
    }

    // Hook fopen()
    try {
        var fopen = Module.findExportByName(null, "fopen");
        if (fopen) {
            Interceptor.attach(fopen, {
                onEnter: function(args) {
                    this.path = args[0].readUtf8String();
                },
                onLeave: function(retval) {
                    for (var i = 0; i < jailbreakPaths.length; i++) {
                        if (this.path && this.path.indexOf(jailbreakPaths[i]) !== -1) {
                            retval.replace(ptr(0)); // NULL
                            console.log("[+] fopen hiding: " + this.path);
                            return;
                        }
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] fopen hook failed: " + e);
    }

    // Hook UIApplication canOpenURL:
    try {
        var UIApplication = ObjC.classes.UIApplication;
        var canOpenURL = UIApplication['- canOpenURL:'];

        Interceptor.attach(canOpenURL.implementation, {
            onEnter: function(args) {
                this.url = ObjC.Object(args[2]).toString();
            },
            onLeave: function(retval) {
                for (var i = 0; i < jailbreakSchemes.length; i++) {
                    if (this.url.indexOf(jailbreakSchemes[i]) !== -1) {
                        retval.replace(0); // NO
                        console.log("[+] Hiding URL scheme: " + this.url);
                        return;
                    }
                }
            }
        });
    } catch (e) {
        console.log("[-] canOpenURL hook failed: " + e);
    }

    // Hook fork() - some apps check if fork succeeds
    try {
        var fork = Module.findExportByName(null, "fork");
        if (fork) {
            Interceptor.attach(fork, {
                onLeave: function(retval) {
                    retval.replace(-1); // Simulate fork failure
                    console.log("[+] fork() blocked");
                }
            });
        }
    } catch (e) {
        console.log("[-] fork hook failed: " + e);
    }

    // Hook system() - prevent shell execution checks
    try {
        var system = Module.findExportByName(null, "system");
        if (system) {
            Interceptor.attach(system, {
                onEnter: function(args) {
                    var cmd = args[0].readUtf8String();
                    console.log("[+] system() intercepted: " + cmd);
                },
                onLeave: function(retval) {
                    retval.replace(-1);
                }
            });
        }
    } catch (e) {
        console.log("[-] system hook failed: " + e);
    }

    // Hook popen() - prevent shell execution checks
    try {
        var popen = Module.findExportByName(null, "popen");
        if (popen) {
            Interceptor.attach(popen, {
                onEnter: function(args) {
                    var cmd = args[0].readUtf8String();
                    console.log("[+] popen() intercepted: " + cmd);
                },
                onLeave: function(retval) {
                    retval.replace(ptr(0)); // NULL
                }
            });
        }
    } catch (e) {
        console.log("[-] popen hook failed: " + e);
    }

    // Hook _dyld_image_count and _dyld_get_image_name to hide dylibs
    try {
        var _dyld_get_image_name = Module.findExportByName(null, "_dyld_get_image_name");
        if (_dyld_get_image_name) {
            Interceptor.attach(_dyld_get_image_name, {
                onLeave: function(retval) {
                    var name = retval.readUtf8String();
                    if (name && (name.indexOf("frida") !== -1 ||
                                 name.indexOf("substrate") !== -1 ||
                                 name.indexOf("cycript") !== -1)) {
                        retval.replace(Memory.allocUtf8String(""));
                        console.log("[+] Hiding dylib: " + name);
                    }
                }
            });
        }
    } catch (e) {
        console.log("[-] dyld hook failed: " + e);
    }

    console.log("[*] Jailbreak Detection Bypass hooks installed");

} else {
    console.log("[-] Objective-C runtime not available");
}
