/**
 * iOS Method Tracer
 * Generic Objective-C method tracing utility
 * Usage: frida -U -f com.app -l method_tracer.js --no-pause
 * Configure classes/methods to trace at bottom of file
 */

if (ObjC.available) {
    console.log("[*] iOS Method Tracer loaded");

    /**
     * Trace all methods of a class
     * @param {string} className - The class name to trace
     * @param {boolean} includeParent - Include parent class methods
     */
    function traceClass(className, includeParent) {
        try {
            var clazz = ObjC.classes[className];
            if (!clazz) {
                console.log("[-] Class not found: " + className);
                return;
            }

            var methods = clazz.$ownMethods;
            console.log("[+] Tracing " + methods.length + " methods in " + className);

            methods.forEach(function(method) {
                traceMethod(className, method);
            });

        } catch (e) {
            console.log("[-] Error tracing class: " + e);
        }
    }

    /**
     * Trace a specific method
     * @param {string} className - The class name
     * @param {string} methodName - The method name (e.g., "- login:" or "+ sharedInstance")
     */
    function traceMethod(className, methodName) {
        try {
            var clazz = ObjC.classes[className];
            if (!clazz) {
                console.log("[-] Class not found: " + className);
                return;
            }

            var method = clazz[methodName];
            if (!method) {
                console.log("[-] Method not found: " + className + " " + methodName);
                return;
            }

            Interceptor.attach(method.implementation, {
                onEnter: function(args) {
                    this.className = className;
                    this.methodName = methodName;

                    console.log("\n[CALL] " + className + " " + methodName);

                    // Parse method signature for argument types
                    var argCount = (methodName.match(/:/g) || []).length;

                    // Log arguments (args[0] is self, args[1] is _cmd, args[2+] are actual args)
                    for (var i = 0; i < argCount; i++) {
                        try {
                            var arg = new ObjC.Object(args[2 + i]);
                            console.log("    arg[" + i + "]: " + arg.toString());
                        } catch (e) {
                            try {
                                console.log("    arg[" + i + "]: " + args[2 + i]);
                            } catch (e2) {
                                console.log("    arg[" + i + "]: [unknown]");
                            }
                        }
                    }
                },
                onLeave: function(retval) {
                    try {
                        var ret = new ObjC.Object(retval);
                        console.log("    return: " + ret.toString());
                    } catch (e) {
                        console.log("    return: " + retval);
                    }
                }
            });

            console.log("[+] Hooked: " + className + " " + methodName);

        } catch (e) {
            console.log("[-] Error tracing method: " + e);
        }
    }

    /**
     * Search for classes matching pattern
     * @param {string} pattern - Pattern to search for
     */
    function searchClasses(pattern) {
        var matches = [];
        var regex = new RegExp(pattern, "i");

        for (var className in ObjC.classes) {
            if (regex.test(className)) {
                matches.push(className);
            }
        }

        console.log("[+] Found " + matches.length + " classes matching '" + pattern + "':");
        matches.forEach(function(name) {
            console.log("    " + name);
        });

        return matches;
    }

    /**
     * Search for methods matching pattern across all classes
     * @param {string} pattern - Pattern to search for
     */
    function searchMethods(pattern) {
        var matches = [];
        var regex = new RegExp(pattern, "i");

        for (var className in ObjC.classes) {
            var clazz = ObjC.classes[className];
            var methods = clazz.$ownMethods;

            methods.forEach(function(method) {
                if (regex.test(method)) {
                    matches.push(className + " " + method);
                }
            });
        }

        console.log("[+] Found " + matches.length + " methods matching '" + pattern + "':");
        matches.slice(0, 50).forEach(function(match) {
            console.log("    " + match);
        });

        if (matches.length > 50) {
            console.log("    ... and " + (matches.length - 50) + " more");
        }

        return matches;
    }

    /**
     * Trace methods matching a pattern in a class
     * @param {string} className - The class name
     * @param {string} pattern - Method pattern to match
     */
    function traceMethodsMatching(className, pattern) {
        var clazz = ObjC.classes[className];
        if (!clazz) {
            console.log("[-] Class not found: " + className);
            return;
        }

        var regex = new RegExp(pattern, "i");
        var methods = clazz.$ownMethods;
        var count = 0;

        methods.forEach(function(method) {
            if (regex.test(method)) {
                traceMethod(className, method);
                count++;
            }
        });

        console.log("[+] Traced " + count + " methods matching '" + pattern + "' in " + className);
    }

    // Expose functions globally for REPL use
    global.traceClass = traceClass;
    global.traceMethod = traceMethod;
    global.searchClasses = searchClasses;
    global.searchMethods = searchMethods;
    global.traceMethodsMatching = traceMethodsMatching;

    console.log("[*] Method Tracer ready");
    console.log("    Usage in Frida REPL:");
    console.log("    > searchClasses('Auth')");
    console.log("    > searchMethods('password')");
    console.log("    > traceClass('AuthManager')");
    console.log("    > traceMethod('AuthManager', '- login:')");
    console.log("    > traceMethodsMatching('NetworkManager', 'request')");

    // =====================================================
    // CONFIGURE TRACING HERE
    // Uncomment and modify as needed
    // =====================================================

    // Example: Trace authentication-related classes
    // traceClass('AuthManager');
    // traceClass('LoginViewController');

    // Example: Trace specific methods
    // traceMethod('NSURLSession', '- dataTaskWithRequest:completionHandler:');
    // traceMethod('KeychainWrapper', '- setPassword:forService:');

    // Example: Trace all methods matching pattern
    // traceMethodsMatching('UserManager', 'password');
    // traceMethodsMatching('APIClient', 'request');

} else {
    console.log("[-] Objective-C runtime not available");
}
