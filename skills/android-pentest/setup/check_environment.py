#!/usr/bin/env python3
"""
Android Pentesting Environment Checker

Verifies all required tools are installed and properly configured,
checks device connectivity, tests Frida attachment, and validates
proxy setup.

Usage:
    python check_environment.py [OPTIONS]

Options:
    --device SERIAL     Target device serial
    --proxy HOST:PORT   Test proxy connectivity
    --full              Run all checks including network tests
    --json              Output results as JSON
    --fix               Attempt to fix issues where possible
    -v, --verbose       Verbose output
"""

import argparse
import json
import os
import platform
import shutil
import socket
import subprocess
import sys
from dataclasses import dataclass, field, asdict
from enum import Enum
from pathlib import Path
from typing import Optional, List, Dict, Any


class CheckStatus(Enum):
    """Check result status."""
    PASS = "pass"
    FAIL = "fail"
    WARN = "warn"
    SKIP = "skip"


@dataclass
class CheckResult:
    """Result of a single check."""
    name: str
    status: CheckStatus
    message: str
    details: Optional[str] = None
    fix_hint: Optional[str] = None


@dataclass
class EnvironmentReport:
    """Complete environment check report."""
    system: Dict[str, Any] = field(default_factory=dict)
    tools: List[CheckResult] = field(default_factory=list)
    device: List[CheckResult] = field(default_factory=list)
    frida: List[CheckResult] = field(default_factory=list)
    proxy: List[CheckResult] = field(default_factory=list)
    overall_status: CheckStatus = CheckStatus.PASS

    def add_result(self, category: str, result: CheckResult):
        """Add a check result."""
        getattr(self, category).append(result)
        if result.status == CheckStatus.FAIL:
            self.overall_status = CheckStatus.FAIL
        elif result.status == CheckStatus.WARN and self.overall_status == CheckStatus.PASS:
            self.overall_status = CheckStatus.WARN


class EnvironmentChecker:
    """Checks Android pentesting environment."""

    # Required tools with install hints
    REQUIRED_TOOLS = {
        "adb": {
            "description": "Android Debug Bridge",
            "install": {
                "darwin": "brew install android-platform-tools",
                "linux": "sudo apt install adb",
                "windows": "Download Android SDK Platform Tools"
            }
        },
        "frida": {
            "description": "Frida dynamic instrumentation",
            "install": {
                "all": "pip install frida-tools"
            },
            "check_cmd": ["frida", "--version"]
        },
        "objection": {
            "description": "Objection mobile exploration toolkit",
            "install": {
                "all": "pip install objection"
            },
            "optional": True
        },
        "apktool": {
            "description": "APK reverse engineering tool",
            "install": {
                "darwin": "brew install apktool",
                "linux": "sudo apt install apktool",
                "all": "Download from https://ibotpeaches.github.io/Apktool/"
            },
            "optional": True
        },
        "jadx": {
            "description": "Dex to Java decompiler",
            "install": {
                "darwin": "brew install jadx",
                "linux": "Download from https://github.com/skylot/jadx",
                "all": "Download from https://github.com/skylot/jadx"
            },
            "optional": True
        },
        "dex2jar": {
            "description": "Dex to JAR converter",
            "install": {
                "all": "Download from https://github.com/pxb1988/dex2jar"
            },
            "optional": True
        },
        "openssl": {
            "description": "OpenSSL for certificate handling",
            "install": {
                "darwin": "brew install openssl",
                "linux": "sudo apt install openssl"
            }
        }
    }

    def __init__(self, verbose: bool = False, device_serial: Optional[str] = None,
                 proxy: Optional[str] = None):
        self.verbose = verbose
        self.device_serial = device_serial
        self.proxy = proxy
        self.report = EnvironmentReport()
        self.platform = platform.system().lower()

    def _log(self, message: str, level: str = "INFO"):
        """Log message."""
        colors = {
            "INFO": "\033[94m",
            "PASS": "\033[92m",
            "FAIL": "\033[91m",
            "WARN": "\033[93m",
            "DEBUG": "\033[96m",
        }
        reset = "\033[0m"
        color = colors.get(level, "")

        if level == "DEBUG" and not self.verbose:
            return

        print(f"{color}[{level}]{reset} {message}")

    def _run_cmd(self, cmd: List[str], timeout: int = 30) -> subprocess.CompletedProcess:
        """Run a command."""
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            return result
        except subprocess.TimeoutExpired:
            return subprocess.CompletedProcess(cmd, 1, "", "Timeout")
        except FileNotFoundError:
            return subprocess.CompletedProcess(cmd, 1, "", "Not found")

    def _adb_cmd(self, *args) -> subprocess.CompletedProcess:
        """Run ADB command."""
        cmd = ["adb"]
        if self.device_serial:
            cmd.extend(["-s", self.device_serial])
        cmd.extend(args)
        return self._run_cmd(cmd)

    def check_system(self):
        """Check system information."""
        self._log("Checking system information...", "INFO")

        self.report.system = {
            "platform": platform.system(),
            "platform_release": platform.release(),
            "platform_version": platform.version(),
            "architecture": platform.machine(),
            "python_version": platform.python_version(),
            "hostname": platform.node()
        }

        # Check if running on compatible system
        if self.platform not in ["darwin", "linux", "windows"]:
            self._log(f"Unknown platform: {self.platform}", "WARN")

    def check_tools(self):
        """Check required tools installation."""
        self._log("Checking required tools...", "INFO")

        for tool_name, tool_info in self.REQUIRED_TOOLS.items():
            self._log(f"  Checking {tool_name}...", "DEBUG")

            # Find tool
            tool_path = shutil.which(tool_name)

            if tool_path:
                # Get version if possible
                version = "installed"
                check_cmd = tool_info.get("check_cmd", [tool_name, "--version"])

                result = self._run_cmd(check_cmd)
                if result.returncode == 0:
                    version_output = result.stdout.strip() or result.stderr.strip()
                    # Extract first line
                    version = version_output.split('\n')[0][:50]

                status = CheckStatus.PASS
                message = f"Found at {tool_path}"
                details = f"Version: {version}"
                fix_hint = None

            else:
                is_optional = tool_info.get("optional", False)
                status = CheckStatus.WARN if is_optional else CheckStatus.FAIL
                message = "Not installed"
                details = tool_info["description"]

                # Get install hint
                install_hints = tool_info.get("install", {})
                fix_hint = install_hints.get(self.platform) or install_hints.get("all", "")

            result = CheckResult(
                name=tool_name,
                status=status,
                message=message,
                details=details,
                fix_hint=fix_hint
            )
            self.report.add_result("tools", result)

            status_str = status.value.upper()
            self._log(f"  {tool_name}: {message}", status_str)

    def check_device(self):
        """Check Android device connectivity."""
        self._log("Checking device connectivity...", "INFO")

        # Start ADB server
        self._run_cmd(["adb", "start-server"])

        # List devices
        result = self._adb_cmd("devices", "-l")

        if result.returncode != 0:
            self.report.add_result("device", CheckResult(
                name="adb_server",
                status=CheckStatus.FAIL,
                message="ADB server not running",
                fix_hint="Run: adb start-server"
            ))
            return

        # Parse devices
        devices = []
        for line in result.stdout.split('\n'):
            if '\tdevice' in line:
                parts = line.split()
                serial = parts[0]
                # Extract model if available
                model = ""
                for part in parts:
                    if part.startswith("model:"):
                        model = part.split(":")[1]
                devices.append({"serial": serial, "model": model})

        if not devices:
            self.report.add_result("device", CheckResult(
                name="device_connection",
                status=CheckStatus.FAIL,
                message="No devices connected",
                fix_hint="Connect device via USB and enable USB debugging"
            ))
            self._log("  No devices connected", "FAIL")
            return

        # Use specified device or first available
        if self.device_serial:
            device = next((d for d in devices if d["serial"] == self.device_serial), None)
            if not device:
                self.report.add_result("device", CheckResult(
                    name="device_connection",
                    status=CheckStatus.FAIL,
                    message=f"Device {self.device_serial} not found",
                    details=f"Available: {[d['serial'] for d in devices]}"
                ))
                return
        else:
            device = devices[0]
            self.device_serial = device["serial"]

        self.report.add_result("device", CheckResult(
            name="device_connection",
            status=CheckStatus.PASS,
            message=f"Connected to {device['serial']}",
            details=f"Model: {device.get('model', 'Unknown')}"
        ))
        self._log(f"  Connected to {device['serial']}", "PASS")

        # Check device details
        self._check_device_details()

    def _check_device_details(self):
        """Check device configuration details."""
        # Get device properties
        props = {}
        for prop in ["ro.product.model", "ro.build.version.release",
                     "ro.build.version.sdk", "ro.debuggable", "ro.secure"]:
            result = self._adb_cmd("shell", f"getprop {prop}")
            props[prop] = result.stdout.strip() if result.returncode == 0 else "unknown"

        # Store in report
        self.report.system["device"] = {
            "model": props.get("ro.product.model", "Unknown"),
            "android_version": props.get("ro.build.version.release", "Unknown"),
            "sdk_version": props.get("ro.build.version.sdk", "Unknown"),
            "debuggable": props.get("ro.debuggable", "0"),
            "secure": props.get("ro.secure", "1")
        }

        # Check root access
        root_result = self._adb_cmd("shell", "su -c 'id'")
        has_root = "uid=0" in root_result.stdout

        if has_root:
            self.report.add_result("device", CheckResult(
                name="root_access",
                status=CheckStatus.PASS,
                message="Root access available"
            ))
            self._log("  Root access: available", "PASS")
        else:
            self.report.add_result("device", CheckResult(
                name="root_access",
                status=CheckStatus.WARN,
                message="Root access not available",
                details="Some features require root",
                fix_hint="Root the device with Magisk"
            ))
            self._log("  Root access: not available", "WARN")

        # Check debuggable
        if props.get("ro.debuggable") == "1":
            self.report.add_result("device", CheckResult(
                name="debuggable",
                status=CheckStatus.PASS,
                message="Device is debuggable"
            ))
        else:
            self.report.add_result("device", CheckResult(
                name="debuggable",
                status=CheckStatus.WARN,
                message="Device not marked as debuggable",
                fix_hint="Use Magisk to set ro.debuggable=1"
            ))

    def check_frida(self):
        """Check Frida installation and connectivity."""
        self._log("Checking Frida setup...", "INFO")

        # Check frida-tools
        frida_path = shutil.which("frida")
        if not frida_path:
            self.report.add_result("frida", CheckResult(
                name="frida_tools",
                status=CheckStatus.FAIL,
                message="frida-tools not installed",
                fix_hint="pip install frida-tools"
            ))
            return

        # Get frida version
        result = self._run_cmd(["frida", "--version"])
        frida_version = result.stdout.strip() if result.returncode == 0 else "unknown"

        self.report.add_result("frida", CheckResult(
            name="frida_tools",
            status=CheckStatus.PASS,
            message=f"frida-tools {frida_version} installed"
        ))

        # Check if device is connected for server check
        if not self.device_serial:
            self._log("  Skipping server check (no device)", "DEBUG")
            return

        # Check Frida server on device
        result = self._adb_cmd("shell", "ls /data/local/tmp/frida-server")
        server_exists = "frida-server" in result.stdout and "No such file" not in result.stderr

        if server_exists:
            self.report.add_result("frida", CheckResult(
                name="frida_server_installed",
                status=CheckStatus.PASS,
                message="Frida server installed on device"
            ))

            # Check if running
            result = self._adb_cmd("shell", "pgrep -f frida-server")
            if result.stdout.strip():
                self.report.add_result("frida", CheckResult(
                    name="frida_server_running",
                    status=CheckStatus.PASS,
                    message="Frida server is running",
                    details=f"PID: {result.stdout.strip()}"
                ))
                self._log("  Frida server: running", "PASS")

                # Test connection
                self._test_frida_connection()
            else:
                self.report.add_result("frida", CheckResult(
                    name="frida_server_running",
                    status=CheckStatus.WARN,
                    message="Frida server not running",
                    fix_hint="Start with: adb shell su -c '/data/local/tmp/frida-server -D &'"
                ))
                self._log("  Frida server: not running", "WARN")
        else:
            self.report.add_result("frida", CheckResult(
                name="frida_server_installed",
                status=CheckStatus.FAIL,
                message="Frida server not installed on device",
                fix_hint="Use frida_server_manager.py install"
            ))
            self._log("  Frida server: not installed", "FAIL")

    def _test_frida_connection(self):
        """Test Frida connection to device."""
        try:
            import frida

            device_mgr = frida.get_device_manager()
            device = device_mgr.get_device(self.device_serial, timeout=5)
            processes = device.enumerate_processes()

            self.report.add_result("frida", CheckResult(
                name="frida_connection",
                status=CheckStatus.PASS,
                message=f"Frida connected ({len(processes)} processes)"
            ))
            self._log(f"  Frida connection: OK ({len(processes)} processes)", "PASS")

        except ImportError:
            self.report.add_result("frida", CheckResult(
                name="frida_connection",
                status=CheckStatus.SKIP,
                message="frida module not available for testing"
            ))
        except Exception as e:
            self.report.add_result("frida", CheckResult(
                name="frida_connection",
                status=CheckStatus.FAIL,
                message=f"Frida connection failed: {str(e)}"
            ))
            self._log(f"  Frida connection: failed ({e})", "FAIL")

    def check_proxy(self):
        """Check proxy configuration."""
        if not self.proxy:
            self._log("Skipping proxy check (not configured)", "DEBUG")
            return

        self._log(f"Checking proxy: {self.proxy}...", "INFO")

        # Parse proxy
        try:
            if ":" in self.proxy:
                host, port = self.proxy.rsplit(":", 1)
                port = int(port)
            else:
                host = self.proxy
                port = 8080
        except ValueError:
            self.report.add_result("proxy", CheckResult(
                name="proxy_config",
                status=CheckStatus.FAIL,
                message=f"Invalid proxy format: {self.proxy}",
                fix_hint="Use format: host:port"
            ))
            return

        # Test connectivity
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((host, port))
            sock.close()

            self.report.add_result("proxy", CheckResult(
                name="proxy_connectivity",
                status=CheckStatus.PASS,
                message=f"Proxy reachable at {host}:{port}"
            ))
            self._log(f"  Proxy connectivity: OK", "PASS")

        except socket.error as e:
            self.report.add_result("proxy", CheckResult(
                name="proxy_connectivity",
                status=CheckStatus.FAIL,
                message=f"Cannot connect to proxy: {e}",
                fix_hint="Ensure proxy is running and accessible"
            ))
            self._log(f"  Proxy connectivity: failed ({e})", "FAIL")
            return

        # Check device proxy setting
        if self.device_serial:
            result = self._adb_cmd("shell", "settings get global http_proxy")
            device_proxy = result.stdout.strip()

            if device_proxy and device_proxy != ":0" and device_proxy != "null":
                self.report.add_result("proxy", CheckResult(
                    name="device_proxy",
                    status=CheckStatus.PASS,
                    message=f"Device proxy set to: {device_proxy}"
                ))
            else:
                self.report.add_result("proxy", CheckResult(
                    name="device_proxy",
                    status=CheckStatus.WARN,
                    message="Device proxy not configured",
                    fix_hint=f"Run: adb shell settings put global http_proxy {host}:{port}"
                ))

    def run_all_checks(self):
        """Run all environment checks."""
        self.check_system()
        self.check_tools()
        self.check_device()
        self.check_frida()
        self.check_proxy()

        return self.report

    def print_report(self):
        """Print human-readable report."""
        print("\n" + "=" * 60)
        print("  Android Pentesting Environment Report")
        print("=" * 60)

        # System info
        print("\n[System Information]")
        sys_info = self.report.system
        print(f"  Platform: {sys_info.get('platform', 'Unknown')} "
              f"{sys_info.get('platform_release', '')}")
        print(f"  Python: {sys_info.get('python_version', 'Unknown')}")

        if "device" in sys_info:
            dev = sys_info["device"]
            print(f"\n  Device: {dev.get('model', 'Unknown')}")
            print(f"  Android: {dev.get('android_version', 'Unknown')} "
                  f"(SDK {dev.get('sdk_version', 'Unknown')})")

        # Print check categories
        categories = [
            ("Tools", self.report.tools),
            ("Device", self.report.device),
            ("Frida", self.report.frida),
            ("Proxy", self.report.proxy)
        ]

        for cat_name, results in categories:
            if not results:
                continue

            print(f"\n[{cat_name}]")
            for r in results:
                status_symbols = {
                    CheckStatus.PASS: "\033[92m[PASS]\033[0m",
                    CheckStatus.FAIL: "\033[91m[FAIL]\033[0m",
                    CheckStatus.WARN: "\033[93m[WARN]\033[0m",
                    CheckStatus.SKIP: "\033[96m[SKIP]\033[0m"
                }
                symbol = status_symbols.get(r.status, "[????]")
                print(f"  {symbol} {r.name}: {r.message}")

                if r.details and self.verbose:
                    print(f"         {r.details}")

                if r.fix_hint and r.status in [CheckStatus.FAIL, CheckStatus.WARN]:
                    print(f"         Fix: {r.fix_hint}")

        # Summary
        print("\n" + "=" * 60)
        overall_symbol = {
            CheckStatus.PASS: "\033[92mREADY\033[0m",
            CheckStatus.WARN: "\033[93mPARTIAL\033[0m",
            CheckStatus.FAIL: "\033[91mNOT READY\033[0m"
        }
        print(f"  Overall Status: {overall_symbol.get(self.report.overall_status, 'UNKNOWN')}")
        print("=" * 60 + "\n")

    def to_json(self) -> str:
        """Convert report to JSON."""
        def convert(obj):
            if isinstance(obj, CheckStatus):
                return obj.value
            if isinstance(obj, CheckResult):
                return {
                    "name": obj.name,
                    "status": obj.status.value,
                    "message": obj.message,
                    "details": obj.details,
                    "fix_hint": obj.fix_hint
                }
            return obj

        report_dict = {
            "system": self.report.system,
            "tools": [convert(r) for r in self.report.tools],
            "device": [convert(r) for r in self.report.device],
            "frida": [convert(r) for r in self.report.frida],
            "proxy": [convert(r) for r in self.report.proxy],
            "overall_status": self.report.overall_status.value
        }

        return json.dumps(report_dict, indent=2)


def main():
    parser = argparse.ArgumentParser(
        description="Check Android pentesting environment",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python check_environment.py
  python check_environment.py --device emulator-5554
  python check_environment.py --proxy 192.168.1.100:8080
  python check_environment.py --json > report.json
        """
    )

    parser.add_argument("-d", "--device", help="Device serial")
    parser.add_argument("-p", "--proxy", help="Proxy host:port to test")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    checker = EnvironmentChecker(
        verbose=args.verbose,
        device_serial=args.device,
        proxy=args.proxy
    )

    checker.run_all_checks()

    if args.json:
        print(checker.to_json())
    else:
        checker.print_report()

    # Return exit code based on status
    if checker.report.overall_status == CheckStatus.FAIL:
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
