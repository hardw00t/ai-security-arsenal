#!/usr/bin/env bash
#
# Android Physical Device Setup for Penetration Testing
# Sets up a rooted Android device for security testing
#
# Usage:
#   ./setup_physical_device.sh [OPTIONS]
#
# Options:
#   --device SERIAL     Target device serial (default: first device)
#   --proxy-host HOST   Proxy host IP (default: host machine IP)
#   --proxy-port PORT   Proxy port (default: 8080)
#   --cert FILE         Path to CA certificate (DER or PEM format)
#   --skip-root-check   Skip root verification
#   --install-apps      Install helper apps (Drozer, etc.)
#   --frida-version VER Frida server version (default: latest)
#   -v, --verbose       Verbose output
#   -h, --help          Show this help

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Defaults
DEVICE_SERIAL=""
PROXY_HOST=""
PROXY_PORT="8080"
CA_CERT_PATH=""
SKIP_ROOT_CHECK=false
INSTALL_APPS=false
FRIDA_VERSION="latest"
VERBOSE=false
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEMP_DIR="/tmp/android_pentest_setup_$$"

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_verbose() {
    if $VERBOSE; then
        echo -e "${CYAN}[DEBUG]${NC} $1"
    fi
}

# Cleanup function
cleanup() {
    log_verbose "Cleaning up temporary files..."
    rm -rf "$TEMP_DIR" 2>/dev/null || true
}
trap cleanup EXIT

# Show help
show_help() {
    head -30 "$0" | tail -20 | sed 's/^#//'
    exit 0
}

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --device)
                DEVICE_SERIAL="$2"
                shift 2
                ;;
            --proxy-host)
                PROXY_HOST="$2"
                shift 2
                ;;
            --proxy-port)
                PROXY_PORT="$2"
                shift 2
                ;;
            --cert)
                CA_CERT_PATH="$2"
                shift 2
                ;;
            --skip-root-check)
                SKIP_ROOT_CHECK=true
                shift
                ;;
            --install-apps)
                INSTALL_APPS=true
                shift
                ;;
            --frida-version)
                FRIDA_VERSION="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                ;;
        esac
    done
}

# Get ADB command with device serial
adb_cmd() {
    if [[ -n "$DEVICE_SERIAL" ]]; then
        adb -s "$DEVICE_SERIAL" "$@"
    else
        adb "$@"
    fi
}

# Check if ADB is available
check_adb() {
    log_info "Checking ADB installation..."

    if ! command -v adb &>/dev/null; then
        log_error "ADB is not installed or not in PATH"
        log_info "Install Android SDK Platform Tools:"
        log_info "  macOS: brew install android-platform-tools"
        log_info "  Linux: sudo apt install adb"
        return 1
    fi

    log_success "ADB found: $(which adb)"
    log_verbose "ADB version: $(adb version | head -1)"
}

# Check device connectivity
check_device() {
    log_info "Checking device connectivity..."

    # Start ADB server
    adb start-server &>/dev/null

    # List devices
    local devices
    devices=$(adb devices | grep -v "List" | grep -v "^$" | wc -l)

    if [[ $devices -eq 0 ]]; then
        log_error "No devices connected"
        log_info "Make sure:"
        log_info "  1. USB debugging is enabled in Developer Options"
        log_info "  2. Device is connected via USB"
        log_info "  3. You've authorized the computer on the device"
        return 1
    fi

    if [[ -z "$DEVICE_SERIAL" ]]; then
        DEVICE_SERIAL=$(adb devices | grep -v "List" | grep "device$" | head -1 | cut -f1)
        log_info "Using device: $DEVICE_SERIAL"
    fi

    # Verify specific device
    if ! adb devices | grep -q "$DEVICE_SERIAL"; then
        log_error "Device $DEVICE_SERIAL not found"
        return 1
    fi

    # Get device info
    local model brand android_version
    model=$(adb_cmd shell getprop ro.product.model 2>/dev/null | tr -d '\r')
    brand=$(adb_cmd shell getprop ro.product.brand 2>/dev/null | tr -d '\r')
    android_version=$(adb_cmd shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')

    log_success "Connected to: $brand $model (Android $android_version)"
}

# Check USB debugging status
check_usb_debugging() {
    log_info "Verifying USB debugging..."

    local adb_enabled
    adb_enabled=$(adb_cmd shell settings get global adb_enabled 2>/dev/null | tr -d '\r')

    if [[ "$adb_enabled" != "1" ]]; then
        log_warning "USB debugging may not be fully enabled"
    else
        log_success "USB debugging is enabled"
    fi

    # Check for authorization
    local device_state
    device_state=$(adb devices | grep "$DEVICE_SERIAL" | awk '{print $2}')

    if [[ "$device_state" == "unauthorized" ]]; then
        log_error "Device is unauthorized. Please authorize this computer on the device."
        return 1
    fi

    log_success "Device is authorized"
}

# Check root access
check_root() {
    log_info "Checking root access..."

    if $SKIP_ROOT_CHECK; then
        log_warning "Skipping root check as requested"
        return 0
    fi

    # Try su
    local root_test
    root_test=$(adb_cmd shell "su -c 'id'" 2>/dev/null | tr -d '\r' || echo "")

    if [[ "$root_test" == *"uid=0"* ]]; then
        log_success "Root access available via su"
        return 0
    fi

    # Try magisk
    root_test=$(adb_cmd shell "magisk -v" 2>/dev/null | tr -d '\r' || echo "")
    if [[ -n "$root_test" ]]; then
        log_success "Magisk detected: $root_test"
        return 0
    fi

    log_warning "Root access not detected"
    log_info "Some features may not work without root:"
    log_info "  - System CA certificate installation"
    log_info "  - Global proxy configuration"
    log_info "  - Frida server as system service"

    return 0
}

# Get device architecture
get_device_arch() {
    local abi
    abi=$(adb_cmd shell getprop ro.product.cpu.abi 2>/dev/null | tr -d '\r')

    case "$abi" in
        arm64-v8a)
            echo "arm64"
            ;;
        armeabi-v7a|armeabi)
            echo "arm"
            ;;
        x86_64)
            echo "x86_64"
            ;;
        x86)
            echo "x86"
            ;;
        *)
            log_error "Unknown architecture: $abi"
            return 1
            ;;
    esac
}

# Get latest Frida version
get_latest_frida_version() {
    if [[ "$FRIDA_VERSION" != "latest" ]]; then
        echo "$FRIDA_VERSION"
        return
    fi

    local version
    version=$(curl -sL "https://api.github.com/repos/frida/frida/releases/latest" | \
              grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')

    if [[ -z "$version" ]]; then
        log_error "Failed to get latest Frida version"
        return 1
    fi

    echo "$version"
}

# Install Frida server
install_frida_server() {
    log_info "Installing Frida server..."

    mkdir -p "$TEMP_DIR"

    # Get architecture
    local arch
    arch=$(get_device_arch)
    log_verbose "Device architecture: $arch"

    # Get Frida version
    local version
    version=$(get_latest_frida_version)
    log_info "Using Frida version: $version"

    # Download URL
    local filename="frida-server-${version}-android-${arch}.xz"
    local url="https://github.com/frida/frida/releases/download/${version}/${filename}"

    log_verbose "Downloading from: $url"

    # Download
    if ! curl -sL "$url" -o "$TEMP_DIR/$filename"; then
        log_error "Failed to download Frida server"
        return 1
    fi

    # Extract
    if ! xz -d "$TEMP_DIR/$filename"; then
        log_error "Failed to extract Frida server"
        return 1
    fi

    local server_path="$TEMP_DIR/frida-server-${version}-android-${arch}"

    # Push to device
    log_verbose "Pushing Frida server to device..."
    adb_cmd push "$server_path" /data/local/tmp/frida-server

    # Set permissions
    adb_cmd shell "chmod 755 /data/local/tmp/frida-server"

    # Try to install as system service (requires root)
    local has_root
    has_root=$(adb_cmd shell "su -c 'id'" 2>/dev/null | grep -c "uid=0" || echo "0")

    if [[ "$has_root" -gt 0 ]]; then
        log_verbose "Installing Frida server as system service..."

        # Create init script
        cat > "$TEMP_DIR/frida-server.sh" << 'EOF'
#!/system/bin/sh
# Frida Server Init Script

FRIDA_SERVER="/data/local/tmp/frida-server"
FRIDA_PID_FILE="/data/local/tmp/frida-server.pid"

start() {
    if [ -f "$FRIDA_PID_FILE" ]; then
        PID=$(cat "$FRIDA_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "Frida server already running (PID: $PID)"
            return 0
        fi
    fi

    "$FRIDA_SERVER" -D &
    echo $! > "$FRIDA_PID_FILE"
    echo "Frida server started (PID: $!)"
}

stop() {
    if [ -f "$FRIDA_PID_FILE" ]; then
        PID=$(cat "$FRIDA_PID_FILE")
        kill "$PID" 2>/dev/null
        rm -f "$FRIDA_PID_FILE"
        echo "Frida server stopped"
    else
        # Kill any running instance
        pkill -f frida-server 2>/dev/null || true
    fi
}

restart() {
    stop
    sleep 1
    start
}

status() {
    if [ -f "$FRIDA_PID_FILE" ]; then
        PID=$(cat "$FRIDA_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "Frida server is running (PID: $PID)"
            return 0
        fi
    fi
    echo "Frida server is not running"
    return 1
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 1
        ;;
esac
EOF

        adb_cmd push "$TEMP_DIR/frida-server.sh" /data/local/tmp/frida-server.sh
        adb_cmd shell "su -c 'chmod 755 /data/local/tmp/frida-server.sh'"
    fi

    log_success "Frida server installed"
}

# Start Frida server
start_frida_server() {
    log_info "Starting Frida server..."

    # Kill any existing instance
    adb_cmd shell "pkill -f frida-server" 2>/dev/null || true
    sleep 1

    # Try with root
    local has_root
    has_root=$(adb_cmd shell "su -c 'id'" 2>/dev/null | grep -c "uid=0" || echo "0")

    if [[ "$has_root" -gt 0 ]]; then
        adb_cmd shell "su -c '/data/local/tmp/frida-server -D'" &
    else
        adb_cmd shell "/data/local/tmp/frida-server -D" &
    fi

    sleep 2

    # Verify
    if adb_cmd shell "pgrep -f frida-server" &>/dev/null; then
        log_success "Frida server is running"
    else
        log_warning "Frida server may not have started correctly"
    fi
}

# Verify Frida connection
verify_frida() {
    log_info "Verifying Frida connection..."

    if ! command -v frida &>/dev/null; then
        log_warning "Frida CLI not installed, skipping verification"
        log_info "Install with: pip install frida-tools"
        return 0
    fi

    local device_arg=""
    if [[ -n "$DEVICE_SERIAL" ]]; then
        device_arg="-D $DEVICE_SERIAL"
    fi

    # Try to list processes
    if frida-ps $device_arg &>/dev/null; then
        log_success "Frida connection verified"
        log_verbose "Running processes:"
        frida-ps $device_arg | head -10
    else
        log_warning "Could not connect to Frida server"
    fi
}

# Convert certificate to Android format
convert_cert_to_android_format() {
    local input_cert="$1"
    local output_dir="$2"

    # Detect format and convert to PEM if needed
    local pem_cert="$output_dir/cert.pem"

    if file "$input_cert" | grep -q "DER"; then
        log_verbose "Converting DER to PEM..."
        openssl x509 -inform DER -in "$input_cert" -out "$pem_cert"
    elif file "$input_cert" | grep -q "PEM\|ASCII"; then
        cp "$input_cert" "$pem_cert"
    else
        # Try to detect by content
        if head -1 "$input_cert" | grep -q "BEGIN"; then
            cp "$input_cert" "$pem_cert"
        else
            openssl x509 -inform DER -in "$input_cert" -out "$pem_cert" 2>/dev/null || \
            cp "$input_cert" "$pem_cert"
        fi
    fi

    # Get subject hash (old format for older Android)
    local subject_hash
    subject_hash=$(openssl x509 -inform PEM -subject_hash_old -in "$pem_cert" -noout)

    # Convert to Android format
    local android_cert="$output_dir/${subject_hash}.0"

    openssl x509 -inform PEM -text -in "$pem_cert" > "$android_cert"

    echo "$android_cert"
}

# Install CA certificate
install_ca_cert() {
    if [[ -z "$CA_CERT_PATH" ]]; then
        log_info "No CA certificate specified, skipping..."
        return 0
    fi

    log_info "Installing CA certificate..."

    if [[ ! -f "$CA_CERT_PATH" ]]; then
        log_error "Certificate file not found: $CA_CERT_PATH"
        return 1
    fi

    mkdir -p "$TEMP_DIR"

    # Convert certificate
    local android_cert
    android_cert=$(convert_cert_to_android_format "$CA_CERT_PATH" "$TEMP_DIR")
    local cert_name
    cert_name=$(basename "$android_cert")

    log_verbose "Android cert name: $cert_name"

    # Check if we have root
    local has_root
    has_root=$(adb_cmd shell "su -c 'id'" 2>/dev/null | grep -c "uid=0" || echo "0")

    if [[ "$has_root" -gt 0 ]]; then
        log_verbose "Installing as system CA (requires root)..."

        # Check Android version for cert location
        local android_ver
        android_ver=$(adb_cmd shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')

        local cert_path
        if [[ "$android_ver" -ge 34 ]]; then
            # Android 14+ uses APEX
            cert_path="/apex/com.android.conscrypt/cacerts/$cert_name"
            log_warning "Android 14+ requires special handling for system certs"
            log_info "Consider using Magisk module for certificate injection"
        else
            cert_path="/system/etc/security/cacerts/$cert_name"
        fi

        # Push certificate
        adb_cmd push "$android_cert" /data/local/tmp/

        # Remount system and install
        adb_cmd shell "su -c 'mount -o rw,remount /system'" 2>/dev/null || true
        adb_cmd shell "su -c 'cp /data/local/tmp/$cert_name $cert_path'"
        adb_cmd shell "su -c 'chmod 644 $cert_path'"
        adb_cmd shell "su -c 'mount -o ro,remount /system'" 2>/dev/null || true

        log_success "CA certificate installed as system cert"
    else
        log_warning "No root access - installing as user certificate"

        # Install as user cert
        adb_cmd push "$android_cert" /sdcard/

        log_info "Certificate pushed to /sdcard/$cert_name"
        log_info "To complete installation:"
        log_info "  1. Go to Settings > Security > Encryption & credentials"
        log_info "  2. Tap 'Install a certificate' > 'CA certificate'"
        log_info "  3. Select the certificate from storage"
    fi
}

# Configure proxy settings
configure_proxy() {
    if [[ -z "$PROXY_HOST" ]]; then
        # Try to detect host IP
        PROXY_HOST=$(ip route get 1 2>/dev/null | awk '{print $7}' | head -1)
        if [[ -z "$PROXY_HOST" ]]; then
            PROXY_HOST=$(ifconfig | grep "inet " | grep -v 127.0.0.1 | awk '{print $2}' | head -1)
        fi
    fi

    if [[ -z "$PROXY_HOST" ]]; then
        log_warning "Could not determine proxy host, skipping proxy configuration"
        return 0
    fi

    log_info "Configuring proxy: $PROXY_HOST:$PROXY_PORT"

    # Check if we have root for global proxy
    local has_root
    has_root=$(adb_cmd shell "su -c 'id'" 2>/dev/null | grep -c "uid=0" || echo "0")

    if [[ "$has_root" -gt 0 ]]; then
        # Set global proxy (requires root)
        adb_cmd shell "su -c 'settings put global http_proxy $PROXY_HOST:$PROXY_PORT'"
        log_success "Global proxy configured"
    else
        # Set Wi-Fi proxy (may not work on all devices without root)
        adb_cmd shell "settings put global http_proxy $PROXY_HOST:$PROXY_PORT" 2>/dev/null || true
        log_warning "Set proxy without root - may need manual Wi-Fi proxy configuration"
        log_info "Manual setup:"
        log_info "  1. Go to Settings > Wi-Fi"
        log_info "  2. Long press on connected network > Modify network"
        log_info "  3. Show advanced options"
        log_info "  4. Set Proxy to Manual"
        log_info "  5. Host: $PROXY_HOST, Port: $PROXY_PORT"
    fi
}

# Install helper apps
install_helper_apps() {
    if ! $INSTALL_APPS; then
        return 0
    fi

    log_info "Installing helper applications..."

    mkdir -p "$TEMP_DIR/apps"

    # List of apps to install
    declare -A APPS=(
        ["drozer"]="https://github.com/WithSecureLabs/drozer/releases/latest/download/drozer-agent.apk"
    )

    for app_name in "${!APPS[@]}"; do
        local url="${APPS[$app_name]}"
        local apk_path="$TEMP_DIR/apps/${app_name}.apk"

        log_verbose "Downloading $app_name..."

        # Handle GitHub latest release redirect
        if [[ "$url" == *"/latest/"* ]]; then
            url=$(curl -sLI -o /dev/null -w '%{url_effective}' "$url" 2>/dev/null || echo "$url")
        fi

        if curl -sL "$url" -o "$apk_path" 2>/dev/null; then
            log_verbose "Installing $app_name..."
            if adb_cmd install -r "$apk_path" &>/dev/null; then
                log_success "Installed: $app_name"
            else
                log_warning "Failed to install: $app_name"
            fi
        else
            log_warning "Failed to download: $app_name"
        fi
    done
}

# Make device debuggable (if rooted)
configure_debuggable() {
    log_info "Checking debuggable configuration..."

    local has_root
    has_root=$(adb_cmd shell "su -c 'id'" 2>/dev/null | grep -c "uid=0" || echo "0")

    if [[ "$has_root" -eq 0 ]]; then
        log_verbose "Root not available, skipping debuggable configuration"
        return 0
    fi

    # Check current ro.debuggable
    local debuggable
    debuggable=$(adb_cmd shell getprop ro.debuggable 2>/dev/null | tr -d '\r')

    if [[ "$debuggable" == "1" ]]; then
        log_success "Device is already debuggable"
        return 0
    fi

    log_info "Device is not debuggable, attempting to configure..."

    # Try Magisk resetprop
    if adb_cmd shell "su -c 'magisk --version'" &>/dev/null; then
        adb_cmd shell "su -c 'magisk resetprop ro.debuggable 1'"
        log_success "Set ro.debuggable=1 via Magisk"
    else
        log_warning "Cannot make device debuggable without Magisk"
    fi
}

# Verify all tools working
verify_setup() {
    log_info "Verifying setup..."

    echo ""
    echo "=========================================="
    echo "        Setup Verification Results        "
    echo "=========================================="
    echo ""

    # Device info
    local model brand android_version sdk_version
    model=$(adb_cmd shell getprop ro.product.model 2>/dev/null | tr -d '\r')
    brand=$(adb_cmd shell getprop ro.product.brand 2>/dev/null | tr -d '\r')
    android_version=$(adb_cmd shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')
    sdk_version=$(adb_cmd shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')

    echo "Device Information:"
    echo "  Model: $brand $model"
    echo "  Android: $android_version (SDK $sdk_version)"
    echo "  Serial: $DEVICE_SERIAL"
    echo ""

    # Root status
    local root_status="No"
    if adb_cmd shell "su -c 'id'" 2>/dev/null | grep -q "uid=0"; then
        root_status="Yes"
    fi
    echo "Root Access: $root_status"

    # Frida status
    local frida_status="Not running"
    if adb_cmd shell "pgrep -f frida-server" &>/dev/null; then
        frida_status="Running"
    fi
    echo "Frida Server: $frida_status"

    # Proxy status
    local proxy
    proxy=$(adb_cmd shell "settings get global http_proxy" 2>/dev/null | tr -d '\r')
    echo "Proxy: ${proxy:-Not set}"

    # CA cert status
    local ca_count
    ca_count=$(adb_cmd shell "ls /system/etc/security/cacerts/ 2>/dev/null | wc -l" | tr -d '\r')
    echo "System CA Certs: $ca_count"

    echo ""
    echo "=========================================="

    # Final verification
    if [[ "$frida_status" == "Running" ]]; then
        log_success "Device is ready for penetration testing!"
    else
        log_warning "Some components may not be configured correctly"
    fi
}

# Main function
main() {
    echo ""
    echo "========================================"
    echo "  Android Physical Device Setup Script  "
    echo "========================================"
    echo ""

    parse_args "$@"

    # Create temp directory
    mkdir -p "$TEMP_DIR"

    # Check prerequisites
    check_adb || exit 1
    check_device || exit 1
    check_usb_debugging || exit 1
    check_root

    # Configure device
    configure_debuggable

    # Install Frida
    install_frida_server
    start_frida_server
    verify_frida

    # Install CA certificate
    install_ca_cert

    # Configure proxy
    configure_proxy

    # Install helper apps
    install_helper_apps

    # Verify setup
    verify_setup

    echo ""
    log_success "Physical device setup complete!"
    echo ""
}

main "$@"
