#!/usr/bin/env bash
#
# Burp Suite CA Certificate Installer for Android
# Exports, converts, and installs Burp's CA certificate on Android devices
#
# Usage:
#   ./burp_cert_installer.sh [OPTIONS]
#
# Options:
#   --device SERIAL     Target device serial (default: first device)
#   --cert FILE         Path to existing certificate (DER or PEM)
#   --export-from-burp  Export certificate from running Burp proxy
#   --burp-host HOST    Burp proxy host (default: 127.0.0.1)
#   --burp-port PORT    Burp proxy port (default: 8080)
#   --user-cert         Install as user cert (no root required)
#   --android14         Use Android 14+ compatible method
#   -v, --verbose       Verbose output
#   -h, --help          Show this help

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Defaults
DEVICE_SERIAL=""
CERT_PATH=""
EXPORT_FROM_BURP=false
BURP_HOST="127.0.0.1"
BURP_PORT="8080"
USER_CERT=false
ANDROID14_MODE=false
VERBOSE=false
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEMP_DIR="/tmp/burp_cert_installer_$$"

# Logging
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_verbose() { $VERBOSE && echo -e "${CYAN}[DEBUG]${NC} $1" || true; }

# Cleanup
cleanup() {
    log_verbose "Cleaning up temporary files..."
    rm -rf "$TEMP_DIR" 2>/dev/null || true
}
trap cleanup EXIT

# Show help
show_help() {
    head -25 "$0" | tail -18 | sed 's/^#//'
    exit 0
}

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --device)
                DEVICE_SERIAL="$2"
                shift 2
                ;;
            --cert)
                CERT_PATH="$2"
                shift 2
                ;;
            --export-from-burp)
                EXPORT_FROM_BURP=true
                shift
                ;;
            --burp-host)
                BURP_HOST="$2"
                shift 2
                ;;
            --burp-port)
                BURP_PORT="$2"
                shift 2
                ;;
            --user-cert)
                USER_CERT=true
                shift
                ;;
            --android14)
                ANDROID14_MODE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                ;;
        esac
    done
}

# ADB command helper
adb_cmd() {
    if [[ -n "$DEVICE_SERIAL" ]]; then
        adb -s "$DEVICE_SERIAL" "$@"
    else
        adb "$@"
    fi
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."

    # Check ADB
    if ! command -v adb &>/dev/null; then
        log_error "ADB is not installed"
        return 1
    fi

    # Check OpenSSL
    if ! command -v openssl &>/dev/null; then
        log_error "OpenSSL is not installed"
        return 1
    fi

    # Check curl (for Burp export)
    if $EXPORT_FROM_BURP && ! command -v curl &>/dev/null; then
        log_error "curl is required for Burp export"
        return 1
    fi

    log_success "Prerequisites check passed"
}

# Check device connection
check_device() {
    log_info "Checking device connection..."

    adb start-server &>/dev/null

    local devices
    devices=$(adb devices | grep -v "List" | grep -v "^$" | grep "device$" | wc -l)

    if [[ $devices -eq 0 ]]; then
        log_error "No devices connected"
        return 1
    fi

    if [[ -z "$DEVICE_SERIAL" ]]; then
        DEVICE_SERIAL=$(adb devices | grep "device$" | head -1 | cut -f1)
        log_info "Using device: $DEVICE_SERIAL"
    fi

    # Get Android version
    local sdk_version
    sdk_version=$(adb_cmd shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')

    log_verbose "Android SDK version: $sdk_version"

    # Auto-enable Android 14 mode if needed
    if [[ "$sdk_version" -ge 34 ]] && ! $ANDROID14_MODE; then
        log_warning "Android 14+ detected. Enabling Android 14 compatibility mode."
        ANDROID14_MODE=true
    fi

    log_success "Device connected: $(adb_cmd shell getprop ro.product.model | tr -d '\r')"
}

# Check root access
check_root() {
    if $USER_CERT; then
        log_verbose "User cert mode - root not required"
        return 0
    fi

    log_info "Checking root access..."

    local root_test
    root_test=$(adb_cmd shell "su -c 'id'" 2>/dev/null | tr -d '\r' || echo "")

    if [[ "$root_test" == *"uid=0"* ]]; then
        log_success "Root access available"
        return 0
    fi

    # Try adb root (for emulators)
    adb_cmd root &>/dev/null
    sleep 1

    root_test=$(adb_cmd shell "id" 2>/dev/null | tr -d '\r')
    if [[ "$root_test" == *"uid=0"* ]]; then
        log_success "ADB root access available"
        return 0
    fi

    log_warning "Root access not available"
    log_info "Certificate will be installed as user cert (limited functionality)"
    USER_CERT=true
    return 0
}

# Export certificate from Burp Suite
export_burp_cert() {
    log_info "Exporting certificate from Burp Suite..."

    mkdir -p "$TEMP_DIR"
    local burp_cert="$TEMP_DIR/burp_ca.der"

    # Download certificate from Burp
    log_verbose "Downloading from http://$BURP_HOST:$BURP_PORT/cert"

    if ! curl -sS --connect-timeout 5 \
         -x "http://$BURP_HOST:$BURP_PORT" \
         "http://burp/cert" \
         -o "$burp_cert" 2>/dev/null; then

        # Try direct download
        if ! curl -sS --connect-timeout 5 \
             "http://$BURP_HOST:$BURP_PORT/cert" \
             -o "$burp_cert" 2>/dev/null; then
            log_error "Failed to export certificate from Burp"
            log_info "Make sure Burp Suite is running and proxy is configured"
            log_info "  Host: $BURP_HOST"
            log_info "  Port: $BURP_PORT"
            return 1
        fi
    fi

    # Verify it's a certificate
    if ! file "$burp_cert" | grep -qi "certificate\|data"; then
        log_error "Downloaded file is not a valid certificate"
        return 1
    fi

    CERT_PATH="$burp_cert"
    log_success "Certificate exported from Burp Suite"
}

# Convert certificate to Android format
convert_certificate() {
    log_info "Converting certificate to Android format..."

    mkdir -p "$TEMP_DIR"

    local input_cert="$CERT_PATH"
    local pem_cert="$TEMP_DIR/cert.pem"
    local android_cert=""

    # Detect format and convert to PEM
    if file "$input_cert" | grep -qi "DER\|data"; then
        log_verbose "Converting DER to PEM..."
        if ! openssl x509 -inform DER -in "$input_cert" -out "$pem_cert" 2>/dev/null; then
            log_error "Failed to convert DER certificate"
            return 1
        fi
    elif file "$input_cert" | grep -qi "PEM\|ASCII\|text"; then
        cp "$input_cert" "$pem_cert"
    else
        # Try both formats
        if openssl x509 -inform DER -in "$input_cert" -out "$pem_cert" 2>/dev/null; then
            log_verbose "Detected DER format"
        elif openssl x509 -inform PEM -in "$input_cert" -out "$pem_cert" 2>/dev/null; then
            log_verbose "Detected PEM format"
        else
            log_error "Unrecognized certificate format"
            return 1
        fi
    fi

    # Verify certificate
    if ! openssl x509 -in "$pem_cert" -noout 2>/dev/null; then
        log_error "Invalid certificate file"
        return 1
    fi

    # Display certificate info
    log_verbose "Certificate details:"
    if $VERBOSE; then
        openssl x509 -in "$pem_cert" -noout -subject -issuer -dates
    fi

    # Get subject hash (old format for Android compatibility)
    local subject_hash
    subject_hash=$(openssl x509 -inform PEM -subject_hash_old -in "$pem_cert" -noout)

    if [[ -z "$subject_hash" ]]; then
        log_error "Failed to get certificate hash"
        return 1
    fi

    log_verbose "Subject hash: $subject_hash"

    # Create Android certificate format
    android_cert="$TEMP_DIR/${subject_hash}.0"

    # Combine cert text output with PEM
    {
        openssl x509 -inform PEM -text -in "$pem_cert"
    } > "$android_cert"

    # Store paths for later use
    CONVERTED_CERT="$android_cert"
    CERT_HASH="$subject_hash"

    log_success "Certificate converted: ${subject_hash}.0"
}

# Install as user certificate
install_user_cert() {
    log_info "Installing certificate as user CA..."

    # Push to sdcard
    adb_cmd push "$CONVERTED_CERT" "/sdcard/Download/${CERT_HASH}.0"

    log_success "Certificate pushed to /sdcard/Download/${CERT_HASH}.0"
    echo ""
    log_info "To complete installation manually:"
    log_info "  1. Go to Settings > Security > Encryption & credentials"
    log_info "  2. Tap 'Install a certificate' > 'CA certificate'"
    log_info "  3. Navigate to Downloads and select ${CERT_HASH}.0"
    log_info "  4. Confirm the installation"
    echo ""
    log_warning "Note: User certificates only work for apps that trust user CAs"
    log_info "For full interception, use --android14 mode or root the device"
}

# Install as system certificate (standard method)
install_system_cert() {
    log_info "Installing certificate as system CA..."

    local cert_dest="/system/etc/security/cacerts/${CERT_HASH}.0"

    # Push to temp location
    adb_cmd push "$CONVERTED_CERT" /data/local/tmp/

    # Remount system as writable
    log_verbose "Remounting system partition..."

    # Try different remount methods
    adb_cmd shell "su -c 'mount -o rw,remount /system'" 2>/dev/null || \
    adb_cmd shell "su -c 'mount -o rw,remount /'" 2>/dev/null || \
    adb_cmd remount 2>/dev/null || true

    # Copy certificate
    log_verbose "Copying certificate to system..."
    if ! adb_cmd shell "su -c 'cp /data/local/tmp/${CERT_HASH}.0 $cert_dest'" 2>/dev/null; then
        # Try without su (for emulators with adb root)
        adb_cmd shell "cp /data/local/tmp/${CERT_HASH}.0 $cert_dest" 2>/dev/null || {
            log_error "Failed to copy certificate to system"
            return 1
        }
    fi

    # Set permissions
    adb_cmd shell "su -c 'chmod 644 $cert_dest'" 2>/dev/null || \
    adb_cmd shell "chmod 644 $cert_dest" 2>/dev/null || true

    # Set ownership
    adb_cmd shell "su -c 'chown root:root $cert_dest'" 2>/dev/null || \
    adb_cmd shell "chown root:root $cert_dest" 2>/dev/null || true

    # Remount as read-only
    adb_cmd shell "su -c 'mount -o ro,remount /system'" 2>/dev/null || true

    # Verify
    if adb_cmd shell "ls $cert_dest" &>/dev/null; then
        log_success "System CA certificate installed"
        return 0
    else
        log_error "Certificate installation failed"
        return 1
    fi
}

# Install for Android 14+ (APEX method)
install_android14_cert() {
    log_info "Installing certificate for Android 14+ (APEX method)..."

    local cert_name="${CERT_HASH}.0"

    # Push certificate to device
    adb_cmd push "$CONVERTED_CERT" /data/local/tmp/

    # Create the installation script
    cat > "$TEMP_DIR/install_cert.sh" << 'SCRIPT'
#!/system/bin/sh
# Android 14+ Certificate Installation Script

CERT_NAME="$1"
CERT_PATH="/data/local/tmp/$CERT_NAME"
APEX_CACERTS="/apex/com.android.conscrypt/cacerts"
SYSTEM_CACERTS="/system/etc/security/cacerts"

# Create temporary directory
TEMP_APEX="/data/local/tmp/cacerts_apex"
rm -rf "$TEMP_APEX"
mkdir -p "$TEMP_APEX"

# Copy existing certificates
if [ -d "$APEX_CACERTS" ]; then
    cp -a "$APEX_CACERTS/"* "$TEMP_APEX/" 2>/dev/null
elif [ -d "$SYSTEM_CACERTS" ]; then
    cp -a "$SYSTEM_CACERTS/"* "$TEMP_APEX/" 2>/dev/null
fi

# Add new certificate
cp "$CERT_PATH" "$TEMP_APEX/$CERT_NAME"
chmod 644 "$TEMP_APEX/$CERT_NAME"

# Bind mount over APEX cacerts
if [ -d "$APEX_CACERTS" ]; then
    # For Android 14+, we need to use nsenter
    # This mounts the temp directory over the APEX cacerts for all processes

    # First, remount as writable
    mount -o rw,remount /

    # Create bind mount
    mount --bind "$TEMP_APEX" "$APEX_CACERTS"

    echo "Certificate installed to APEX cacerts"
else
    # Fallback for older Android
    mount -o rw,remount /system
    cp "$CERT_PATH" "$SYSTEM_CACERTS/$CERT_NAME"
    chmod 644 "$SYSTEM_CACERTS/$CERT_NAME"
    mount -o ro,remount /system

    echo "Certificate installed to system cacerts"
fi

# Verify
if [ -f "$APEX_CACERTS/$CERT_NAME" ] || [ -f "$SYSTEM_CACERTS/$CERT_NAME" ]; then
    echo "SUCCESS"
else
    echo "FAILED"
fi
SCRIPT

    # Push and execute script
    adb_cmd push "$TEMP_DIR/install_cert.sh" /data/local/tmp/
    adb_cmd shell "chmod 755 /data/local/tmp/install_cert.sh"

    local result
    result=$(adb_cmd shell "su -c '/data/local/tmp/install_cert.sh ${CERT_HASH}.0'" 2>&1 | tr -d '\r')

    log_verbose "Installation result: $result"

    if echo "$result" | grep -q "SUCCESS"; then
        log_success "Certificate installed for Android 14+"
        log_warning "Note: This installation is not persistent across reboots"
        log_info "Consider using a Magisk module for persistent installation"
        return 0
    else
        log_error "Android 14 certificate installation failed"
        log_info "You may need to use a Magisk module for persistent CA installation"
        return 1
    fi
}

# Verify certificate installation
verify_installation() {
    log_info "Verifying certificate installation..."

    local cert_name="${CERT_HASH}.0"

    # Check system cacerts
    if adb_cmd shell "ls /system/etc/security/cacerts/$cert_name" &>/dev/null; then
        log_success "Certificate found in /system/etc/security/cacerts/"
        return 0
    fi

    # Check APEX cacerts (Android 14+)
    if adb_cmd shell "ls /apex/com.android.conscrypt/cacerts/$cert_name" &>/dev/null; then
        log_success "Certificate found in /apex/com.android.conscrypt/cacerts/"
        return 0
    fi

    # Check user cacerts
    local user_certs
    user_certs=$(adb_cmd shell "ls /data/misc/user/0/cacerts-added/" 2>/dev/null || echo "")
    if echo "$user_certs" | grep -q "$cert_name"; then
        log_success "Certificate found in user CA store"
        return 0
    fi

    log_warning "Certificate not found in expected locations"
    return 1
}

# Test certificate with curl
test_certificate() {
    log_info "Testing certificate..."

    # Test HTTPS connection through proxy
    local test_url="https://www.google.com"

    log_verbose "Testing HTTPS connection to $test_url"

    # We can't easily test from the device, but we can check if the cert is working
    # by attempting a connection through the proxy from the host

    if curl -sS --connect-timeout 5 \
         --proxy "http://$BURP_HOST:$BURP_PORT" \
         "$test_url" &>/dev/null; then
        log_success "HTTPS interception working via proxy"
    else
        log_verbose "Could not verify HTTPS interception from host"
    fi
}

# Main function
main() {
    echo ""
    echo "========================================"
    echo "  Burp CA Certificate Installer         "
    echo "========================================"
    echo ""

    parse_args "$@"

    # Create temp directory
    mkdir -p "$TEMP_DIR"

    # Check prerequisites
    check_prerequisites || exit 1
    check_device || exit 1
    check_root

    # Get certificate
    if [[ -z "$CERT_PATH" ]] && $EXPORT_FROM_BURP; then
        export_burp_cert || exit 1
    elif [[ -z "$CERT_PATH" ]]; then
        log_error "No certificate specified"
        log_info "Use --cert FILE or --export-from-burp"
        exit 1
    fi

    if [[ ! -f "$CERT_PATH" ]]; then
        log_error "Certificate file not found: $CERT_PATH"
        exit 1
    fi

    # Convert certificate
    convert_certificate || exit 1

    # Install certificate
    if $USER_CERT; then
        install_user_cert
    elif $ANDROID14_MODE; then
        install_android14_cert || install_user_cert
    else
        install_system_cert || install_user_cert
    fi

    # Verify
    verify_installation

    # Test
    if $EXPORT_FROM_BURP; then
        test_certificate
    fi

    echo ""
    log_success "Certificate installation complete!"
    echo ""

    # Reminder
    if ! $USER_CERT; then
        log_info "Reboot the device for the certificate to take effect:"
        log_info "  adb reboot"
    fi
}

main "$@"
