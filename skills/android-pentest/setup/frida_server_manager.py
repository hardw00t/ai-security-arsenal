#!/usr/bin/env python3
"""
Frida Server Manager for Android Devices

Manages Frida server installation, startup, and monitoring across multiple devices.

Usage:
    python frida_server_manager.py install [--device SERIAL] [--version VERSION]
    python frida_server_manager.py start [--device SERIAL]
    python frida_server_manager.py stop [--device SERIAL]
    python frida_server_manager.py status [--device SERIAL]
    python frida_server_manager.py monitor [--device SERIAL] [--restart-on-crash]
    python frida_server_manager.py list-devices
"""

import argparse
import json
import os
import shutil
import signal
import subprocess
import sys
import tempfile
import threading
import time
import urllib.request
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional
from enum import Enum


class ServerStatus(Enum):
    """Frida server status."""
    RUNNING = "running"
    STOPPED = "stopped"
    NOT_INSTALLED = "not_installed"
    ERROR = "error"


@dataclass
class DeviceInfo:
    """Android device information."""
    serial: str
    model: str
    android_version: str
    architecture: str
    is_emulator: bool
    root_available: bool
    frida_installed: bool
    frida_running: bool
    frida_version: Optional[str] = None


class FridaServerManager:
    """Manages Frida server across Android devices."""

    # Architecture mapping
    ARCH_MAP = {
        "arm64-v8a": "arm64",
        "armeabi-v7a": "arm",
        "armeabi": "arm",
        "x86_64": "x86_64",
        "x86": "x86",
    }

    FRIDA_SERVER_PATH = "/data/local/tmp/frida-server"
    FRIDA_PID_PATH = "/data/local/tmp/frida-server.pid"

    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.adb_path = self._find_adb()
        self.temp_dir = Path(tempfile.mkdtemp(prefix="frida_mgr_"))
        self._download_cache: Dict[str, Path] = {}
        self._monitors: Dict[str, threading.Thread] = {}
        self._stop_monitoring = threading.Event()

    def _log(self, message: str, level: str = "INFO"):
        """Log a message."""
        colors = {
            "INFO": "\033[94m",
            "SUCCESS": "\033[92m",
            "WARNING": "\033[93m",
            "ERROR": "\033[91m",
            "DEBUG": "\033[96m",
        }
        reset = "\033[0m"
        color = colors.get(level, "")

        if level == "DEBUG" and not self.verbose:
            return

        timestamp = time.strftime("%H:%M:%S")
        print(f"{color}[{timestamp}] [{level}]{reset} {message}")

    def _find_adb(self) -> str:
        """Find ADB executable."""
        # Check PATH
        adb_path = shutil.which("adb")
        if adb_path:
            return adb_path

        # Check Android SDK
        android_home = os.environ.get("ANDROID_HOME") or os.environ.get("ANDROID_SDK_ROOT")
        if android_home:
            adb = Path(android_home) / "platform-tools" / "adb"
            if adb.exists():
                return str(adb)

        raise RuntimeError("ADB not found. Install Android SDK Platform Tools.")

    def _run_adb(self, *args, serial: Optional[str] = None,
                 timeout: int = 30) -> subprocess.CompletedProcess:
        """Run ADB command."""
        cmd = [self.adb_path]
        if serial:
            cmd.extend(["-s", serial])
        cmd.extend(args)

        self._log(f"Running: {' '.join(cmd)}", "DEBUG")

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            return result
        except subprocess.TimeoutExpired:
            self._log(f"ADB command timed out", "WARNING")
            return subprocess.CompletedProcess(cmd, 1, "", "Timeout")

    def _adb_shell(self, command: str, serial: Optional[str] = None,
                   root: bool = False, timeout: int = 30) -> str:
        """Run shell command on device."""
        if root:
            # Try su first
            result = self._run_adb("shell", f"su -c '{command}'",
                                   serial=serial, timeout=timeout)
            if result.returncode == 0:
                return result.stdout.strip()

            # Fall back to adb root
            self._run_adb("root", serial=serial)
            time.sleep(1)

        result = self._run_adb("shell", command, serial=serial, timeout=timeout)
        return result.stdout.strip()

    def list_devices(self) -> List[DeviceInfo]:
        """List all connected devices."""
        result = self._run_adb("devices", "-l")
        devices = []

        for line in result.stdout.split("\n"):
            if "\tdevice" in line:
                parts = line.split()
                serial = parts[0]

                # Get device info
                model = self._adb_shell("getprop ro.product.model", serial=serial)
                android_ver = self._adb_shell(
                    "getprop ro.build.version.release",
                    serial=serial
                )
                abi = self._adb_shell("getprop ro.product.cpu.abi", serial=serial)
                arch = self.ARCH_MAP.get(abi, abi)

                is_emulator = "emulator" in serial.lower() or \
                              "goldfish" in self._adb_shell(
                                  "getprop ro.hardware",
                                  serial=serial
                              ).lower()

                # Check root
                root_check = self._adb_shell("su -c 'id'", serial=serial)
                root_available = "uid=0" in root_check

                # Check Frida
                frida_check = self._adb_shell(
                    f"ls {self.FRIDA_SERVER_PATH} 2>/dev/null",
                    serial=serial
                )
                frida_installed = self.FRIDA_SERVER_PATH in frida_check

                # Check if running
                frida_pid = self._adb_shell("pgrep -f frida-server", serial=serial)
                frida_running = bool(frida_pid.strip())

                # Get Frida version
                frida_version = None
                if frida_installed:
                    version_output = self._adb_shell(
                        f"{self.FRIDA_SERVER_PATH} --version 2>/dev/null || echo ''",
                        serial=serial,
                        timeout=5
                    )
                    if version_output and "frida" not in version_output.lower():
                        frida_version = version_output.strip()

                devices.append(DeviceInfo(
                    serial=serial,
                    model=model,
                    android_version=android_ver,
                    architecture=arch,
                    is_emulator=is_emulator,
                    root_available=root_available,
                    frida_installed=frida_installed,
                    frida_running=frida_running,
                    frida_version=frida_version
                ))

        return devices

    def get_device(self, serial: Optional[str] = None) -> Optional[DeviceInfo]:
        """Get a specific device or first available."""
        devices = self.list_devices()

        if not devices:
            self._log("No devices connected", "ERROR")
            return None

        if serial:
            for device in devices:
                if device.serial == serial:
                    return device
            self._log(f"Device {serial} not found", "ERROR")
            return None

        return devices[0]

    def get_latest_frida_version(self) -> str:
        """Get latest Frida release version."""
        try:
            url = "https://api.github.com/repos/frida/frida/releases/latest"
            with urllib.request.urlopen(url, timeout=10) as response:
                data = json.loads(response.read())
                return data["tag_name"]
        except Exception as e:
            self._log(f"Failed to get latest version: {e}", "WARNING")
            return "16.5.6"  # Fallback version

    def download_frida_server(self, version: str, arch: str) -> Path:
        """Download Frida server for specified architecture."""
        cache_key = f"{version}-{arch}"
        if cache_key in self._download_cache:
            cached = self._download_cache[cache_key]
            if cached.exists():
                self._log(f"Using cached download: {cached}", "DEBUG")
                return cached

        filename = f"frida-server-{version}-android-{arch}.xz"
        url = f"https://github.com/frida/frida/releases/download/{version}/{filename}"

        download_path = self.temp_dir / filename
        server_path = self.temp_dir / f"frida-server-{version}-{arch}"

        self._log(f"Downloading Frida server {version} for {arch}...")

        try:
            urllib.request.urlretrieve(url, download_path)

            # Extract
            subprocess.run(["xz", "-d", "-f", str(download_path)], check=True)

            # Rename extracted file
            extracted = self.temp_dir / f"frida-server-{version}-android-{arch}"
            if extracted.exists():
                extracted.rename(server_path)

            self._download_cache[cache_key] = server_path
            self._log("Download complete", "SUCCESS")
            return server_path

        except Exception as e:
            self._log(f"Download failed: {e}", "ERROR")
            raise

    def install(self, serial: Optional[str] = None, version: str = "latest",
                force: bool = False) -> bool:
        """Install Frida server on device."""
        device = self.get_device(serial)
        if not device:
            return False

        self._log(f"Installing Frida server on {device.serial} ({device.model})")

        # Check if already installed
        if device.frida_installed and not force:
            self._log("Frida server already installed. Use --force to reinstall.",
                     "WARNING")
            return True

        # Get version
        if version == "latest":
            version = self.get_latest_frida_version()
        self._log(f"Using Frida version: {version}")

        # Download
        try:
            server_path = self.download_frida_server(version, device.architecture)
        except Exception as e:
            self._log(f"Failed to download Frida server: {e}", "ERROR")
            return False

        # Stop existing server
        self.stop(device.serial)

        # Push to device
        self._log("Pushing Frida server to device...")
        result = self._run_adb(
            "push", str(server_path), self.FRIDA_SERVER_PATH,
            serial=device.serial
        )
        if result.returncode != 0:
            self._log(f"Push failed: {result.stderr}", "ERROR")
            return False

        # Set permissions
        self._adb_shell(f"chmod 755 {self.FRIDA_SERVER_PATH}", serial=device.serial)

        # Verify
        check = self._adb_shell(f"ls -la {self.FRIDA_SERVER_PATH}", serial=device.serial)
        if self.FRIDA_SERVER_PATH not in check:
            self._log("Installation verification failed", "ERROR")
            return False

        self._log("Frida server installed successfully", "SUCCESS")
        return True

    def start(self, serial: Optional[str] = None, daemon: bool = True) -> bool:
        """Start Frida server."""
        device = self.get_device(serial)
        if not device:
            return False

        if not device.frida_installed:
            self._log("Frida server not installed. Run install first.", "ERROR")
            return False

        if device.frida_running:
            self._log("Frida server already running", "WARNING")
            return True

        self._log(f"Starting Frida server on {device.serial}...")

        # Try with root
        daemon_flag = "-D" if daemon else ""

        if device.root_available:
            # Use su
            self._adb_shell(
                f"su -c '{self.FRIDA_SERVER_PATH} {daemon_flag} &'",
                serial=device.serial
            )
        else:
            # Try adb root for emulators
            self._run_adb("root", serial=device.serial)
            time.sleep(1)
            self._adb_shell(
                f"{self.FRIDA_SERVER_PATH} {daemon_flag} &",
                serial=device.serial
            )

        # Wait and verify
        time.sleep(2)
        pid = self._adb_shell("pgrep -f frida-server", serial=device.serial)

        if pid:
            self._log(f"Frida server started (PID: {pid})", "SUCCESS")

            # Save PID
            self._adb_shell(
                f"echo {pid} > {self.FRIDA_PID_PATH}",
                serial=device.serial
            )
            return True
        else:
            self._log("Failed to start Frida server", "ERROR")
            return False

    def stop(self, serial: Optional[str] = None) -> bool:
        """Stop Frida server."""
        device = self.get_device(serial)
        if not device:
            return False

        if not device.frida_running:
            self._log("Frida server not running", "DEBUG")
            return True

        self._log(f"Stopping Frida server on {device.serial}...")

        # Kill process
        if device.root_available:
            self._adb_shell("su -c 'pkill -9 frida-server'", serial=device.serial)
        else:
            self._adb_shell("pkill -9 frida-server", serial=device.serial)

        # Clean up PID file
        self._adb_shell(f"rm -f {self.FRIDA_PID_PATH}", serial=device.serial)

        time.sleep(1)

        # Verify
        pid = self._adb_shell("pgrep -f frida-server", serial=device.serial)
        if not pid:
            self._log("Frida server stopped", "SUCCESS")
            return True
        else:
            self._log("Failed to stop Frida server", "ERROR")
            return False

    def restart(self, serial: Optional[str] = None) -> bool:
        """Restart Frida server."""
        self.stop(serial)
        time.sleep(1)
        return self.start(serial)

    def status(self, serial: Optional[str] = None) -> ServerStatus:
        """Get Frida server status."""
        device = self.get_device(serial)
        if not device:
            return ServerStatus.ERROR

        if not device.frida_installed:
            return ServerStatus.NOT_INSTALLED

        if device.frida_running:
            return ServerStatus.RUNNING

        return ServerStatus.STOPPED

    def verify_connection(self, serial: Optional[str] = None) -> bool:
        """Verify Frida connection by listing processes."""
        device = self.get_device(serial)
        if not device:
            return False

        # Check if frida-tools is installed
        try:
            import frida
        except ImportError:
            self._log("frida-tools not installed. Install with: pip install frida-tools",
                     "WARNING")
            # Try command line
            frida_ps = shutil.which("frida-ps")
            if not frida_ps:
                return False

            result = subprocess.run(
                [frida_ps, "-D", device.serial],
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.returncode == 0

        # Use frida module
        try:
            device_mgr = frida.get_device_manager()
            frida_device = device_mgr.get_device(device.serial, timeout=5)
            processes = frida_device.enumerate_processes()

            self._log(f"Connected! Found {len(processes)} processes", "SUCCESS")
            return True
        except Exception as e:
            self._log(f"Connection failed: {e}", "ERROR")
            return False

    def monitor(self, serial: Optional[str] = None,
                restart_on_crash: bool = True,
                interval: int = 5):
        """Monitor Frida server and optionally restart on crash."""
        device = self.get_device(serial)
        if not device:
            return

        self._log(f"Monitoring Frida server on {device.serial}")
        self._log("Press Ctrl+C to stop monitoring")

        crash_count = 0
        max_crashes = 5

        try:
            while not self._stop_monitoring.is_set():
                status = self.status(device.serial)

                if status == ServerStatus.RUNNING:
                    crash_count = 0  # Reset on successful check
                elif status == ServerStatus.STOPPED:
                    self._log("Frida server crashed!", "WARNING")
                    crash_count += 1

                    if restart_on_crash and crash_count < max_crashes:
                        self._log(f"Restarting... (attempt {crash_count}/{max_crashes})")
                        self.start(device.serial)
                    elif crash_count >= max_crashes:
                        self._log(f"Too many crashes ({crash_count}). Stopping monitor.",
                                 "ERROR")
                        break

                time.sleep(interval)

        except KeyboardInterrupt:
            self._log("Monitoring stopped")

    def cleanup(self):
        """Clean up temporary files."""
        self._stop_monitoring.set()
        if self.temp_dir.exists():
            shutil.rmtree(self.temp_dir, ignore_errors=True)


def print_devices_table(devices: List[DeviceInfo]):
    """Print devices in a table format."""
    if not devices:
        print("No devices connected")
        return

    # Header
    print("\n" + "=" * 90)
    print(f"{'Serial':<20} {'Model':<15} {'Android':<8} {'Arch':<8} "
          f"{'Root':<6} {'Frida':<10} {'Status':<10}")
    print("=" * 90)

    for d in devices:
        root = "Yes" if d.root_available else "No"
        frida = d.frida_version or ("Yes" if d.frida_installed else "No")
        status = "Running" if d.frida_running else "Stopped" if d.frida_installed else "-"

        emu_tag = " (emu)" if d.is_emulator else ""
        print(f"{d.serial:<20} {d.model[:14]:<15} {d.android_version:<8} "
              f"{d.architecture:<8} {root:<6} {frida:<10} {status:<10}{emu_tag}")

    print("=" * 90 + "\n")


def main():
    parser = argparse.ArgumentParser(
        description="Frida Server Manager for Android Devices",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  frida_server_manager.py list-devices
  frida_server_manager.py install --device emulator-5554 --version 16.5.6
  frida_server_manager.py start --device emulator-5554
  frida_server_manager.py monitor --restart-on-crash
        """
    )
    parser.add_argument("-v", "--verbose", action="store_true",
                       help="Verbose output")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # List devices
    subparsers.add_parser("list-devices", help="List connected devices")

    # Install
    install_parser = subparsers.add_parser("install", help="Install Frida server")
    install_parser.add_argument("-d", "--device", help="Device serial")
    install_parser.add_argument("--version", default="latest",
                               help="Frida version (default: latest)")
    install_parser.add_argument("-f", "--force", action="store_true",
                               help="Force reinstall")

    # Start
    start_parser = subparsers.add_parser("start", help="Start Frida server")
    start_parser.add_argument("-d", "--device", help="Device serial")
    start_parser.add_argument("--no-daemon", action="store_true",
                             help="Run in foreground")

    # Stop
    stop_parser = subparsers.add_parser("stop", help="Stop Frida server")
    stop_parser.add_argument("-d", "--device", help="Device serial")

    # Restart
    restart_parser = subparsers.add_parser("restart", help="Restart Frida server")
    restart_parser.add_argument("-d", "--device", help="Device serial")

    # Status
    status_parser = subparsers.add_parser("status", help="Check Frida server status")
    status_parser.add_argument("-d", "--device", help="Device serial")

    # Verify
    verify_parser = subparsers.add_parser("verify", help="Verify Frida connection")
    verify_parser.add_argument("-d", "--device", help="Device serial")

    # Monitor
    monitor_parser = subparsers.add_parser("monitor", help="Monitor Frida server")
    monitor_parser.add_argument("-d", "--device", help="Device serial")
    monitor_parser.add_argument("--restart-on-crash", action="store_true",
                               help="Auto-restart on crash")
    monitor_parser.add_argument("--interval", type=int, default=5,
                               help="Check interval in seconds")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    manager = FridaServerManager(verbose=args.verbose)

    try:
        if args.command == "list-devices":
            devices = manager.list_devices()
            print_devices_table(devices)

        elif args.command == "install":
            success = manager.install(
                serial=args.device,
                version=args.version,
                force=args.force
            )
            return 0 if success else 1

        elif args.command == "start":
            success = manager.start(
                serial=args.device,
                daemon=not args.no_daemon
            )
            return 0 if success else 1

        elif args.command == "stop":
            success = manager.stop(serial=args.device)
            return 0 if success else 1

        elif args.command == "restart":
            success = manager.restart(serial=args.device)
            return 0 if success else 1

        elif args.command == "status":
            device = manager.get_device(args.device)
            if device:
                print(f"\nDevice: {device.serial} ({device.model})")
                print(f"  Architecture: {device.architecture}")
                print(f"  Android: {device.android_version}")
                print(f"  Root: {'Yes' if device.root_available else 'No'}")
                print(f"  Frida Installed: {'Yes' if device.frida_installed else 'No'}")
                print(f"  Frida Running: {'Yes' if device.frida_running else 'No'}")
                if device.frida_version:
                    print(f"  Frida Version: {device.frida_version}")
                print()

        elif args.command == "verify":
            success = manager.verify_connection(serial=args.device)
            return 0 if success else 1

        elif args.command == "monitor":
            manager.monitor(
                serial=args.device,
                restart_on_crash=args.restart_on_crash,
                interval=args.interval
            )

        return 0

    finally:
        manager.cleanup()


if __name__ == "__main__":
    sys.exit(main())
