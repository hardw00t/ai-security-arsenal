#!/usr/bin/env python3
"""
Android Emulator Setup for Penetration Testing

Creates and configures Android emulators optimized for security testing.

Usage:
    python setup_emulator.py create --name pentest-avd --api 30
    python setup_emulator.py configure --name pentest-avd --proxy 192.168.1.100:8080
    python setup_emulator.py start --name pentest-avd --writable
    python setup_emulator.py snapshot --name pentest-avd --save clean-state
    python setup_emulator.py root --name pentest-avd
"""

import argparse
import json
import os
import platform
import re
import shutil
import subprocess
import sys
import tempfile
import time
import urllib.request
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional


@dataclass
class EmulatorConfig:
    """Emulator configuration."""
    name: str
    api_level: int = 30
    arch: str = "x86_64"
    device: str = "pixel_4"
    ram: int = 4096
    heap: int = 512
    disk_size: str = "8G"
    gpu: str = "auto"
    play_store: bool = False
    root: bool = True
    writable_system: bool = True
    snapshot: Optional[str] = None


class EmulatorSetup:
    """Android emulator setup and configuration."""

    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.android_home = self._get_android_home()
        self.sdk_manager = self._get_sdk_manager()
        self.avd_manager = self._get_avd_manager()
        self.emulator_bin = self._get_emulator()
        self.adb = self._get_adb()
        self.temp_dir = Path(tempfile.mkdtemp(prefix="emu_setup_"))

    def _log(self, message: str, level: str = "INFO"):
        """Log message."""
        colors = {
            "INFO": "\033[94m",
            "SUCCESS": "\033[92m",
            "WARNING": "\033[93m",
            "ERROR": "\033[91m",
            "DEBUG": "\033[96m",
        }
        reset = "\033[0m"
        color = colors.get(level, "")

        if level == "DEBUG" and not self.verbose:
            return

        print(f"{color}[{level}]{reset} {message}")

    def _get_android_home(self) -> Path:
        """Get Android SDK path."""
        # Check environment variable
        android_home = os.environ.get("ANDROID_HOME") or os.environ.get("ANDROID_SDK_ROOT")

        if android_home:
            return Path(android_home)

        # Common locations
        home = Path.home()
        locations = [
            home / "Android" / "Sdk",
            home / "Library" / "Android" / "sdk",
            Path("/usr/lib/android-sdk"),
            home / ".android" / "sdk",
        ]

        for loc in locations:
            if loc.exists():
                return loc

        self._log("Android SDK not found. Please set ANDROID_HOME.", "ERROR")
        sys.exit(1)

    def _get_sdk_manager(self) -> Path:
        """Get sdkmanager path."""
        candidates = [
            self.android_home / "cmdline-tools" / "latest" / "bin" / "sdkmanager",
            self.android_home / "cmdline-tools" / "bin" / "sdkmanager",
            self.android_home / "tools" / "bin" / "sdkmanager",
        ]

        for candidate in candidates:
            if candidate.exists():
                return candidate

        self._log("sdkmanager not found. Install command-line tools.", "ERROR")
        sys.exit(1)

    def _get_avd_manager(self) -> Path:
        """Get avdmanager path."""
        candidates = [
            self.android_home / "cmdline-tools" / "latest" / "bin" / "avdmanager",
            self.android_home / "cmdline-tools" / "bin" / "avdmanager",
            self.android_home / "tools" / "bin" / "avdmanager",
        ]

        for candidate in candidates:
            if candidate.exists():
                return candidate

        self._log("avdmanager not found", "ERROR")
        sys.exit(1)

    def _get_emulator(self) -> Path:
        """Get emulator path."""
        emulator = self.android_home / "emulator" / "emulator"
        if not emulator.exists():
            emulator = self.android_home / "tools" / "emulator"

        if not emulator.exists():
            self._log("Emulator not found", "ERROR")
            sys.exit(1)

        return emulator

    def _get_adb(self) -> Path:
        """Get ADB path."""
        adb = self.android_home / "platform-tools" / "adb"

        if not adb.exists():
            # Try system PATH
            adb_path = shutil.which("adb")
            if adb_path:
                return Path(adb_path)

            self._log("ADB not found", "ERROR")
            sys.exit(1)

        return adb

    def _run_cmd(self, cmd: list, check: bool = True, capture: bool = True,
                 timeout: int = 300) -> subprocess.CompletedProcess:
        """Run a command."""
        self._log(f"Running: {' '.join(str(c) for c in cmd)}", "DEBUG")

        try:
            result = subprocess.run(
                cmd,
                capture_output=capture,
                text=True,
                timeout=timeout,
                check=check
            )
            return result
        except subprocess.TimeoutExpired:
            self._log(f"Command timed out: {cmd}", "ERROR")
            raise
        except subprocess.CalledProcessError as e:
            self._log(f"Command failed: {e.stderr}", "ERROR")
            raise

    def _adb_cmd(self, *args, serial: Optional[str] = None) -> subprocess.CompletedProcess:
        """Run ADB command."""
        cmd = [str(self.adb)]
        if serial:
            cmd.extend(["-s", serial])
        cmd.extend(args)
        return self._run_cmd(cmd, check=False)

    def _adb_shell(self, command: str, serial: Optional[str] = None,
                   root: bool = False) -> str:
        """Run ADB shell command."""
        if root:
            command = f"su -c '{command}'"

        result = self._adb_cmd("shell", command, serial=serial)
        return result.stdout.strip() if result.stdout else ""

    def list_available_packages(self) -> dict:
        """List available system images."""
        self._log("Fetching available system images...")

        result = self._run_cmd([str(self.sdk_manager), "--list"], check=False)

        packages = {
            "system_images": [],
            "platforms": []
        }

        if result.stdout:
            for line in result.stdout.split("\n"):
                if "system-images" in line:
                    # Parse: system-images;android-30;google_apis;x86_64
                    match = re.search(r"(system-images;[^\s]+)", line)
                    if match:
                        packages["system_images"].append(match.group(1))
                elif "platforms;android-" in line:
                    match = re.search(r"(platforms;android-\d+)", line)
                    if match:
                        packages["platforms"].append(match.group(1))

        return packages

    def install_system_image(self, api_level: int, arch: str = "x86_64",
                            with_play_store: bool = False) -> str:
        """Install system image."""
        # Determine image variant
        if with_play_store:
            variant = "google_apis_playstore"
        else:
            variant = "google_apis"

        package = f"system-images;android-{api_level};{variant};{arch}"

        self._log(f"Installing system image: {package}")

        # Accept licenses
        accept_proc = subprocess.Popen(
            [str(self.sdk_manager), "--licenses"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        accept_proc.communicate(input="y\n" * 20, timeout=60)

        # Install
        result = self._run_cmd(
            [str(self.sdk_manager), "--install", package],
            timeout=600
        )

        if result.returncode != 0:
            # Try without play store
            if with_play_store:
                self._log("Play Store image not available, trying without...", "WARNING")
                return self.install_system_image(api_level, arch, False)

            self._log(f"Failed to install system image: {result.stderr}", "ERROR")
            raise RuntimeError("System image installation failed")

        self._log("System image installed", "SUCCESS")
        return package

    def create_avd(self, config: EmulatorConfig) -> bool:
        """Create Android Virtual Device."""
        self._log(f"Creating AVD: {config.name}")

        # Check if AVD exists
        result = self._run_cmd([str(self.avd_manager), "list", "avd"], check=False)
        if config.name in (result.stdout or ""):
            self._log(f"AVD {config.name} already exists", "WARNING")
            return True

        # Ensure system image is installed
        variant = "google_apis_playstore" if config.play_store else "google_apis"
        package = f"system-images;android-{config.api_level};{variant};{config.arch}"

        try:
            self.install_system_image(
                config.api_level,
                config.arch,
                config.play_store
            )
        except Exception as e:
            self._log(f"Failed to install system image: {e}", "ERROR")
            return False

        # Create AVD
        cmd = [
            str(self.avd_manager),
            "create", "avd",
            "--name", config.name,
            "--package", package,
            "--device", config.device,
            "--force"
        ]

        proc = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = proc.communicate(input="no\n", timeout=60)

        if proc.returncode != 0:
            self._log(f"Failed to create AVD: {stderr}", "ERROR")
            return False

        # Configure AVD
        self._configure_avd_ini(config)

        self._log(f"AVD {config.name} created", "SUCCESS")
        return True

    def _configure_avd_ini(self, config: EmulatorConfig):
        """Configure AVD settings in config.ini."""
        avd_dir = Path.home() / ".android" / "avd" / f"{config.name}.avd"
        config_ini = avd_dir / "config.ini"

        if not config_ini.exists():
            self._log("AVD config.ini not found", "WARNING")
            return

        # Read existing config
        with open(config_ini) as f:
            lines = f.readlines()

        # Settings to update
        settings = {
            "hw.ramSize": str(config.ram),
            "vm.heapSize": str(config.heap),
            "disk.dataPartition.size": config.disk_size,
            "hw.gpu.enabled": "yes",
            "hw.gpu.mode": config.gpu,
            "hw.keyboard": "yes",
            "hw.mainKeys": "no",
            "hw.camera.back": "virtualscene",
            "hw.camera.front": "emulated",
            "fastboot.forceColdBoot": "no",
            "fastboot.forceFastBoot": "yes",
        }

        # Update config
        updated_lines = []
        updated_keys = set()

        for line in lines:
            key = line.split("=")[0].strip()
            if key in settings:
                updated_lines.append(f"{key}={settings[key]}\n")
                updated_keys.add(key)
            else:
                updated_lines.append(line)

        # Add missing settings
        for key, value in settings.items():
            if key not in updated_keys:
                updated_lines.append(f"{key}={value}\n")

        with open(config_ini, "w") as f:
            f.writelines(updated_lines)

        self._log("AVD configuration updated", "DEBUG")

    def start_emulator(self, name: str, writable: bool = False,
                      no_snapshot: bool = False, proxy: Optional[str] = None,
                      gpu: str = "auto") -> Optional[str]:
        """Start emulator and return serial."""
        self._log(f"Starting emulator: {name}")

        cmd = [
            str(self.emulator_bin),
            "-avd", name,
            "-gpu", gpu,
            "-no-audio",
            "-no-boot-anim",
        ]

        if writable:
            cmd.append("-writable-system")

        if no_snapshot:
            cmd.append("-no-snapshot-load")

        if proxy:
            cmd.extend(["-http-proxy", proxy])

        self._log(f"Emulator command: {' '.join(cmd)}", "DEBUG")

        # Start emulator in background
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

        # Wait for emulator to boot
        self._log("Waiting for emulator to boot...")
        serial = self._wait_for_emulator(timeout=180)

        if serial:
            self._log(f"Emulator started: {serial}", "SUCCESS")
            return serial
        else:
            self._log("Emulator failed to start", "ERROR")
            process.terminate()
            return None

    def _wait_for_emulator(self, timeout: int = 180) -> Optional[str]:
        """Wait for emulator to be ready."""
        start_time = time.time()

        while time.time() - start_time < timeout:
            # Get list of emulators
            result = self._adb_cmd("devices")
            if result.stdout:
                for line in result.stdout.split("\n"):
                    if "emulator-" in line and "device" in line:
                        serial = line.split()[0]

                        # Check if boot completed
                        boot_status = self._adb_shell(
                            "getprop sys.boot_completed",
                            serial=serial
                        )

                        if boot_status == "1":
                            return serial

            time.sleep(2)

        return None

    def root_emulator(self, serial: str, method: str = "system") -> bool:
        """Root the emulator."""
        self._log("Rooting emulator...")

        if method == "system":
            return self._root_via_system(serial)
        elif method == "magisk":
            return self._root_via_magisk(serial)
        else:
            self._log(f"Unknown rooting method: {method}", "ERROR")
            return False

    def _root_via_system(self, serial: str) -> bool:
        """Root emulator by modifying system."""
        # Restart ADB as root
        result = self._adb_cmd("root", serial=serial)
        time.sleep(2)

        # Check root access
        uid = self._adb_shell("id", serial=serial)
        if "uid=0" in uid:
            self._log("ADB root access enabled", "SUCCESS")
        else:
            self._log("ADB root access not available", "WARNING")

        # Remount system as writable
        self._adb_cmd("remount", serial=serial)
        time.sleep(1)

        # Disable secure boot properties
        props = [
            ("ro.debuggable", "1"),
            ("ro.secure", "0"),
            ("ro.adb.secure", "0"),
            ("service.adb.root", "1"),
        ]

        for prop, value in props:
            self._adb_shell(f"setprop {prop} {value}", serial=serial)

        self._log("System rooting complete", "SUCCESS")
        return True

    def _root_via_magisk(self, serial: str) -> bool:
        """Root emulator using Magisk."""
        self._log("Installing Magisk...")

        # Download Magisk APK
        magisk_url = "https://github.com/topjohnwu/Magisk/releases/latest/download/Magisk-v28.0.apk"
        magisk_apk = self.temp_dir / "Magisk.apk"

        try:
            self._log("Downloading Magisk...", "DEBUG")
            urllib.request.urlretrieve(magisk_url, magisk_apk)
        except Exception as e:
            self._log(f"Failed to download Magisk: {e}", "ERROR")
            return False

        # Install Magisk app
        result = self._adb_cmd("install", "-r", str(magisk_apk), serial=serial)
        if result.returncode != 0:
            self._log("Failed to install Magisk APK", "ERROR")
            return False

        self._log("Magisk APK installed - manual patching required", "WARNING")
        self._log("Steps to complete Magisk installation:")
        self._log("  1. Open Magisk app on the emulator")
        self._log("  2. Tap 'Install' next to Magisk")
        self._log("  3. Select 'Direct Install (Recommended)'")
        self._log("  4. Reboot the emulator")

        return True

    def install_frida_server(self, serial: str, version: str = "latest") -> bool:
        """Install Frida server on emulator."""
        self._log("Installing Frida server...")

        # Get architecture
        arch = self._adb_shell("getprop ro.product.cpu.abi", serial=serial)
        arch_map = {
            "x86_64": "x86_64",
            "x86": "x86",
            "arm64-v8a": "arm64",
            "armeabi-v7a": "arm",
        }
        frida_arch = arch_map.get(arch, "x86_64")

        # Get latest version if needed
        if version == "latest":
            try:
                with urllib.request.urlopen(
                    "https://api.github.com/repos/frida/frida/releases/latest"
                ) as response:
                    data = json.loads(response.read())
                    version = data["tag_name"]
            except Exception:
                version = "16.5.6"  # Fallback version

        self._log(f"Using Frida version: {version}")

        # Download
        filename = f"frida-server-{version}-android-{frida_arch}.xz"
        url = f"https://github.com/frida/frida/releases/download/{version}/{filename}"

        download_path = self.temp_dir / filename
        server_path = self.temp_dir / f"frida-server-{version}-android-{frida_arch}"

        try:
            self._log(f"Downloading from: {url}", "DEBUG")
            urllib.request.urlretrieve(url, download_path)

            # Extract
            self._run_cmd(["xz", "-d", str(download_path)])
        except Exception as e:
            self._log(f"Failed to download Frida: {e}", "ERROR")
            return False

        # Push to emulator
        self._adb_cmd("root", serial=serial)
        time.sleep(1)

        self._adb_cmd("push", str(server_path), "/data/local/tmp/frida-server",
                     serial=serial)
        self._adb_shell("chmod 755 /data/local/tmp/frida-server", serial=serial)

        # Create startup script
        startup_script = """#!/system/bin/sh
/data/local/tmp/frida-server -D &
"""
        script_path = self.temp_dir / "99frida"
        with open(script_path, "w") as f:
            f.write(startup_script)

        # Install startup script
        self._adb_cmd("remount", serial=serial)
        self._adb_cmd("push", str(script_path), "/system/etc/init.d/99frida",
                     serial=serial)
        self._adb_shell("chmod 755 /system/etc/init.d/99frida", serial=serial)

        self._log("Frida server installed", "SUCCESS")
        return True

    def start_frida_server(self, serial: str) -> bool:
        """Start Frida server."""
        self._log("Starting Frida server...")

        # Kill existing
        self._adb_shell("pkill -f frida-server", serial=serial)
        time.sleep(1)

        # Start
        self._adb_shell("/data/local/tmp/frida-server -D &", serial=serial)
        time.sleep(2)

        # Verify
        pids = self._adb_shell("pgrep -f frida-server", serial=serial)
        if pids:
            self._log(f"Frida server running (PID: {pids})", "SUCCESS")
            return True
        else:
            self._log("Frida server failed to start", "ERROR")
            return False

    def install_ca_cert(self, serial: str, cert_path: str) -> bool:
        """Install CA certificate as system cert."""
        self._log(f"Installing CA certificate: {cert_path}")

        cert_path = Path(cert_path)
        if not cert_path.exists():
            self._log("Certificate file not found", "ERROR")
            return False

        # Convert to Android format
        result = self._run_cmd([
            "openssl", "x509", "-inform", "PEM",
            "-subject_hash_old", "-in", str(cert_path), "-noout"
        ], check=False)

        if result.returncode != 0:
            # Try DER format
            result = self._run_cmd([
                "openssl", "x509", "-inform", "DER",
                "-subject_hash_old", "-in", str(cert_path), "-noout"
            ])

        subject_hash = result.stdout.strip()
        android_cert = self.temp_dir / f"{subject_hash}.0"

        # Create Android cert format
        self._run_cmd([
            "openssl", "x509", "-inform", "PEM",
            "-text", "-in", str(cert_path), "-out", str(android_cert)
        ], check=False)

        # Push to emulator
        self._adb_cmd("root", serial=serial)
        self._adb_cmd("remount", serial=serial)
        time.sleep(1)

        self._adb_cmd("push", str(android_cert),
                     f"/system/etc/security/cacerts/{subject_hash}.0",
                     serial=serial)
        self._adb_shell(
            f"chmod 644 /system/etc/security/cacerts/{subject_hash}.0",
            serial=serial
        )

        self._log("CA certificate installed", "SUCCESS")
        return True

    def configure_proxy(self, serial: str, proxy_host: str, proxy_port: int) -> bool:
        """Configure global proxy."""
        self._log(f"Configuring proxy: {proxy_host}:{proxy_port}")

        self._adb_shell(
            f"settings put global http_proxy {proxy_host}:{proxy_port}",
            serial=serial
        )

        # Verify
        current_proxy = self._adb_shell(
            "settings get global http_proxy",
            serial=serial
        )

        if f"{proxy_host}:{proxy_port}" in current_proxy:
            self._log("Proxy configured", "SUCCESS")
            return True
        else:
            self._log("Proxy configuration may have failed", "WARNING")
            return False

    def save_snapshot(self, name: str, snapshot_name: str) -> bool:
        """Save emulator snapshot."""
        self._log(f"Saving snapshot: {snapshot_name}")

        # Use emulator console to save snapshot
        # First, find the console port
        result = self._adb_cmd("devices")
        serial = None
        for line in result.stdout.split("\n"):
            if "emulator-" in line:
                serial = line.split()[0]
                break

        if not serial:
            self._log("No emulator found", "ERROR")
            return False

        port = int(serial.split("-")[1])

        # Send snapshot command via console
        import socket
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect(("localhost", port))

            # Authenticate (read auth token)
            auth_token_path = Path.home() / ".emulator_console_auth_token"
            if auth_token_path.exists():
                auth_token = auth_token_path.read_text().strip()
                sock.sendall(f"auth {auth_token}\n".encode())
                sock.recv(1024)

            # Save snapshot
            sock.sendall(f"avd snapshot save {snapshot_name}\n".encode())
            response = sock.recv(4096).decode()
            sock.close()

            if "OK" in response:
                self._log(f"Snapshot '{snapshot_name}' saved", "SUCCESS")
                return True
            else:
                self._log(f"Snapshot save failed: {response}", "ERROR")
                return False

        except Exception as e:
            self._log(f"Failed to save snapshot: {e}", "ERROR")
            return False

    def cleanup(self):
        """Clean up temporary files."""
        if self.temp_dir.exists():
            shutil.rmtree(self.temp_dir)


def main():
    parser = argparse.ArgumentParser(
        description="Android Emulator Setup for Penetration Testing",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("-v", "--verbose", action="store_true",
                       help="Verbose output")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Create command
    create_parser = subparsers.add_parser("create", help="Create new AVD")
    create_parser.add_argument("--name", required=True, help="AVD name")
    create_parser.add_argument("--api", type=int, default=30,
                              help="Android API level (default: 30)")
    create_parser.add_argument("--arch", default="x86_64",
                              choices=["x86_64", "x86", "arm64-v8a"],
                              help="Architecture")
    create_parser.add_argument("--device", default="pixel_4",
                              help="Device profile")
    create_parser.add_argument("--ram", type=int, default=4096,
                              help="RAM in MB")
    create_parser.add_argument("--play-store", action="store_true",
                              help="Include Play Store")

    # Start command
    start_parser = subparsers.add_parser("start", help="Start emulator")
    start_parser.add_argument("--name", required=True, help="AVD name")
    start_parser.add_argument("--writable", action="store_true",
                             help="Start with writable system")
    start_parser.add_argument("--no-snapshot", action="store_true",
                             help="Cold boot without snapshot")
    start_parser.add_argument("--proxy", help="HTTP proxy (host:port)")
    start_parser.add_argument("--gpu", default="auto",
                             choices=["auto", "host", "swiftshader_indirect", "off"],
                             help="GPU mode")

    # Configure command
    config_parser = subparsers.add_parser("configure", help="Configure emulator")
    config_parser.add_argument("--serial", help="Emulator serial")
    config_parser.add_argument("--proxy", help="Set proxy (host:port)")
    config_parser.add_argument("--cert", help="Install CA certificate")
    config_parser.add_argument("--frida", action="store_true",
                              help="Install Frida server")
    config_parser.add_argument("--frida-version", default="latest",
                              help="Frida version")

    # Root command
    root_parser = subparsers.add_parser("root", help="Root emulator")
    root_parser.add_argument("--serial", help="Emulator serial")
    root_parser.add_argument("--method", default="system",
                            choices=["system", "magisk"],
                            help="Rooting method")

    # Snapshot command
    snap_parser = subparsers.add_parser("snapshot", help="Manage snapshots")
    snap_parser.add_argument("--name", required=True, help="AVD name")
    snap_parser.add_argument("--save", help="Save snapshot with name")

    # List command
    list_parser = subparsers.add_parser("list", help="List available images")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    setup = EmulatorSetup(verbose=args.verbose)

    try:
        if args.command == "create":
            config = EmulatorConfig(
                name=args.name,
                api_level=args.api,
                arch=args.arch,
                device=args.device,
                ram=args.ram,
                play_store=args.play_store,
            )
            success = setup.create_avd(config)

        elif args.command == "start":
            serial = setup.start_emulator(
                args.name,
                writable=args.writable,
                no_snapshot=args.no_snapshot,
                proxy=args.proxy,
                gpu=args.gpu
            )
            success = serial is not None

        elif args.command == "configure":
            serial = args.serial
            if not serial:
                # Find first emulator
                result = setup._adb_cmd("devices")
                for line in result.stdout.split("\n"):
                    if "emulator-" in line and "device" in line:
                        serial = line.split()[0]
                        break

            if not serial:
                print("No emulator found. Start one first.")
                return 1

            success = True
            if args.proxy:
                host, port = args.proxy.split(":")
                success &= setup.configure_proxy(serial, host, int(port))
            if args.cert:
                success &= setup.install_ca_cert(serial, args.cert)
            if args.frida:
                success &= setup.install_frida_server(serial, args.frida_version)
                success &= setup.start_frida_server(serial)

        elif args.command == "root":
            serial = args.serial
            if not serial:
                result = setup._adb_cmd("devices")
                for line in result.stdout.split("\n"):
                    if "emulator-" in line and "device" in line:
                        serial = line.split()[0]
                        break

            if not serial:
                print("No emulator found")
                return 1

            success = setup.root_emulator(serial, args.method)

        elif args.command == "snapshot":
            if args.save:
                success = setup.save_snapshot(args.name, args.save)
            else:
                print("Specify --save to save a snapshot")
                success = False

        elif args.command == "list":
            packages = setup.list_available_packages()
            print("\nAvailable System Images:")
            for img in packages["system_images"][:20]:
                print(f"  {img}")
            success = True

        else:
            parser.print_help()
            success = False

        return 0 if success else 1

    finally:
        setup.cleanup()


if __name__ == "__main__":
    sys.exit(main())
