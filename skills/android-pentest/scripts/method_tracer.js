/**
 * Method Tracer for Android Applications
 *
 * Traces method calls with arguments and return values.
 * Configure the classes and methods to trace below.
 *
 * Usage: frida -U -f <package> -l method_tracer.js --no-pause
 */

Java.perform(function() {
    console.log("[*] Method Tracer loaded");

    // =================== CONFIGURATION ===================
    // Add classes to trace here
    var classesToTrace = [
        // Example: "com.example.app.AuthManager",
        // Example: "com.example.app.NetworkClient"
    ];

    // Add specific methods to trace (class.method format)
    var methodsToTrace = [
        // Example: "com.example.app.AuthManager.login",
        // Example: "com.example.app.Utils.encrypt"
    ];

    // Trace all methods matching these patterns (regex)
    var methodPatterns = [
        // /login/i,
        // /auth/i,
        // /password/i,
        // /encrypt/i,
        // /decrypt/i,
        // /token/i,
        // /secret/i
    ];
    // =====================================================

    var Color = {
        Reset: "\x1b[0m",
        Red: "\x1b[31m",
        Green: "\x1b[32m",
        Yellow: "\x1b[33m",
        Blue: "\x1b[34m",
        Magenta: "\x1b[35m",
        Cyan: "\x1b[36m"
    };

    function formatArg(arg) {
        if (arg === null) return "null";
        if (arg === undefined) return "undefined";

        try {
            // Handle byte arrays specially
            if (arg.getClass && arg.getClass().getName() === "[B") {
                var bytes = Java.array('byte', arg);
                var hex = "";
                var str = "";
                for (var i = 0; i < Math.min(bytes.length, 64); i++) {
                    var b = (bytes[i] & 0xFF).toString(16);
                    hex += (b.length === 1 ? "0" : "") + b;
                    var c = bytes[i] & 0xFF;
                    str += (c >= 32 && c < 127) ? String.fromCharCode(c) : ".";
                }
                if (bytes.length > 64) {
                    hex += "...";
                    str += "...";
                }
                return "[bytes(" + bytes.length + "): " + hex + " | \"" + str + "\"]";
            }

            // Handle string arrays
            if (arg.getClass && arg.getClass().getName() === "[Ljava.lang.String;") {
                return "[" + Java.array('java.lang.String', arg).join(", ") + "]";
            }

            // Try toString
            return arg.toString();
        } catch (e) {
            return "<error: " + e + ">";
        }
    }

    function traceMethod(className, methodName) {
        try {
            var targetClass = Java.use(className);
            var overloads = targetClass[methodName].overloads;

            if (overloads.length === 0) {
                console.log("[-] No overloads found for: " + className + "." + methodName);
                return;
            }

            overloads.forEach(function(overload) {
                overload.implementation = function() {
                    var args = [];
                    for (var i = 0; i < arguments.length; i++) {
                        args.push(formatArg(arguments[i]));
                    }

                    console.log("\n" + Color.Cyan + "[TRACE] " + Color.Reset + className + "." + Color.Green + methodName + Color.Reset);
                    console.log(Color.Yellow + "  Args: " + Color.Reset + args.join(", "));

                    var retval;
                    try {
                        retval = this[methodName].apply(this, arguments);
                        console.log(Color.Magenta + "  Return: " + Color.Reset + formatArg(retval));
                    } catch (e) {
                        console.log(Color.Red + "  Exception: " + Color.Reset + e);
                        throw e;
                    }

                    return retval;
                };
            });

            console.log("[+] Tracing: " + className + "." + methodName + " (" + overloads.length + " overloads)");
        } catch (e) {
            console.log("[-] Failed to trace " + className + "." + methodName + ": " + e);
        }
    }

    function traceClass(className) {
        try {
            var targetClass = Java.use(className);
            var methods = targetClass.class.getDeclaredMethods();

            methods.forEach(function(method) {
                var methodName = method.getName();
                traceMethod(className, methodName);
            });

            console.log("[+] Tracing all methods in: " + className);
        } catch (e) {
            console.log("[-] Failed to trace class " + className + ": " + e);
        }
    }

    function traceByPattern(patterns) {
        if (patterns.length === 0) return;

        console.log("[*] Searching for methods matching patterns...");

        Java.enumerateLoadedClasses({
            onMatch: function(className) {
                // Skip system classes for performance
                if (className.startsWith("java.") ||
                    className.startsWith("android.") ||
                    className.startsWith("androidx.") ||
                    className.startsWith("dalvik.") ||
                    className.startsWith("libcore.") ||
                    className.startsWith("sun.") ||
                    className.startsWith("org.apache.") ||
                    className.startsWith("org.json.") ||
                    className.startsWith("org.xml.") ||
                    className.startsWith("com.android.") ||
                    className.startsWith("com.google.android.")) {
                    return;
                }

                try {
                    var targetClass = Java.use(className);
                    var methods = targetClass.class.getDeclaredMethods();

                    methods.forEach(function(method) {
                        var methodName = method.getName();
                        var fullName = className + "." + methodName;

                        for (var i = 0; i < patterns.length; i++) {
                            if (patterns[i].test(fullName) || patterns[i].test(methodName)) {
                                traceMethod(className, methodName);
                                break;
                            }
                        }
                    });
                } catch (e) {
                    // Ignore classes that can't be loaded
                }
            },
            onComplete: function() {
                console.log("[*] Pattern search complete");
            }
        });
    }

    // Execute tracing based on configuration
    console.log("\n[*] Setting up traces...\n");

    // Trace specific classes
    classesToTrace.forEach(function(className) {
        traceClass(className);
    });

    // Trace specific methods
    methodsToTrace.forEach(function(fullMethod) {
        var parts = fullMethod.split(".");
        var methodName = parts.pop();
        var className = parts.join(".");
        traceMethod(className, methodName);
    });

    // Trace by patterns
    traceByPattern(methodPatterns);

    console.log("\n[*] Method Tracer ready - configure classes/methods at top of script");
    console.log("[*] Example: Add 'com.example.app.AuthManager' to classesToTrace array");
});


// =================== HELPER FUNCTIONS ===================

// Call this from Frida REPL to trace a class at runtime
function trace(className) {
    Java.perform(function() {
        try {
            var targetClass = Java.use(className);
            var methods = targetClass.class.getDeclaredMethods();

            methods.forEach(function(method) {
                var methodName = method.getName();
                var overloads = targetClass[methodName].overloads;

                overloads.forEach(function(overload) {
                    overload.implementation = function() {
                        console.log("\n[TRACE] " + className + "." + methodName);
                        console.log("  Args: " + Array.from(arguments).map(a => a ? a.toString() : "null").join(", "));

                        var retval = this[methodName].apply(this, arguments);
                        console.log("  Return: " + (retval ? retval.toString() : "null"));

                        return retval;
                    };
                });
            });

            console.log("[+] Now tracing: " + className);
        } catch (e) {
            console.log("[-] Failed: " + e);
        }
    });
}

// Call to list methods of a class
function listMethods(className) {
    Java.perform(function() {
        try {
            var targetClass = Java.use(className);
            var methods = targetClass.class.getDeclaredMethods();

            console.log("\n[*] Methods in " + className + ":\n");
            methods.forEach(function(method) {
                console.log("  " + method.toString());
            });
        } catch (e) {
            console.log("[-] Failed: " + e);
        }
    });
}

// Export helper functions
rpc.exports = {
    trace: trace,
    listMethods: listMethods
};
