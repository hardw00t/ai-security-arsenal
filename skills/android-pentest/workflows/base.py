#!/usr/bin/env python3
"""
Base utilities for Android pentesting workflows.
Provides common functionality for MCP tool integration, checkpointing, and reporting.
"""

import json
import os
import sys
import time
import subprocess
import hashlib
from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Optional


class Severity(Enum):
    """Finding severity levels aligned with CVSS."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class FindingCategory(Enum):
    """OWASP MASVS categories."""
    STORAGE = "MASVS-STORAGE"
    CRYPTO = "MASVS-CRYPTO"
    AUTH = "MASVS-AUTH"
    NETWORK = "MASVS-NETWORK"
    PLATFORM = "MASVS-PLATFORM"
    CODE = "MASVS-CODE"
    RESILIENCE = "MASVS-RESILIENCE"
    PRIVACY = "MASVS-PRIVACY"


@dataclass
class Finding:
    """Represents a security finding."""
    id: str
    title: str
    severity: Severity
    category: FindingCategory
    description: str
    evidence: list[str] = field(default_factory=list)
    affected_component: str = ""
    remediation: str = ""
    references: list[str] = field(default_factory=list)
    mastg_id: str = ""
    cvss_score: float = 0.0
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        data = asdict(self)
        data['severity'] = self.severity.value
        data['category'] = self.category.value
        return data


@dataclass
class Checkpoint:
    """Workflow checkpoint for resume capability."""
    workflow_name: str
    package_name: str
    current_step: str
    completed_steps: list[str] = field(default_factory=list)
    findings: list[dict] = field(default_factory=list)
    state: dict = field(default_factory=dict)
    started_at: str = field(default_factory=lambda: datetime.now().isoformat())
    updated_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def save(self, path: Path) -> None:
        """Save checkpoint to file."""
        self.updated_at = datetime.now().isoformat()
        with open(path, 'w') as f:
            json.dump(asdict(self), f, indent=2)

    @classmethod
    def load(cls, path: Path) -> 'Checkpoint':
        """Load checkpoint from file."""
        with open(path) as f:
            data = json.load(f)
        return cls(**data)


class MCPClient:
    """Client for interacting with Android Dynamic MCP server."""

    def __init__(self, server_url: str = "http://localhost:8000"):
        self.server_url = server_url
        self.connected = False
        self.device_id: Optional[str] = None

    def call_tool(self, tool_name: str, **kwargs) -> dict:
        """
        Call an MCP tool and return the result.

        In production, this would use the MCP protocol.
        For now, we use subprocess to call the MCP server CLI.
        """
        try:
            # Build command for MCP tool invocation
            cmd = ["python", "-m", "android_mcp", "call", tool_name]
            for key, value in kwargs.items():
                if value is not None:
                    cmd.extend([f"--{key}", str(value)])

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                try:
                    return json.loads(result.stdout)
                except json.JSONDecodeError:
                    return {"output": result.stdout, "success": True}
            else:
                return {"error": result.stderr, "success": False}

        except subprocess.TimeoutExpired:
            return {"error": "Tool execution timed out", "success": False}
        except FileNotFoundError:
            # Fallback to direct ADB/Frida commands
            return self._fallback_execution(tool_name, kwargs)

    def _fallback_execution(self, tool_name: str, params: dict) -> dict:
        """Fallback to direct command execution if MCP server unavailable."""
        fallback_commands = {
            "list_devices": "adb devices -l",
            "get_packages": "adb shell pm list packages",
            "get_app_info": f"adb shell dumpsys package {params.get('package', '')}",
            "shell_command": f"adb shell {params.get('command', '')}",
        }

        if tool_name in fallback_commands:
            try:
                result = subprocess.run(
                    fallback_commands[tool_name],
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                return {"output": result.stdout, "error": result.stderr, "success": result.returncode == 0}
            except Exception as e:
                return {"error": str(e), "success": False}

        return {"error": f"No fallback for tool: {tool_name}", "success": False}

    # Convenience methods for common operations
    def list_devices(self) -> list[dict]:
        """List connected Android devices."""
        result = self.call_tool("list_devices")
        if result.get("success"):
            return result.get("devices", [])
        return []

    def get_packages(self, filter_str: str = "") -> list[str]:
        """Get installed packages, optionally filtered."""
        result = self.call_tool("get_packages", filter=filter_str)
        if result.get("success"):
            return result.get("packages", [])
        return []

    def get_app_info(self, package: str) -> dict:
        """Get detailed app information."""
        return self.call_tool("get_app_info", package=package)

    def pull_apk(self, package: str, output_path: str) -> bool:
        """Pull APK from device."""
        result = self.call_tool("pull_apk", package=package, output=output_path)
        return result.get("success", False)

    def shell(self, command: str, as_root: bool = False) -> dict:
        """Execute shell command on device."""
        return self.call_tool("shell_command", command=command, root=as_root)

    def start_frida(self, package: str, script: str, spawn: bool = True) -> dict:
        """Start Frida with a script."""
        return self.call_tool("frida_script", package=package, script=script, spawn=spawn)

    def hook_method(self, package: str, class_name: str, method: str,
                    on_enter: str = "", on_leave: str = "") -> dict:
        """Hook a specific method."""
        return self.call_tool(
            "hook_method",
            package=package,
            class_name=class_name,
            method=method,
            on_enter=on_enter,
            on_leave=on_leave
        )

    def dump_prefs(self, package: str) -> dict:
        """Dump SharedPreferences."""
        return self.call_tool("dump_shared_prefs", package=package)

    def dump_databases(self, package: str) -> dict:
        """Dump SQLite databases."""
        return self.call_tool("dump_databases", package=package)

    def get_logcat(self, package: str = "", lines: int = 1000) -> dict:
        """Get logcat output."""
        return self.call_tool("get_logcat", package=package, lines=lines)

    def test_exported_components(self, package: str) -> dict:
        """Get exported components."""
        return self.call_tool("get_exported_components", package=package)

    def send_intent(self, action: str = "", component: str = "",
                   data: str = "", extras: dict = None) -> dict:
        """Send an intent."""
        return self.call_tool(
            "send_intent",
            action=action,
            component=component,
            data=data,
            extras=json.dumps(extras) if extras else None
        )

    def query_provider(self, uri: str, projection: str = "",
                      selection: str = "") -> dict:
        """Query a content provider."""
        return self.call_tool(
            "query_content_provider",
            uri=uri,
            projection=projection,
            selection=selection
        )


class ProgressReporter:
    """Reports workflow progress to console and optionally to file."""

    def __init__(self, workflow_name: str, total_steps: int,
                 output_file: Optional[Path] = None, verbose: bool = True):
        self.workflow_name = workflow_name
        self.total_steps = total_steps
        self.current_step = 0
        self.output_file = output_file
        self.verbose = verbose
        self.start_time = time.time()
        self.step_times: list[float] = []

    def start(self) -> None:
        """Start the progress reporter."""
        self._log(f"\n{'='*60}")
        self._log(f"Starting: {self.workflow_name}")
        self._log(f"Total steps: {self.total_steps}")
        self._log(f"{'='*60}\n")

    def step(self, name: str, status: str = "running") -> None:
        """Report a step."""
        self.current_step += 1
        progress = (self.current_step / self.total_steps) * 100
        elapsed = time.time() - self.start_time

        if status == "running":
            symbol = "ðŸ”„"
        elif status == "done":
            symbol = "âœ…"
        elif status == "failed":
            symbol = "âŒ"
        elif status == "skipped":
            symbol = "â­ï¸"
        else:
            symbol = "â€¢"

        msg = f"[{self.current_step}/{self.total_steps}] {symbol} {name} ({progress:.1f}%)"
        self._log(msg)

        if self.output_file:
            self._write_progress(name, status, progress)

    def finding(self, finding: Finding) -> None:
        """Report a finding."""
        severity_colors = {
            Severity.CRITICAL: "ðŸ”´",
            Severity.HIGH: "ðŸŸ ",
            Severity.MEDIUM: "ðŸŸ¡",
            Severity.LOW: "ðŸ”µ",
            Severity.INFO: "âšª"
        }
        symbol = severity_colors.get(finding.severity, "â€¢")
        self._log(f"  {symbol} FINDING: [{finding.severity.value.upper()}] {finding.title}")

    def error(self, message: str) -> None:
        """Report an error."""
        self._log(f"  âŒ ERROR: {message}")

    def warning(self, message: str) -> None:
        """Report a warning."""
        self._log(f"  âš ï¸  WARNING: {message}")

    def info(self, message: str) -> None:
        """Report info."""
        if self.verbose:
            self._log(f"  â„¹ï¸  {message}")

    def complete(self, findings_count: int) -> None:
        """Report completion."""
        elapsed = time.time() - self.start_time
        self._log(f"\n{'='*60}")
        self._log(f"Completed: {self.workflow_name}")
        self._log(f"Duration: {elapsed:.1f}s")
        self._log(f"Findings: {findings_count}")
        self._log(f"{'='*60}\n")

    def _log(self, message: str) -> None:
        """Log message to console."""
        print(message)

    def _write_progress(self, step: str, status: str, progress: float) -> None:
        """Write progress to file."""
        if self.output_file:
            with open(self.output_file, 'a') as f:
                f.write(json.dumps({
                    "timestamp": datetime.now().isoformat(),
                    "workflow": self.workflow_name,
                    "step": step,
                    "status": status,
                    "progress": progress
                }) + "\n")


class BaseWorkflow(ABC):
    """Base class for all pentesting workflows."""

    def __init__(self, package: str, output_dir: Path,
                 apk_path: Optional[Path] = None,
                 resume: bool = False, verbose: bool = True):
        self.package = package
        self.output_dir = Path(output_dir)
        self.apk_path = Path(apk_path) if apk_path else None
        self.resume = resume
        self.verbose = verbose

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Initialize MCP client
        self.mcp = MCPClient()

        # Initialize findings list
        self.findings: list[Finding] = []

        # Checkpoint management
        self.checkpoint_path = self.output_dir / f"{self.name}_checkpoint.json"
        self.checkpoint: Optional[Checkpoint] = None

        # Progress reporter (initialized in run())
        self.progress: Optional[ProgressReporter] = None

    @property
    @abstractmethod
    def name(self) -> str:
        """Workflow name."""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Workflow description."""
        pass

    @property
    @abstractmethod
    def steps(self) -> list[tuple[str, Callable]]:
        """List of (step_name, step_function) tuples."""
        pass

    def add_finding(self, finding: Finding) -> None:
        """Add a finding and report it."""
        self.findings.append(finding)
        if self.progress:
            self.progress.finding(finding)
        self._save_checkpoint()

    def _save_checkpoint(self) -> None:
        """Save current state to checkpoint."""
        if self.checkpoint:
            self.checkpoint.findings = [f.to_dict() for f in self.findings]
            self.checkpoint.save(self.checkpoint_path)

    def _load_checkpoint(self) -> bool:
        """Load checkpoint if exists and resume is enabled."""
        if self.resume and self.checkpoint_path.exists():
            try:
                self.checkpoint = Checkpoint.load(self.checkpoint_path)
                # Restore findings
                for f_dict in self.checkpoint.findings:
                    f_dict['severity'] = Severity(f_dict['severity'])
                    f_dict['category'] = FindingCategory(f_dict['category'])
                    self.findings.append(Finding(**f_dict))
                return True
            except Exception as e:
                print(f"Warning: Could not load checkpoint: {e}")

        # Create new checkpoint
        self.checkpoint = Checkpoint(
            workflow_name=self.name,
            package_name=self.package,
            current_step=""
        )
        return False

    def _should_skip_step(self, step_name: str) -> bool:
        """Check if step should be skipped (already completed)."""
        if self.checkpoint and step_name in self.checkpoint.completed_steps:
            return True
        return False

    def _mark_step_complete(self, step_name: str) -> None:
        """Mark a step as completed."""
        if self.checkpoint:
            self.checkpoint.completed_steps.append(step_name)
            self.checkpoint.current_step = step_name
            self._save_checkpoint()

    def run(self) -> list[Finding]:
        """Execute the workflow."""
        # Load checkpoint if resuming
        resumed = self._load_checkpoint()

        # Initialize progress reporter
        self.progress = ProgressReporter(
            self.name,
            len(self.steps),
            self.output_dir / f"{self.name}_progress.log",
            self.verbose
        )

        self.progress.start()

        if resumed:
            self.progress.info(f"Resumed from checkpoint. {len(self.checkpoint.completed_steps)} steps already complete.")

        # Execute steps
        for step_name, step_func in self.steps:
            if self._should_skip_step(step_name):
                self.progress.step(step_name, "skipped")
                continue

            self.progress.step(step_name, "running")

            try:
                step_func()
                self._mark_step_complete(step_name)
                self.progress.step(step_name, "done")
            except Exception as e:
                self.progress.error(f"Step '{step_name}' failed: {e}")
                self.progress.step(step_name, "failed")
                # Continue to next step

        self.progress.complete(len(self.findings))

        # Generate report
        self._generate_report()

        return self.findings

    def _generate_report(self) -> None:
        """Generate JSON report of findings."""
        report = {
            "workflow": self.name,
            "package": self.package,
            "timestamp": datetime.now().isoformat(),
            "summary": {
                "total_findings": len(self.findings),
                "critical": len([f for f in self.findings if f.severity == Severity.CRITICAL]),
                "high": len([f for f in self.findings if f.severity == Severity.HIGH]),
                "medium": len([f for f in self.findings if f.severity == Severity.MEDIUM]),
                "low": len([f for f in self.findings if f.severity == Severity.LOW]),
                "info": len([f for f in self.findings if f.severity == Severity.INFO])
            },
            "findings": [f.to_dict() for f in self.findings]
        }

        report_path = self.output_dir / f"{self.name}_findings.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        if self.progress:
            self.progress.info(f"Report saved to: {report_path}")


def generate_finding_id(category: str, title: str) -> str:
    """Generate a unique finding ID."""
    content = f"{category}-{title}-{datetime.now().isoformat()}"
    return hashlib.md5(content.encode()).hexdigest()[:8].upper()


def load_payloads(payload_file: str) -> list[str]:
    """Load payloads from a file in the payloads directory."""
    skill_dir = Path(__file__).parent.parent
    payload_path = skill_dir / "payloads" / payload_file

    if not payload_path.exists():
        return []

    payloads = []
    with open(payload_path) as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#'):
                payloads.append(line)

    return payloads


def parse_common_args():
    """Parse common command line arguments."""
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('--package', '-p', required=True, help='Target package name')
    parser.add_argument('--apk', '-a', help='Path to APK file')
    parser.add_argument('--output', '-o', default='./results', help='Output directory')
    parser.add_argument('--resume', '-r', action='store_true', help='Resume from checkpoint')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--device', '-d', help='Target device ID')

    return parser


if __name__ == "__main__":
    # Test the base utilities
    print("Base utilities loaded successfully")

    # Test MCP client
    client = MCPClient()
    devices = client.list_devices()
    print(f"Found devices: {devices}")
