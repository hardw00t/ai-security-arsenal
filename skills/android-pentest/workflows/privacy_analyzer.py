#!/usr/bin/env python3
"""
Privacy Analyzer
Analyze app privacy practices, permissions, tracking SDKs, and data collection.

Usage:
    python privacy_analyzer.py --package com.target.app
    python privacy_analyzer.py -p com.target.app --monitor-duration 60
"""

import argparse
import json
import re
import time
from pathlib import Path
from typing import Callable

from base import (
    BaseWorkflow, Finding, Severity, FindingCategory,
    generate_finding_id, parse_common_args
)


class PrivacyAnalyzer(BaseWorkflow):
    """Automated privacy analyzer."""

    @property
    def name(self) -> str:
        return "privacy_analyzer"

    @property
    def description(self) -> str:
        return "Analyze app privacy practices and data collection"

    @property
    def steps(self) -> list[tuple[str, Callable]]:
        return [
            ("Initialize Analyzer", self.step_initialize),
            ("Analyze Permissions", self.step_analyze_permissions),
            ("Detect Tracking SDKs", self.step_detect_trackers),
            ("Monitor Data Collection", self.step_monitor_data_collection),
            ("Check Device Fingerprinting", self.step_check_fingerprinting),
            ("Analyze Third-Party Data Sharing", self.step_analyze_data_sharing),
            ("Check Location Tracking", self.step_check_location),
            ("Analyze Advertising IDs", self.step_analyze_ad_ids),
            ("Generate Privacy Report", self.step_generate_report),
        ]

    def __init__(self, *args, monitor_duration: int = 30, **kwargs):
        super().__init__(*args, **kwargs)
        self.monitor_duration = monitor_duration
        self.permissions_requested: list[str] = []
        self.permissions_used: list[str] = []
        self.trackers_detected: list[dict] = []
        self.data_collected: list[dict] = []
        self.third_party_endpoints: list[str] = []

    # Known tracking SDK packages
    TRACKING_SDKS = {
        'com.google.firebase.analytics': {'name': 'Firebase Analytics', 'type': 'analytics'},
        'com.google.android.gms.analytics': {'name': 'Google Analytics', 'type': 'analytics'},
        'com.facebook.appevents': {'name': 'Facebook Analytics', 'type': 'analytics'},
        'com.facebook.ads': {'name': 'Facebook Ads', 'type': 'advertising'},
        'com.appsflyer': {'name': 'AppsFlyer', 'type': 'attribution'},
        'com.adjust.sdk': {'name': 'Adjust', 'type': 'attribution'},
        'io.branch': {'name': 'Branch', 'type': 'attribution'},
        'com.mixpanel': {'name': 'Mixpanel', 'type': 'analytics'},
        'com.amplitude': {'name': 'Amplitude', 'type': 'analytics'},
        'com.segment': {'name': 'Segment', 'type': 'analytics'},
        'com.crashlytics': {'name': 'Crashlytics', 'type': 'crash_reporting'},
        'io.sentry': {'name': 'Sentry', 'type': 'crash_reporting'},
        'com.newrelic': {'name': 'New Relic', 'type': 'performance'},
        'com.google.android.gms.ads': {'name': 'Google Mobile Ads', 'type': 'advertising'},
        'com.unity3d.ads': {'name': 'Unity Ads', 'type': 'advertising'},
        'com.applovin': {'name': 'AppLovin', 'type': 'advertising'},
        'com.mopub': {'name': 'MoPub', 'type': 'advertising'},
        'com.chartboost': {'name': 'Chartboost', 'type': 'advertising'},
        'com.ironsource': {'name': 'ironSource', 'type': 'advertising'},
        'com.flurry': {'name': 'Flurry', 'type': 'analytics'},
        'com.localytics': {'name': 'Localytics', 'type': 'analytics'},
        'com.clevertap': {'name': 'CleverTap', 'type': 'engagement'},
        'com.braze': {'name': 'Braze', 'type': 'engagement'},
        'com.onesignal': {'name': 'OneSignal', 'type': 'push'},
        'com.urbanairship': {'name': 'Airship', 'type': 'push'},
    }

    # Dangerous permissions
    DANGEROUS_PERMISSIONS = {
        'READ_CONTACTS': {'category': 'contacts', 'risk': 'high'},
        'WRITE_CONTACTS': {'category': 'contacts', 'risk': 'high'},
        'READ_CALENDAR': {'category': 'calendar', 'risk': 'medium'},
        'WRITE_CALENDAR': {'category': 'calendar', 'risk': 'medium'},
        'READ_CALL_LOG': {'category': 'phone', 'risk': 'high'},
        'WRITE_CALL_LOG': {'category': 'phone', 'risk': 'high'},
        'READ_PHONE_STATE': {'category': 'phone', 'risk': 'medium'},
        'READ_PHONE_NUMBERS': {'category': 'phone', 'risk': 'medium'},
        'CALL_PHONE': {'category': 'phone', 'risk': 'medium'},
        'READ_SMS': {'category': 'sms', 'risk': 'critical'},
        'SEND_SMS': {'category': 'sms', 'risk': 'critical'},
        'RECEIVE_SMS': {'category': 'sms', 'risk': 'critical'},
        'RECORD_AUDIO': {'category': 'microphone', 'risk': 'high'},
        'CAMERA': {'category': 'camera', 'risk': 'high'},
        'ACCESS_FINE_LOCATION': {'category': 'location', 'risk': 'high'},
        'ACCESS_COARSE_LOCATION': {'category': 'location', 'risk': 'medium'},
        'ACCESS_BACKGROUND_LOCATION': {'category': 'location', 'risk': 'critical'},
        'READ_EXTERNAL_STORAGE': {'category': 'storage', 'risk': 'medium'},
        'WRITE_EXTERNAL_STORAGE': {'category': 'storage', 'risk': 'medium'},
        'READ_MEDIA_IMAGES': {'category': 'media', 'risk': 'medium'},
        'READ_MEDIA_VIDEO': {'category': 'media', 'risk': 'medium'},
        'READ_MEDIA_AUDIO': {'category': 'media', 'risk': 'medium'},
        'ACTIVITY_RECOGNITION': {'category': 'sensors', 'risk': 'medium'},
        'BODY_SENSORS': {'category': 'sensors', 'risk': 'high'},
        'GET_ACCOUNTS': {'category': 'accounts', 'risk': 'medium'},
    }

    def step_initialize(self) -> None:
        """Initialize the privacy analyzer."""
        devices = self.mcp.list_devices()
        if not devices:
            raise RuntimeError("No Android device connected")

        self.progress.info(f"Target package: {self.package}")
        self.progress.info(f"Monitoring duration: {self.monitor_duration}s")

    def step_analyze_permissions(self) -> None:
        """Analyze requested and used permissions."""
        self.progress.info("Analyzing permissions...")

        app_info = self.mcp.get_app_info(self.package)

        if not app_info.get('success'):
            self.progress.warning("Could not get app info")
            return

        info = app_info.get('output', '')

        # Extract requested permissions
        perm_pattern = r'android\.permission\.([A-Z_]+)'
        self.permissions_requested = list(set(re.findall(perm_pattern, info)))

        # Categorize dangerous permissions
        dangerous_found = []
        for perm in self.permissions_requested:
            if perm in self.DANGEROUS_PERMISSIONS:
                dangerous_found.append({
                    'permission': perm,
                    **self.DANGEROUS_PERMISSIONS[perm]
                })

        if dangerous_found:
            # Group by risk level
            critical = [p for p in dangerous_found if p['risk'] == 'critical']
            high = [p for p in dangerous_found if p['risk'] == 'high']

            if critical:
                self.add_finding(Finding(
                    id=generate_finding_id("PRIVACY", "critical_permissions"),
                    title="Critical Privacy Permissions Requested",
                    severity=Severity.HIGH,
                    category=FindingCategory.PRIVACY,
                    description=f"Application requests critical privacy permissions: {[p['permission'] for p in critical]}",
                    evidence=[f"{p['permission']} ({p['category']})" for p in critical],
                    affected_component="AndroidManifest.xml",
                    remediation="Review if these permissions are necessary. Provide clear privacy disclosure.",
                    mastg_id="MASTG-TEST-0040"
                ))

            if high:
                self.add_finding(Finding(
                    id=generate_finding_id("PRIVACY", "high_risk_permissions"),
                    title="High-Risk Privacy Permissions Requested",
                    severity=Severity.MEDIUM,
                    category=FindingCategory.PRIVACY,
                    description=f"Application requests high-risk permissions affecting user privacy.",
                    evidence=[f"{p['permission']} ({p['category']})" for p in high],
                    affected_component="AndroidManifest.xml",
                    remediation="Minimize permissions. Request only when needed.",
                    mastg_id="MASTG-TEST-0040"
                ))

        # Store for report
        if self.checkpoint:
            self.checkpoint.state['permissions'] = self.permissions_requested
            self.checkpoint.state['dangerous_permissions'] = dangerous_found

    def step_detect_trackers(self) -> None:
        """Detect known tracking SDKs."""
        self.progress.info("Detecting tracking SDKs...")

        # Hook class loading to detect trackers
        tracker_script = """
        Java.perform(function() {
            var detectedTrackers = [];

            var trackerPackages = %s;

            // Check loaded classes
            Java.enumerateLoadedClasses({
                onMatch: function(className) {
                    for (var pkg in trackerPackages) {
                        if (className.indexOf(pkg) === 0) {
                            if (detectedTrackers.indexOf(pkg) === -1) {
                                detectedTrackers.push(pkg);
                                send({
                                    type: 'tracker_detected',
                                    package: pkg,
                                    class: className,
                                    info: trackerPackages[pkg]
                                });
                            }
                        }
                    }
                },
                onComplete: function() {
                    send({type: 'tracker_scan_complete', count: detectedTrackers.length});
                }
            });
        });
        """ % json.dumps({k: v['name'] for k, v in self.TRACKING_SDKS.items()})

        result = self.mcp.start_frida(self.package, tracker_script, spawn=True)

        # Also check app info for SDK references
        app_info = self.mcp.get_app_info(self.package)
        if app_info.get('success'):
            info = app_info.get('output', '')

            for pkg, sdk_info in self.TRACKING_SDKS.items():
                if pkg in info:
                    self.trackers_detected.append({
                        'package': pkg,
                        'name': sdk_info['name'],
                        'type': sdk_info['type']
                    })

        if self.trackers_detected:
            # Group by type
            analytics = [t for t in self.trackers_detected if t['type'] == 'analytics']
            advertising = [t for t in self.trackers_detected if t['type'] == 'advertising']
            attribution = [t for t in self.trackers_detected if t['type'] == 'attribution']

            self.add_finding(Finding(
                id=generate_finding_id("PRIVACY", "tracking_sdks"),
                title=f"Tracking SDKs Detected ({len(self.trackers_detected)})",
                severity=Severity.MEDIUM,
                category=FindingCategory.PRIVACY,
                description=f"Application includes {len(self.trackers_detected)} tracking SDK(s).",
                evidence=[f"{t['name']} ({t['type']})" for t in self.trackers_detected],
                affected_component="Third-party SDKs",
                remediation="Disclose tracking in privacy policy. Implement opt-out mechanisms.",
                mastg_id="MASTG-TEST-0041"
            ))

            if advertising:
                self.add_finding(Finding(
                    id=generate_finding_id("PRIVACY", "advertising_sdks"),
                    title=f"Advertising SDKs Detected ({len(advertising)})",
                    severity=Severity.LOW,
                    category=FindingCategory.PRIVACY,
                    description="Application includes advertising SDKs that may track user behavior.",
                    evidence=[f"{t['name']}" for t in advertising],
                    affected_component="Advertising SDKs",
                    remediation="Provide ad personalization opt-out. Respect user preferences.",
                    mastg_id="MASTG-TEST-0041"
                ))

    def step_monitor_data_collection(self) -> None:
        """Monitor what data the app collects."""
        self.progress.info("Monitoring data collection...")

        data_collection_script = """
        Java.perform(function() {
            var dataAccessed = [];

            // Monitor ContentResolver queries (contacts, calendar, etc.)
            try {
                var ContentResolver = Java.use('android.content.ContentResolver');
                ContentResolver.query.overload('android.net.Uri', '[Ljava.lang.String;', 'java.lang.String', '[Ljava.lang.String;', 'java.lang.String').implementation = function(uri, projection, selection, selectionArgs, sortOrder) {
                    var uriStr = uri.toString();
                    send({
                        type: 'content_query',
                        uri: uriStr,
                        projection: projection ? projection.toString() : null
                    });
                    return this.query(uri, projection, selection, selectionArgs, sortOrder);
                };
            } catch(e) {}

            // Monitor TelephonyManager (device info)
            try {
                var TelephonyManager = Java.use('android.telephony.TelephonyManager');

                TelephonyManager.getDeviceId.overload().implementation = function() {
                    send({type: 'data_access', category: 'device_id', method: 'getDeviceId'});
                    return this.getDeviceId();
                };

                TelephonyManager.getImei.overload().implementation = function() {
                    send({type: 'data_access', category: 'imei', method: 'getImei'});
                    return this.getImei();
                };

                TelephonyManager.getLine1Number.overload().implementation = function() {
                    send({type: 'data_access', category: 'phone_number', method: 'getLine1Number'});
                    return this.getLine1Number();
                };

                TelephonyManager.getSimSerialNumber.overload().implementation = function() {
                    send({type: 'data_access', category: 'sim_serial', method: 'getSimSerialNumber'});
                    return this.getSimSerialNumber();
                };
            } catch(e) {}

            // Monitor Settings.Secure (Android ID)
            try {
                var Settings = Java.use('android.provider.Settings$Secure');
                Settings.getString.implementation = function(resolver, name) {
                    if (name === 'android_id') {
                        send({type: 'data_access', category: 'android_id', method: 'Settings.Secure.getString'});
                    }
                    return this.getString(resolver, name);
                };
            } catch(e) {}

            // Monitor Build info access
            try {
                var Build = Java.use('android.os.Build');
                // Build fields are accessed statically, harder to hook directly
            } catch(e) {}

            // Monitor AccountManager
            try {
                var AccountManager = Java.use('android.accounts.AccountManager');
                AccountManager.getAccounts.implementation = function() {
                    send({type: 'data_access', category: 'accounts', method: 'getAccounts'});
                    return this.getAccounts();
                };
                AccountManager.getAccountsByType.implementation = function(type) {
                    send({type: 'data_access', category: 'accounts', method: 'getAccountsByType', account_type: type});
                    return this.getAccountsByType(type);
                };
            } catch(e) {}

            // Monitor PackageManager (installed apps)
            try {
                var PackageManager = Java.use('android.content.pm.PackageManager');
                PackageManager.getInstalledPackages.implementation = function(flags) {
                    send({type: 'data_access', category: 'installed_apps', method: 'getInstalledPackages'});
                    return this.getInstalledPackages(flags);
                };
                PackageManager.getInstalledApplications.implementation = function(flags) {
                    send({type: 'data_access', category: 'installed_apps', method: 'getInstalledApplications'});
                    return this.getInstalledApplications(flags);
                };
            } catch(e) {}

            send({type: 'data_monitoring_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, data_collection_script, spawn=True)

        if result.get('success'):
            self.add_finding(Finding(
                id=generate_finding_id("PRIVACY", "data_monitoring"),
                title="Data Collection Monitoring Active",
                severity=Severity.INFO,
                category=FindingCategory.PRIVACY,
                description="Monitoring data access patterns. Use the app to discover what data is collected.",
                evidence=["ContentResolver queries monitored", "Device identifiers monitored", "Account access monitored"],
                affected_component="Data Collection",
                remediation="Minimize data collection. Implement data minimization principles.",
                mastg_id="MASTG-TEST-0042"
            ))

        # Brief monitoring period
        time.sleep(min(self.monitor_duration, 10))

    def step_check_fingerprinting(self) -> None:
        """Check for device fingerprinting techniques."""
        self.progress.info("Checking for device fingerprinting...")

        fingerprint_script = """
        Java.perform(function() {
            var fingerprintData = [];

            // Canvas fingerprinting (WebView)
            try {
                var WebView = Java.use('android.webkit.WebView');
                // Would hook JavaScript interface for canvas
            } catch(e) {}

            // Hardware identifiers
            try {
                var Build = Java.use('android.os.Build');
                send({
                    type: 'build_info_available',
                    fields: ['SERIAL', 'FINGERPRINT', 'HARDWARE', 'MANUFACTURER', 'MODEL', 'PRODUCT', 'BOARD']
                });
            } catch(e) {}

            // Network interfaces (MAC address)
            try {
                var NetworkInterface = Java.use('java.net.NetworkInterface');
                NetworkInterface.getHardwareAddress.implementation = function() {
                    send({type: 'fingerprint_access', category: 'mac_address'});
                    return this.getHardwareAddress();
                };
            } catch(e) {}

            // Bluetooth address
            try {
                var BluetoothAdapter = Java.use('android.bluetooth.BluetoothAdapter');
                BluetoothAdapter.getAddress.implementation = function() {
                    send({type: 'fingerprint_access', category: 'bluetooth_address'});
                    return this.getAddress();
                };
            } catch(e) {}

            // Wi-Fi info
            try {
                var WifiInfo = Java.use('android.net.wifi.WifiInfo');
                WifiInfo.getMacAddress.implementation = function() {
                    send({type: 'fingerprint_access', category: 'wifi_mac'});
                    return this.getMacAddress();
                };
                WifiInfo.getBSSID.implementation = function() {
                    send({type: 'fingerprint_access', category: 'wifi_bssid'});
                    return this.getBSSID();
                };
            } catch(e) {}

            // Sensor data (for fingerprinting)
            try {
                var SensorManager = Java.use('android.hardware.SensorManager');
                SensorManager.getSensorList.implementation = function(type) {
                    send({type: 'fingerprint_access', category: 'sensors', sensor_type: type});
                    return this.getSensorList(type);
                };
            } catch(e) {}

            send({type: 'fingerprint_monitoring_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, fingerprint_script)

        self.add_finding(Finding(
            id=generate_finding_id("PRIVACY", "fingerprint_monitoring"),
            title="Device Fingerprinting Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.PRIVACY,
            description="Monitoring for device fingerprinting techniques.",
            evidence=["Hardware identifiers monitored", "Network addresses monitored", "Sensor access monitored"],
            affected_component="Device Fingerprinting",
            remediation="Avoid collecting unnecessary device identifiers.",
            mastg_id="MASTG-TEST-0043"
        ))

    def step_analyze_data_sharing(self) -> None:
        """Analyze third-party data sharing."""
        self.progress.info("Analyzing third-party data sharing...")

        # Known third-party analytics/tracking domains
        tracking_domains = [
            'google-analytics.com', 'googleanalytics.com', 'analytics.google.com',
            'facebook.com', 'fb.com', 'fbcdn.net',
            'appsflyer.com', 'app.appsflyer.com',
            'adjust.com', 'adjust.io',
            'branch.io', 'app.link',
            'mixpanel.com', 'api.mixpanel.com',
            'amplitude.com', 'api.amplitude.com',
            'segment.io', 'api.segment.io',
            'crashlytics.com', 'firebase.google.com',
            'sentry.io',
            'newrelic.com',
            'mopub.com', 'ads.mopub.com',
            'applovin.com',
            'unity3d.com', 'unityads.unity3d.com',
            'chartboost.com',
            'ironsrc.com', 'is.com',
            'flurry.com',
            'localytics.com',
            'clevertap.com',
            'braze.com',
            'onesignal.com',
            'urbanairship.com',
        ]

        # Hook network to detect data sharing
        data_sharing_script = """
        Java.perform(function() {
            var trackingDomains = %s;
            var sharedEndpoints = [];

            // Hook OkHttp
            try {
                var Request = Java.use('okhttp3.Request');
                var RequestBuilder = Java.use('okhttp3.Request$Builder');

                RequestBuilder.build.implementation = function() {
                    var request = this.build();
                    var url = request.url().toString();

                    for (var i = 0; i < trackingDomains.length; i++) {
                        if (url.indexOf(trackingDomains[i]) !== -1) {
                            send({
                                type: 'data_shared',
                                domain: trackingDomains[i],
                                url: url,
                                method: request.method()
                            });
                            break;
                        }
                    }
                    return request;
                };
            } catch(e) {}

            // Hook URLConnection
            try {
                var URL = Java.use('java.net.URL');
                URL.openConnection.overload().implementation = function() {
                    var urlStr = this.toString();

                    for (var i = 0; i < trackingDomains.length; i++) {
                        if (urlStr.indexOf(trackingDomains[i]) !== -1) {
                            send({
                                type: 'data_shared',
                                domain: trackingDomains[i],
                                url: urlStr
                            });
                            break;
                        }
                    }
                    return this.openConnection();
                };
            } catch(e) {}

            send({type: 'data_sharing_monitoring_ready'});
        });
        """ % json.dumps(tracking_domains)

        result = self.mcp.start_frida(self.package, data_sharing_script)

        self.add_finding(Finding(
            id=generate_finding_id("PRIVACY", "data_sharing_monitoring"),
            title="Third-Party Data Sharing Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.PRIVACY,
            description=f"Monitoring network traffic to {len(tracking_domains)} known tracking domains.",
            evidence=[f"Monitoring {len(tracking_domains)} tracking domains"],
            affected_component="Network Traffic",
            remediation="Disclose all third-party data sharing in privacy policy.",
            mastg_id="MASTG-TEST-0044"
        ))

    def step_check_location(self) -> None:
        """Check location tracking behavior."""
        self.progress.info("Checking location tracking...")

        location_script = """
        Java.perform(function() {
            // LocationManager
            try {
                var LocationManager = Java.use('android.location.LocationManager');

                LocationManager.requestLocationUpdates.overload('java.lang.String', 'long', 'float', 'android.location.LocationListener').implementation = function(provider, minTime, minDistance, listener) {
                    send({
                        type: 'location_request',
                        provider: provider,
                        min_time_ms: minTime,
                        min_distance_m: minDistance
                    });
                    return this.requestLocationUpdates(provider, minTime, minDistance, listener);
                };

                LocationManager.getLastKnownLocation.implementation = function(provider) {
                    send({type: 'location_access', method: 'getLastKnownLocation', provider: provider});
                    return this.getLastKnownLocation(provider);
                };
            } catch(e) {}

            // FusedLocationProviderClient (Google Play Services)
            try {
                var FusedLocationProviderClient = Java.use('com.google.android.gms.location.FusedLocationProviderClient');

                FusedLocationProviderClient.requestLocationUpdates.overload('com.google.android.gms.location.LocationRequest', 'com.google.android.gms.location.LocationCallback', 'android.os.Looper').implementation = function(request, callback, looper) {
                    send({
                        type: 'fused_location_request',
                        interval: request.getInterval(),
                        priority: request.getPriority()
                    });
                    return this.requestLocationUpdates(request, callback, looper);
                };

                FusedLocationProviderClient.getLastLocation.implementation = function() {
                    send({type: 'location_access', method: 'getLastLocation'});
                    return this.getLastLocation();
                };
            } catch(e) {}

            // Geofencing
            try {
                var GeofencingClient = Java.use('com.google.android.gms.location.GeofencingClient');
                GeofencingClient.addGeofences.implementation = function(request, pendingIntent) {
                    send({type: 'geofence_added'});
                    return this.addGeofences(request, pendingIntent);
                };
            } catch(e) {}

            send({type: 'location_monitoring_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, location_script)

        # Check if location permissions are requested
        if any('LOCATION' in p for p in self.permissions_requested):
            self.add_finding(Finding(
                id=generate_finding_id("PRIVACY", "location_tracking"),
                title="Location Tracking Capabilities",
                severity=Severity.MEDIUM,
                category=FindingCategory.PRIVACY,
                description="Application has location permissions. Monitoring location access patterns.",
                evidence=[p for p in self.permissions_requested if 'LOCATION' in p],
                affected_component="Location Services",
                remediation="Minimize location access. Use coarse location when possible.",
                mastg_id="MASTG-TEST-0045"
            ))

            if 'ACCESS_BACKGROUND_LOCATION' in self.permissions_requested:
                self.add_finding(Finding(
                    id=generate_finding_id("PRIVACY", "background_location"),
                    title="Background Location Access Requested",
                    severity=Severity.HIGH,
                    category=FindingCategory.PRIVACY,
                    description="Application requests background location access, enabling tracking even when not in use.",
                    evidence=["ACCESS_BACKGROUND_LOCATION permission"],
                    affected_component="Location Services",
                    remediation="Only request background location if essential. Provide clear disclosure.",
                    mastg_id="MASTG-TEST-0045"
                ))

    def step_analyze_ad_ids(self) -> None:
        """Analyze advertising ID usage."""
        self.progress.info("Analyzing advertising ID usage...")

        ad_id_script = """
        Java.perform(function() {
            // Google Advertising ID
            try {
                var AdvertisingIdClient = Java.use('com.google.android.gms.ads.identifier.AdvertisingIdClient');
                AdvertisingIdClient.getAdvertisingIdInfo.implementation = function(context) {
                    var info = this.getAdvertisingIdInfo(context);
                    send({
                        type: 'ad_id_access',
                        id: info.getId(),
                        limit_ad_tracking: info.isLimitAdTrackingEnabled()
                    });
                    return info;
                };
            } catch(e) {}

            // Info class
            try {
                var Info = Java.use('com.google.android.gms.ads.identifier.AdvertisingIdClient$Info');
                Info.getId.implementation = function() {
                    var id = this.getId();
                    send({type: 'ad_id_retrieved', id_preview: id.substring(0, 8) + '...'});
                    return id;
                };
            } catch(e) {}

            send({type: 'ad_id_monitoring_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, ad_id_script)

        self.add_finding(Finding(
            id=generate_finding_id("PRIVACY", "ad_id_monitoring"),
            title="Advertising ID Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.PRIVACY,
            description="Monitoring Advertising ID access and limit-ad-tracking preferences.",
            evidence=["AdvertisingIdClient hooked"],
            affected_component="Advertising",
            remediation="Respect limit-ad-tracking preference. Don't use GAID for non-advertising purposes.",
            mastg_id="MASTG-TEST-0046"
        ))

    def step_generate_report(self) -> None:
        """Generate privacy analysis report."""
        self.progress.info("Generating privacy report...")

        report = {
            "scan_type": "Privacy Analyzer",
            "package": self.package,
            "permissions": {
                "requested": self.permissions_requested,
                "dangerous": [p for p in self.permissions_requested if p in self.DANGEROUS_PERMISSIONS]
            },
            "trackers": {
                "count": len(self.trackers_detected),
                "list": self.trackers_detected,
                "by_type": {
                    "analytics": [t for t in self.trackers_detected if t.get('type') == 'analytics'],
                    "advertising": [t for t in self.trackers_detected if t.get('type') == 'advertising'],
                    "attribution": [t for t in self.trackers_detected if t.get('type') == 'attribution']
                }
            },
            "summary": {
                "total_findings": len(self.findings),
                "dangerous_permissions": len([p for p in self.permissions_requested if p in self.DANGEROUS_PERMISSIONS]),
                "trackers_detected": len(self.trackers_detected)
            },
            "recommendations": [
                "Minimize data collection to what is strictly necessary",
                "Implement user consent for tracking and data collection",
                "Respect user privacy preferences (limit-ad-tracking)",
                "Provide clear privacy policy disclosure",
                "Allow users to delete their data",
                "Use privacy-preserving alternatives where possible",
                "Avoid background location unless essential"
            ],
            "findings": [f.to_dict() for f in self.findings]
        }

        report_path = self.output_dir / f"{self.package}_privacy_report.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        self.progress.info(f"Report saved to: {report_path}")


def main():
    parser = parse_common_args()
    parser.add_argument('--monitor-duration', '-dur', type=int, default=30,
                       help='Duration to monitor data collection (seconds)')
    args = parser.parse_args()

    workflow = PrivacyAnalyzer(
        package=args.package,
        output_dir=Path(args.output),
        apk_path=Path(args.apk) if args.apk else None,
        resume=args.resume,
        verbose=args.verbose,
        monitor_duration=args.monitor_duration
    )

    findings = workflow.run()

    print(f"\n{'='*60}")
    print(f"Privacy Analysis Complete: {len(findings)} findings")
    print(f"{'='*60}")

    return 0


if __name__ == "__main__":
    exit(main())
