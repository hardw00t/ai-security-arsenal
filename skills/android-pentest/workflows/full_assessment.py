#!/usr/bin/env python3
"""
Full OWASP MASTG Assessment Workflow
Complete security assessment covering all MASVS categories.

Usage:
    python full_assessment.py --package com.target.app --apk ./app.apk
    python full_assessment.py -p com.target.app -o ./results --resume
"""

import argparse
import re
import json
from pathlib import Path
from typing import Callable

from base import (
    BaseWorkflow, Finding, Severity, FindingCategory,
    generate_finding_id, load_payloads, parse_common_args
)


class FullAssessmentWorkflow(BaseWorkflow):
    """Complete OWASP MASTG security assessment."""

    @property
    def name(self) -> str:
        return "full_assessment"

    @property
    def description(self) -> str:
        return "Complete OWASP MASTG security assessment covering all categories"

    @property
    def steps(self) -> list[tuple[str, Callable]]:
        return [
            ("Initialize Assessment", self.step_initialize),
            ("Gather App Information", self.step_gather_info),
            ("MASVS-STORAGE: Data Storage Tests", self.step_storage_tests),
            ("MASVS-CRYPTO: Cryptography Tests", self.step_crypto_tests),
            ("MASVS-AUTH: Authentication Tests", self.step_auth_tests),
            ("MASVS-NETWORK: Network Security Tests", self.step_network_tests),
            ("MASVS-PLATFORM: Platform Interaction Tests", self.step_platform_tests),
            ("MASVS-CODE: Code Quality Tests", self.step_code_tests),
            ("MASVS-RESILIENCE: Resilience Tests", self.step_resilience_tests),
            ("MASVS-PRIVACY: Privacy Tests", self.step_privacy_tests),
            ("Generate Final Report", self.step_generate_report),
        ]

    def step_initialize(self) -> None:
        """Initialize the assessment environment."""
        # Verify device connection
        devices = self.mcp.list_devices()
        if not devices:
            raise RuntimeError("No Android device connected")

        self.progress.info(f"Connected device: {devices[0]}")

        # Verify target app is installed
        packages = self.mcp.get_packages(self.package)
        if not packages:
            self.progress.warning(f"Package {self.package} not found on device")

        # Store state
        if self.checkpoint:
            self.checkpoint.state['devices'] = devices
            self.checkpoint.state['app_installed'] = bool(packages)

    def step_gather_info(self) -> None:
        """Gather application information."""
        app_info = self.mcp.get_app_info(self.package)

        if app_info.get('success'):
            info_text = app_info.get('output', '')

            # Parse key information
            debuggable = 'debuggable=true' in info_text.lower()
            allow_backup = 'allowbackup=true' in info_text.lower()

            # Extract target SDK
            sdk_match = re.search(r'targetSdkVersion=(\d+)', info_text)
            target_sdk = int(sdk_match.group(1)) if sdk_match else 0

            # Store in checkpoint
            if self.checkpoint:
                self.checkpoint.state['debuggable'] = debuggable
                self.checkpoint.state['allow_backup'] = allow_backup
                self.checkpoint.state['target_sdk'] = target_sdk

            # Create findings for misconfigurations
            if debuggable:
                self.add_finding(Finding(
                    id=generate_finding_id("CODE", "debuggable"),
                    title="Application is Debuggable",
                    severity=Severity.HIGH,
                    category=FindingCategory.CODE,
                    description="The application has android:debuggable=true set in the manifest. This allows attackers to attach debuggers and inspect application memory.",
                    evidence=["AndroidManifest.xml: android:debuggable=\"true\""],
                    affected_component="AndroidManifest.xml",
                    remediation="Set android:debuggable=\"false\" in release builds.",
                    mastg_id="MASTG-TEST-0029"
                ))

            if allow_backup:
                self.add_finding(Finding(
                    id=generate_finding_id("STORAGE", "backup"),
                    title="Application Allows Backup",
                    severity=Severity.MEDIUM,
                    category=FindingCategory.STORAGE,
                    description="The application allows backup via android:allowBackup=true. Sensitive data may be extracted through ADB backup.",
                    evidence=["AndroidManifest.xml: android:allowBackup=\"true\""],
                    affected_component="AndroidManifest.xml",
                    remediation="Set android:allowBackup=\"false\" or implement BackupAgent with encryption.",
                    mastg_id="MASTG-TEST-0001"
                ))

            if target_sdk < 30:
                self.add_finding(Finding(
                    id=generate_finding_id("CODE", "sdk"),
                    title="Outdated Target SDK",
                    severity=Severity.LOW,
                    category=FindingCategory.CODE,
                    description=f"Application targets SDK {target_sdk}. Modern security features require SDK 30+.",
                    evidence=[f"targetSdkVersion={target_sdk}"],
                    affected_component="build.gradle",
                    remediation="Update targetSdkVersion to latest stable version.",
                    mastg_id="MASTG-TEST-0030"
                ))

    def step_storage_tests(self) -> None:
        """Test data storage security (MASVS-STORAGE)."""
        self.progress.info("Testing SharedPreferences...")
        prefs_result = self.mcp.dump_prefs(self.package)

        if prefs_result.get('success'):
            prefs_content = prefs_result.get('output', '')

            # Check for sensitive data patterns
            sensitive_patterns = [
                (r'password["\s:=]+["\']?[^"\'<>\s]+', 'password'),
                (r'token["\s:=]+["\']?[^"\'<>\s]+', 'authentication token'),
                (r'api[_-]?key["\s:=]+["\']?[^"\'<>\s]+', 'API key'),
                (r'secret["\s:=]+["\']?[^"\'<>\s]+', 'secret'),
                (r'private[_-]?key["\s:=]+["\']?[^"\'<>\s]+', 'private key'),
                (r'session[_-]?id["\s:=]+["\']?[^"\'<>\s]+', 'session ID'),
            ]

            for pattern, data_type in sensitive_patterns:
                matches = re.findall(pattern, prefs_content, re.IGNORECASE)
                if matches:
                    self.add_finding(Finding(
                        id=generate_finding_id("STORAGE", f"prefs_{data_type}"),
                        title=f"Sensitive Data in SharedPreferences: {data_type}",
                        severity=Severity.HIGH,
                        category=FindingCategory.STORAGE,
                        description=f"Found {data_type} stored in plaintext SharedPreferences.",
                        evidence=matches[:3],
                        affected_component="SharedPreferences",
                        remediation="Use EncryptedSharedPreferences or Android Keystore.",
                        mastg_id="MASTG-TEST-0001"
                    ))

        # Test databases
        self.progress.info("Testing SQLite databases...")
        db_result = self.mcp.dump_databases(self.package)

        if db_result.get('success'):
            db_content = db_result.get('output', '')

            # Check if databases are encrypted
            if 'SQLCipher' not in db_content and 'encrypted' not in db_content.lower():
                if 'CREATE TABLE' in db_content:
                    self.add_finding(Finding(
                        id=generate_finding_id("STORAGE", "unencrypted_db"),
                        title="Unencrypted SQLite Database",
                        severity=Severity.MEDIUM,
                        category=FindingCategory.STORAGE,
                        description="Application uses unencrypted SQLite database for data storage.",
                        evidence=["Database readable without decryption"],
                        affected_component="SQLite databases",
                        remediation="Implement SQLCipher or Room with encryption.",
                        mastg_id="MASTG-TEST-0002"
                    ))

        # Check external storage
        self.progress.info("Checking external storage...")
        ext_result = self.mcp.shell(f"ls -la /sdcard/Android/data/{self.package}/ 2>/dev/null")

        if ext_result.get('success') and ext_result.get('output'):
            self.add_finding(Finding(
                id=generate_finding_id("STORAGE", "external"),
                title="Data Stored on External Storage",
                severity=Severity.LOW,
                category=FindingCategory.STORAGE,
                description="Application stores data on external storage which is world-readable.",
                evidence=[ext_result.get('output', '')[:500]],
                affected_component="External storage",
                remediation="Store sensitive data only in internal storage.",
                mastg_id="MASTG-TEST-0003"
            ))

    def step_crypto_tests(self) -> None:
        """Test cryptography implementation (MASVS-CRYPTO)."""
        self.progress.info("Analyzing cryptographic implementations...")

        # Hook crypto operations
        crypto_script = """
        Java.perform(function() {
            var findings = [];

            // Check for weak algorithms
            var Cipher = Java.use('javax.crypto.Cipher');
            Cipher.getInstance.overload('java.lang.String').implementation = function(alg) {
                var weakAlgs = ['DES', 'RC4', 'RC2', 'Blowfish', 'IDEA'];
                var ecbMode = alg.indexOf('/ECB/') !== -1;

                if (weakAlgs.some(w => alg.toUpperCase().indexOf(w) !== -1)) {
                    send({type: 'weak_cipher', algorithm: alg});
                }
                if (ecbMode) {
                    send({type: 'ecb_mode', algorithm: alg});
                }
                return this.getInstance(alg);
            };

            // Check for weak hashing
            var MessageDigest = Java.use('java.security.MessageDigest');
            MessageDigest.getInstance.overload('java.lang.String').implementation = function(alg) {
                if (alg.toUpperCase() === 'MD5' || alg.toUpperCase() === 'SHA1') {
                    send({type: 'weak_hash', algorithm: alg});
                }
                return this.getInstance(alg);
            };

            // Check SecureRandom seeding
            var SecureRandom = Java.use('java.security.SecureRandom');
            SecureRandom.setSeed.overload('[B').implementation = function(seed) {
                send({type: 'static_seed', seed_length: seed.length});
                return this.setSeed(seed);
            };
        });
        """

        result = self.mcp.start_frida(self.package, crypto_script)

        # For this assessment, we'll check static indicators
        if self.apk_path and self.apk_path.exists():
            # Would decompile and analyze here
            pass

        # Add informational finding about crypto testing
        self.add_finding(Finding(
            id=generate_finding_id("CRYPTO", "review"),
            title="Cryptographic Implementation Review Required",
            severity=Severity.INFO,
            category=FindingCategory.CRYPTO,
            description="Dynamic crypto hooking configured. Run application to capture cryptographic operations.",
            evidence=["Frida hooks installed for Cipher, MessageDigest, SecureRandom"],
            affected_component="Cryptographic APIs",
            remediation="Review captured crypto operations for weak algorithms.",
            mastg_id="MASTG-TEST-0013"
        ))

    def step_auth_tests(self) -> None:
        """Test authentication mechanisms (MASVS-AUTH)."""
        self.progress.info("Testing authentication mechanisms...")

        # Hook authentication methods
        auth_script = """
        Java.perform(function() {
            // Biometric authentication
            try {
                var BiometricPrompt = Java.use('androidx.biometric.BiometricPrompt$AuthenticationCallback');
                BiometricPrompt.onAuthenticationSucceeded.implementation = function(result) {
                    send({type: 'biometric_success', bypassed: false});
                    return this.onAuthenticationSucceeded(result);
                };
                BiometricPrompt.onAuthenticationFailed.implementation = function() {
                    send({type: 'biometric_failed'});
                    return this.onAuthenticationFailed();
                };
            } catch(e) {}

            // Check for hardcoded credentials
            var String = Java.use('java.lang.String');
            var patterns = ['password', 'admin', 'root', 'secret'];
        });
        """

        result = self.mcp.start_frida(self.package, auth_script)

        # Check for exported authentication activities
        components = self.mcp.test_exported_components(self.package)

        if components.get('success'):
            output = components.get('output', '')
            # Look for auth-related exported activities
            auth_keywords = ['login', 'auth', 'password', 'credential', 'session']

            for keyword in auth_keywords:
                if keyword.lower() in output.lower() and 'exported=true' in output:
                    self.add_finding(Finding(
                        id=generate_finding_id("AUTH", f"exported_{keyword}"),
                        title=f"Exported Authentication Component",
                        severity=Severity.MEDIUM,
                        category=FindingCategory.AUTH,
                        description=f"Authentication-related component containing '{keyword}' is exported.",
                        evidence=[f"Component with '{keyword}' has exported=true"],
                        affected_component="Exported Activities",
                        remediation="Set exported=false for authentication components.",
                        mastg_id="MASTG-TEST-0020"
                    ))
                    break

    def step_network_tests(self) -> None:
        """Test network security (MASVS-NETWORK)."""
        self.progress.info("Testing network security...")

        # Check network security config
        nsc_result = self.mcp.shell(f"run-as {self.package} cat /data/data/{self.package}/res/xml/network_security_config.xml 2>/dev/null")

        # Check for cleartext traffic
        info_result = self.mcp.get_app_info(self.package)
        if info_result.get('success'):
            info_text = info_result.get('output', '')

            if 'usesCleartextTraffic=true' in info_text:
                self.add_finding(Finding(
                    id=generate_finding_id("NETWORK", "cleartext"),
                    title="Cleartext Traffic Allowed",
                    severity=Severity.MEDIUM,
                    category=FindingCategory.NETWORK,
                    description="Application allows cleartext (HTTP) traffic which can be intercepted.",
                    evidence=["usesCleartextTraffic=\"true\" in manifest"],
                    affected_component="AndroidManifest.xml",
                    remediation="Set usesCleartextTraffic=\"false\" and use HTTPS only.",
                    mastg_id="MASTG-TEST-0016"
                ))

        # Hook SSL/TLS
        ssl_script = """
        Java.perform(function() {
            // Check for certificate pinning
            try {
                var CertificatePinner = Java.use('okhttp3.CertificatePinner');
                CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(host, certs) {
                    send({type: 'cert_pinning_check', host: host});
                    return this.check(host, certs);
                };
            } catch(e) {
                send({type: 'no_okhttp_pinning'});
            }

            // Monitor TrustManager
            var TrustManager = Java.use('javax.net.ssl.X509TrustManager');
        });
        """

        self.mcp.start_frida(self.package, ssl_script)

    def step_platform_tests(self) -> None:
        """Test platform interaction security (MASVS-PLATFORM)."""
        self.progress.info("Testing platform interactions...")

        # Get exported components
        components = self.mcp.test_exported_components(self.package)

        if components.get('success'):
            output = components.get('output', '')

            # Count exported components
            exported_activities = output.lower().count('activity') if 'exported=true' in output else 0
            exported_services = output.lower().count('service') if 'exported=true' in output else 0
            exported_receivers = output.lower().count('receiver') if 'exported=true' in output else 0
            exported_providers = output.lower().count('provider') if 'exported=true' in output else 0

            if exported_activities > 1 or exported_services > 0 or exported_receivers > 0:
                self.add_finding(Finding(
                    id=generate_finding_id("PLATFORM", "exported_components"),
                    title="Multiple Exported Components",
                    severity=Severity.LOW,
                    category=FindingCategory.PLATFORM,
                    description="Application has multiple exported components that may be accessible to other apps.",
                    evidence=[f"Activities: {exported_activities}, Services: {exported_services}, Receivers: {exported_receivers}"],
                    affected_component="AndroidManifest.xml",
                    remediation="Review exported components and restrict access where possible.",
                    mastg_id="MASTG-TEST-0022"
                ))

        # Test content providers for SQL injection
        self.progress.info("Testing content providers...")
        sqli_payloads = load_payloads("sql_injection.txt")[:10]

        for payload in sqli_payloads:
            uri = f"content://{self.package}.provider/data{payload}"
            result = self.mcp.query_provider(uri)

            if result.get('success') and 'error' not in result.get('output', '').lower():
                self.add_finding(Finding(
                    id=generate_finding_id("PLATFORM", "sqli"),
                    title="Content Provider SQL Injection",
                    severity=Severity.CRITICAL,
                    category=FindingCategory.PLATFORM,
                    description="Content provider is vulnerable to SQL injection.",
                    evidence=[f"Payload: {payload}", f"Response: {result.get('output', '')[:200]}"],
                    affected_component="Content Provider",
                    remediation="Use parameterized queries and input validation.",
                    mastg_id="MASTG-TEST-0024"
                ))
                break

    def step_code_tests(self) -> None:
        """Test code quality and security (MASVS-CODE)."""
        self.progress.info("Testing code quality...")

        # Check for debugging code in logs
        logcat_result = self.mcp.get_logcat(self.package, lines=500)

        if logcat_result.get('success'):
            logs = logcat_result.get('output', '')

            sensitive_patterns = [
                (r'password[\s:=]+\S+', 'password'),
                (r'token[\s:=]+\S+', 'token'),
                (r'api[_-]?key[\s:=]+\S+', 'API key'),
                (r'secret[\s:=]+\S+', 'secret'),
                (r'bearer\s+\S+', 'bearer token'),
            ]

            for pattern, data_type in sensitive_patterns:
                matches = re.findall(pattern, logs, re.IGNORECASE)
                if matches:
                    self.add_finding(Finding(
                        id=generate_finding_id("CODE", f"log_{data_type}"),
                        title=f"Sensitive Data in Logs: {data_type}",
                        severity=Severity.MEDIUM,
                        category=FindingCategory.CODE,
                        description=f"Application logs contain {data_type} in plaintext.",
                        evidence=matches[:3],
                        affected_component="Application logs",
                        remediation="Remove sensitive data from log statements in production builds.",
                        mastg_id="MASTG-TEST-0031"
                    ))

        # Check for WebView vulnerabilities
        webview_script = """
        Java.perform(function() {
            var WebView = Java.use('android.webkit.WebView');
            var WebSettings = Java.use('android.webkit.WebSettings');

            WebSettings.setJavaScriptEnabled.implementation = function(flag) {
                if (flag) {
                    send({type: 'webview_js_enabled'});
                }
                return this.setJavaScriptEnabled(flag);
            };

            WebSettings.setAllowFileAccess.implementation = function(flag) {
                if (flag) {
                    send({type: 'webview_file_access'});
                }
                return this.setAllowFileAccess(flag);
            };
        });
        """

        self.mcp.start_frida(self.package, webview_script)

    def step_resilience_tests(self) -> None:
        """Test app resilience (MASVS-RESILIENCE)."""
        self.progress.info("Testing application resilience...")

        # Check for root detection
        root_script = """
        Java.perform(function() {
            var detected = false;

            // Common root detection methods
            var File = Java.use('java.io.File');
            var originalExists = File.exists.implementation;

            File.exists.implementation = function() {
                var path = this.getAbsolutePath();
                var rootPaths = ['/system/app/Superuser.apk', '/sbin/su', '/system/bin/su', '/system/xbin/su', '/data/local/xbin/su', '/data/local/bin/su', '/system/sd/xbin/su', '/system/bin/failsafe/su', '/data/local/su'];

                if (rootPaths.indexOf(path) !== -1) {
                    send({type: 'root_detection', path: path});
                    detected = true;
                }
                return originalExists.call(this);
            };
        });
        """

        result = self.mcp.start_frida(self.package, root_script)

        # Check for emulator detection
        emulator_script = """
        Java.perform(function() {
            var Build = Java.use('android.os.Build');

            send({
                type: 'build_info',
                fingerprint: Build.FINGERPRINT.value,
                model: Build.MODEL.value,
                manufacturer: Build.MANUFACTURER.value,
                product: Build.PRODUCT.value
            });
        });
        """

        self.mcp.start_frida(self.package, emulator_script)

    def step_privacy_tests(self) -> None:
        """Test privacy controls (MASVS-PRIVACY)."""
        self.progress.info("Testing privacy controls...")

        # Check permissions
        app_info = self.mcp.get_app_info(self.package)

        if app_info.get('success'):
            info_text = app_info.get('output', '')

            dangerous_permissions = [
                'READ_CONTACTS', 'WRITE_CONTACTS', 'READ_CALENDAR', 'WRITE_CALENDAR',
                'READ_CALL_LOG', 'WRITE_CALL_LOG', 'READ_PHONE_STATE', 'CALL_PHONE',
                'READ_SMS', 'SEND_SMS', 'RECEIVE_SMS', 'RECORD_AUDIO', 'CAMERA',
                'ACCESS_FINE_LOCATION', 'ACCESS_COARSE_LOCATION', 'ACCESS_BACKGROUND_LOCATION',
                'READ_EXTERNAL_STORAGE', 'WRITE_EXTERNAL_STORAGE'
            ]

            found_permissions = []
            for perm in dangerous_permissions:
                if perm in info_text:
                    found_permissions.append(perm)

            if found_permissions:
                self.add_finding(Finding(
                    id=generate_finding_id("PRIVACY", "permissions"),
                    title="Dangerous Permissions Requested",
                    severity=Severity.INFO,
                    category=FindingCategory.PRIVACY,
                    description="Application requests dangerous permissions. Review if all are necessary.",
                    evidence=found_permissions,
                    affected_component="AndroidManifest.xml",
                    remediation="Remove unnecessary permissions and implement runtime permission requests.",
                    mastg_id="MASTG-TEST-0040"
                ))

        # Check for tracking SDKs
        tracking_packages = [
            'com.google.firebase.analytics',
            'com.facebook.appevents',
            'com.appsflyer',
            'com.adjust.sdk',
            'io.branch',
            'com.mixpanel',
            'com.amplitude',
            'com.crashlytics',
        ]

        # Would check for these in decompiled code

    def step_generate_report(self) -> None:
        """Generate comprehensive assessment report."""
        self.progress.info("Generating final report...")

        # Summary by severity
        severity_counts = {
            'critical': len([f for f in self.findings if f.severity == Severity.CRITICAL]),
            'high': len([f for f in self.findings if f.severity == Severity.HIGH]),
            'medium': len([f for f in self.findings if f.severity == Severity.MEDIUM]),
            'low': len([f for f in self.findings if f.severity == Severity.LOW]),
            'info': len([f for f in self.findings if f.severity == Severity.INFO])
        }

        # Summary by category
        category_counts = {}
        for category in FindingCategory:
            count = len([f for f in self.findings if f.category == category])
            if count > 0:
                category_counts[category.value] = count

        report = {
            "assessment": {
                "type": "Full OWASP MASTG Assessment",
                "package": self.package,
                "apk_path": str(self.apk_path) if self.apk_path else None,
                "timestamp": self.checkpoint.started_at if self.checkpoint else "",
                "completed": self.checkpoint.updated_at if self.checkpoint else ""
            },
            "summary": {
                "total_findings": len(self.findings),
                "by_severity": severity_counts,
                "by_category": category_counts,
                "risk_score": self._calculate_risk_score()
            },
            "findings": [f.to_dict() for f in self.findings],
            "recommendations": self._generate_recommendations()
        }

        # Save detailed JSON report
        report_path = self.output_dir / f"{self.package}_full_assessment.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        self.progress.info(f"Full report saved to: {report_path}")

    def _calculate_risk_score(self) -> str:
        """Calculate overall risk score."""
        critical = len([f for f in self.findings if f.severity == Severity.CRITICAL])
        high = len([f for f in self.findings if f.severity == Severity.HIGH])
        medium = len([f for f in self.findings if f.severity == Severity.MEDIUM])

        if critical > 0:
            return "CRITICAL"
        elif high > 2:
            return "HIGH"
        elif high > 0 or medium > 3:
            return "MEDIUM"
        elif medium > 0:
            return "LOW"
        else:
            return "MINIMAL"

    def _generate_recommendations(self) -> list[str]:
        """Generate prioritized recommendations."""
        recommendations = []

        severity_order = [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM]

        for severity in severity_order:
            for finding in self.findings:
                if finding.severity == severity and finding.remediation:
                    recommendations.append(f"[{severity.value.upper()}] {finding.remediation}")

        return recommendations[:10]  # Top 10 recommendations


def main():
    parser = parse_common_args()
    args = parser.parse_args()

    workflow = FullAssessmentWorkflow(
        package=args.package,
        output_dir=Path(args.output),
        apk_path=Path(args.apk) if args.apk else None,
        resume=args.resume,
        verbose=args.verbose
    )

    findings = workflow.run()

    # Print summary
    print(f"\n{'='*60}")
    print(f"Assessment Complete: {len(findings)} findings")
    print(f"Results saved to: {args.output}")
    print(f"{'='*60}")

    return 0 if not any(f.severity in [Severity.CRITICAL, Severity.HIGH] for f in findings) else 1


if __name__ == "__main__":
    exit(main())
