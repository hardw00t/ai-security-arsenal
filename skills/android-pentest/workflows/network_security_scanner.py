#!/usr/bin/env python3
"""
Network Security Scanner
Tests SSL/TLS configuration, certificate pinning, and network traffic security.

Usage:
    python network_security_scanner.py --package com.target.app
    python network_security_scanner.py -p com.target.app --proxy 192.168.1.100:8080
"""

import argparse
import json
import re
import time
from pathlib import Path
from typing import Callable

from base import (
    BaseWorkflow, Finding, Severity, FindingCategory,
    generate_finding_id, parse_common_args
)


class NetworkSecurityScanner(BaseWorkflow):
    """Automated network security scanner."""

    @property
    def name(self) -> str:
        return "network_security_scanner"

    @property
    def description(self) -> str:
        return "Test SSL/TLS configuration and network security"

    @property
    def steps(self) -> list[tuple[str, Callable]]:
        return [
            ("Initialize Scanner", self.step_initialize),
            ("Check Network Security Config", self.step_check_nsc),
            ("Test Cleartext Traffic", self.step_test_cleartext),
            ("Test Certificate Pinning", self.step_test_pinning),
            ("Install SSL Bypass Hooks", self.step_ssl_bypass),
            ("Monitor API Endpoints", self.step_monitor_endpoints),
            ("Check Sensitive Data in Traffic", self.step_check_sensitive_data),
            ("Test Certificate Validation", self.step_test_cert_validation),
            ("Generate Network Report", self.step_generate_report),
        ]

    def __init__(self, *args, proxy: str = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.proxy = proxy
        self.endpoints_discovered: list[dict] = []
        self.pinning_detected: bool = False
        self.pinning_bypassed: bool = False

    def step_initialize(self) -> None:
        """Initialize the network scanner."""
        devices = self.mcp.list_devices()
        if not devices:
            raise RuntimeError("No Android device connected")

        self.progress.info(f"Target package: {self.package}")

        if self.proxy:
            self.progress.info(f"Setting up proxy: {self.proxy}")
            host, port = self.proxy.split(':')
            self.mcp.shell(f"settings put global http_proxy {host}:{port}")

    def step_check_nsc(self) -> None:
        """Check Network Security Configuration."""
        self.progress.info("Analyzing Network Security Configuration...")

        # Try to read the NSC from the APK
        nsc_content = None

        # Check manifest for network security config reference
        app_info = self.mcp.get_app_info(self.package)

        if app_info.get('success'):
            info = app_info.get('output', '')

            # Check for usesCleartextTraffic
            if 'usesCleartextTraffic=true' in info:
                self.add_finding(Finding(
                    id=generate_finding_id("NETWORK", "cleartext_allowed"),
                    title="Cleartext Traffic Globally Allowed",
                    severity=Severity.MEDIUM,
                    category=FindingCategory.NETWORK,
                    description="Application manifest allows cleartext (HTTP) traffic for all domains.",
                    evidence=["android:usesCleartextTraffic=\"true\""],
                    affected_component="AndroidManifest.xml",
                    remediation="Set usesCleartextTraffic=\"false\" and use HTTPS exclusively.",
                    mastg_id="MASTG-TEST-0016"
                ))

            # Check target SDK for default NSC behavior
            sdk_match = re.search(r'targetSdkVersion=(\d+)', info)
            if sdk_match:
                target_sdk = int(sdk_match.group(1))
                if target_sdk < 28:
                    self.add_finding(Finding(
                        id=generate_finding_id("NETWORK", "legacy_cleartext"),
                        title="Legacy Target SDK Allows Cleartext by Default",
                        severity=Severity.LOW,
                        category=FindingCategory.NETWORK,
                        description=f"Target SDK {target_sdk} allows cleartext traffic by default (SDK 28+ blocks by default).",
                        evidence=[f"targetSdkVersion={target_sdk}"],
                        affected_component="build.gradle",
                        remediation="Upgrade to targetSdkVersion 28+ for default cleartext blocking.",
                        mastg_id="MASTG-TEST-0016"
                    ))

    def step_test_cleartext(self) -> None:
        """Test for cleartext traffic usage."""
        self.progress.info("Testing cleartext traffic handling...")

        # Hook URL connections to detect HTTP usage
        cleartext_script = """
        Java.perform(function() {
            var httpUrls = [];

            // Hook URL constructor
            var URL = Java.use('java.net.URL');
            URL.$init.overload('java.lang.String').implementation = function(url) {
                if (url && url.toLowerCase().startsWith('http://')) {
                    httpUrls.push(url);
                    send({type: 'http_url', url: url});
                }
                return this.$init(url);
            };

            // Hook HttpURLConnection
            var HttpURLConnection = Java.use('java.net.HttpURLConnection');
            HttpURLConnection.connect.implementation = function() {
                var url = this.getURL().toString();
                if (url.toLowerCase().startsWith('http://')) {
                    send({type: 'http_connection', url: url});
                }
                return this.connect();
            };

            // Hook OkHttp for cleartext
            try {
                var OkHttpClient = Java.use('okhttp3.OkHttpClient$Builder');
                OkHttpClient.build.implementation = function() {
                    var client = this.build();
                    send({type: 'okhttp_client_built'});
                    return client;
                };
            } catch(e) {}

            send({type: 'cleartext_hooks_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, cleartext_script, spawn=True)

        if result.get('success'):
            self.add_finding(Finding(
                id=generate_finding_id("NETWORK", "cleartext_monitor"),
                title="Cleartext Traffic Monitoring Active",
                severity=Severity.INFO,
                category=FindingCategory.NETWORK,
                description="Monitoring for HTTP (non-HTTPS) traffic. Use the app to detect cleartext usage.",
                evidence=["URL constructor hooked", "HttpURLConnection.connect hooked"],
                affected_component="Network Layer",
                remediation="Use HTTPS for all network communications.",
                mastg_id="MASTG-TEST-0016"
            ))

    def step_test_pinning(self) -> None:
        """Test for certificate pinning implementation."""
        self.progress.info("Testing certificate pinning...")

        # Hook certificate pinning mechanisms
        pinning_detection_script = """
        Java.perform(function() {
            var pinningDetected = false;

            // OkHttp CertificatePinner
            try {
                var CertificatePinner = Java.use('okhttp3.CertificatePinner');
                CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, peerCertificates) {
                    send({
                        type: 'pinning_check',
                        library: 'okhttp',
                        hostname: hostname,
                        cert_count: peerCertificates.size()
                    });
                    pinningDetected = true;
                    return this.check(hostname, peerCertificates);
                };
                send({type: 'okhttp_pinner_found'});
            } catch(e) {
                send({type: 'no_okhttp_pinner'});
            }

            // TrustKit
            try {
                var TrustKit = Java.use('com.datatheorem.android.trustkit.TrustKit');
                send({type: 'trustkit_found'});
                pinningDetected = true;
            } catch(e) {}

            // Android Network Security Config pinning
            try {
                var NetworkSecurityTrustManager = Java.use('android.security.net.config.NetworkSecurityTrustManager');
                NetworkSecurityTrustManager.checkServerTrusted.implementation = function(chain, authType) {
                    send({type: 'nsc_trust_check'});
                    return this.checkServerTrusted(chain, authType);
                };
            } catch(e) {}

            // Custom TrustManager implementations
            try {
                var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
                // This hooks all implementations
            } catch(e) {}

            send({type: 'pinning_detection_ready', detected: pinningDetected});
        });
        """

        result = self.mcp.start_frida(self.package, pinning_detection_script, spawn=True)

        # Wait briefly for hooks to trigger
        time.sleep(2)

        # Check if pinning was detected
        # In real implementation, we'd process Frida messages

        self.add_finding(Finding(
            id=generate_finding_id("NETWORK", "pinning_detection"),
            title="Certificate Pinning Detection Active",
            severity=Severity.INFO,
            category=FindingCategory.NETWORK,
            description="Monitoring for certificate pinning. Make network requests to detect pinning implementation.",
            evidence=["OkHttp CertificatePinner hooked", "TrustManager monitoring active"],
            affected_component="SSL/TLS",
            remediation="Implement certificate pinning using OkHttp CertificatePinner or Network Security Config.",
            mastg_id="MASTG-TEST-0017"
        ))

    def step_ssl_bypass(self) -> None:
        """Install comprehensive SSL pinning bypass hooks."""
        self.progress.info("Installing SSL pinning bypass hooks...")

        ssl_bypass_script = """
        Java.perform(function() {
            var bypassCount = 0;

            // ==================== TRUSTMANAGER BYPASS ====================
            var TrustManager = Java.registerClass({
                name: 'com.bypass.TrustManager',
                implements: [Java.use('javax.net.ssl.X509TrustManager')],
                methods: {
                    checkClientTrusted: function(chain, authType) {},
                    checkServerTrusted: function(chain, authType) {},
                    getAcceptedIssuers: function() { return []; }
                }
            });

            // Override SSLContext
            var SSLContext = Java.use('javax.net.ssl.SSLContext');
            SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(km, tm, sr) {
                var trustManagers = [TrustManager.$new()];
                bypassCount++;
                send({type: 'ssl_context_bypass', count: bypassCount});
                return this.init(km, trustManagers, sr);
            };

            // ==================== OKHTTP BYPASS ====================
            try {
                var CertificatePinner = Java.use('okhttp3.CertificatePinner');
                CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, peerCertificates) {
                    send({type: 'okhttp_pinning_bypassed', hostname: hostname});
                    return;
                };
                CertificatePinner.check.overload('java.lang.String', 'java.util.function.Supplier').implementation = function(hostname, peerCertificates) {
                    send({type: 'okhttp_pinning_bypassed_v2', hostname: hostname});
                    return;
                };
            } catch(e) {}

            // ==================== TRUSTKIT BYPASS ====================
            try {
                var TrustKit = Java.use('com.datatheorem.android.trustkit.pinning.OkHostnameVerifier');
                TrustKit.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession').implementation = function(hostname, session) {
                    send({type: 'trustkit_bypassed', hostname: hostname});
                    return true;
                };
            } catch(e) {}

            // ==================== HOSTNAME VERIFIER BYPASS ====================
            try {
                var HostnameVerifier = Java.use('javax.net.ssl.HostnameVerifier');
                var AllowAllHostnameVerifier = Java.registerClass({
                    name: 'com.bypass.AllowAllHostnameVerifier',
                    implements: [HostnameVerifier],
                    methods: {
                        verify: function(hostname, session) {
                            return true;
                        }
                    }
                });

                var HttpsURLConnection = Java.use('javax.net.ssl.HttpsURLConnection');
                HttpsURLConnection.setDefaultHostnameVerifier.implementation = function(verifier) {
                    this.setDefaultHostnameVerifier(AllowAllHostnameVerifier.$new());
                    send({type: 'hostname_verifier_bypassed'});
                };
            } catch(e) {}

            // ==================== NETWORK SECURITY CONFIG BYPASS ====================
            try {
                var PlatformTrustManager = Java.use('android.security.net.config.RootTrustManager');
                PlatformTrustManager.checkServerTrusted.implementation = function(chain, authType) {
                    send({type: 'nsc_bypassed'});
                };
            } catch(e) {}

            // ==================== WEBVIEW SSL BYPASS ====================
            try {
                var WebViewClient = Java.use('android.webkit.WebViewClient');
                WebViewClient.onReceivedSslError.implementation = function(view, handler, error) {
                    handler.proceed();
                    send({type: 'webview_ssl_bypassed', error: error.toString()});
                };
            } catch(e) {}

            send({type: 'ssl_bypass_ready', initial_bypasses: bypassCount});
        });
        """

        result = self.mcp.start_frida(self.package, ssl_bypass_script, spawn=True)

        if result.get('success'):
            self.pinning_bypassed = True
            self.add_finding(Finding(
                id=generate_finding_id("NETWORK", "ssl_bypass_installed"),
                title="SSL/TLS Pinning Bypass Installed",
                severity=Severity.HIGH,
                category=FindingCategory.NETWORK,
                description="SSL pinning bypass hooks are active. If traffic is now visible in proxy, pinning is bypassable.",
                evidence=["SSLContext.init bypassed", "CertificatePinner.check bypassed", "HostnameVerifier bypassed"],
                affected_component="SSL/TLS Implementation",
                remediation="Implement proper certificate pinning with backup pins. Consider using SafetyNet Attestation.",
                mastg_id="MASTG-TEST-0017"
            ))

    def step_monitor_endpoints(self) -> None:
        """Monitor and catalog API endpoints."""
        self.progress.info("Monitoring API endpoints...")

        endpoint_monitor_script = """
        Java.perform(function() {
            var endpoints = [];

            // Hook OkHttp Request Builder
            try {
                var RequestBuilder = Java.use('okhttp3.Request$Builder');
                RequestBuilder.url.overload('java.lang.String').implementation = function(url) {
                    endpoints.push({url: url, method: 'GET'});
                    send({type: 'endpoint', url: url, method: 'GET', library: 'okhttp'});
                    return this.url(url);
                };

                RequestBuilder.url.overload('okhttp3.HttpUrl').implementation = function(url) {
                    var urlStr = url.toString();
                    endpoints.push({url: urlStr, method: 'GET'});
                    send({type: 'endpoint', url: urlStr, method: 'GET', library: 'okhttp'});
                    return this.url(url);
                };

                RequestBuilder.method.implementation = function(method, body) {
                    send({type: 'http_method', method: method, hasBody: body !== null});
                    return this.method(method, body);
                };
            } catch(e) {}

            // Hook HttpURLConnection
            var HttpURLConnection = Java.use('java.net.HttpURLConnection');
            HttpURLConnection.setRequestMethod.implementation = function(method) {
                send({type: 'httpurlconnection_method', method: method});
                return this.setRequestMethod(method);
            };

            // Hook Retrofit (if used)
            try {
                var Retrofit = Java.use('retrofit2.Retrofit');
                Retrofit.create.implementation = function(service) {
                    send({type: 'retrofit_service', service: service.getName()});
                    return this.create(service);
                };
            } catch(e) {}

            // Hook Volley (if used)
            try {
                var Request = Java.use('com.android.volley.Request');
                Request.$init.overload('int', 'java.lang.String', 'com.android.volley.Response$ErrorListener').implementation = function(method, url, errorListener) {
                    send({type: 'volley_request', url: url, method: method});
                    return this.$init(method, url, errorListener);
                };
            } catch(e) {}

            send({type: 'endpoint_monitoring_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, endpoint_monitor_script)

        self.add_finding(Finding(
            id=generate_finding_id("NETWORK", "endpoint_monitor"),
            title="API Endpoint Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.NETWORK,
            description="Monitoring API endpoints. Use the app to discover all network endpoints.",
            evidence=["OkHttp Request.Builder hooked", "HttpURLConnection hooked", "Retrofit/Volley hooked"],
            affected_component="Network API",
            remediation="Review all discovered endpoints for security issues.",
            mastg_id="MASTG-TEST-0018"
        ))

    def step_check_sensitive_data(self) -> None:
        """Check for sensitive data in network traffic."""
        self.progress.info("Monitoring for sensitive data in traffic...")

        sensitive_data_script = """
        Java.perform(function() {
            var sensitivePatterns = [
                /password["\s:=]/i,
                /token["\s:=]/i,
                /api[_-]?key["\s:=]/i,
                /secret["\s:=]/i,
                /bearer/i,
                /authorization/i,
                /credit[_-]?card/i,
                /\\b\\d{16}\\b/,  // Card numbers
                /\\b\\d{3}-\\d{2}-\\d{4}\\b/  // SSN
            ];

            // Hook request body writing
            try {
                var BufferedSink = Java.use('okio.BufferedSink');
                // Would hook write methods
            } catch(e) {}

            // Hook OutputStream for request bodies
            var OutputStream = Java.use('java.io.OutputStream');
            OutputStream.write.overload('[B').implementation = function(data) {
                try {
                    var content = '';
                    for (var i = 0; i < Math.min(data.length, 1000); i++) {
                        content += String.fromCharCode(data[i] & 0xFF);
                    }

                    for (var p = 0; p < sensitivePatterns.length; p++) {
                        if (sensitivePatterns[p].test(content)) {
                            send({
                                type: 'sensitive_in_request',
                                pattern: sensitivePatterns[p].toString(),
                                preview: content.substring(0, 100)
                            });
                            break;
                        }
                    }
                } catch(e) {}
                return this.write(data);
            };

            send({type: 'sensitive_data_monitoring_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, sensitive_data_script)

        self.add_finding(Finding(
            id=generate_finding_id("NETWORK", "sensitive_data_monitor"),
            title="Sensitive Data Traffic Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.NETWORK,
            description="Monitoring request/response bodies for sensitive data patterns.",
            evidence=["OutputStream.write hooked", "Monitoring for passwords, tokens, PII"],
            affected_component="Network Traffic",
            remediation="Encrypt sensitive data before transmission. Use secure authentication.",
            mastg_id="MASTG-TEST-0019"
        ))

    def step_test_cert_validation(self) -> None:
        """Test certificate validation implementation."""
        self.progress.info("Testing certificate validation...")

        cert_validation_script = """
        Java.perform(function() {
            // Check for custom TrustManager implementations
            var customTrustManagers = [];

            Java.enumerateLoadedClasses({
                onMatch: function(className) {
                    if (className.indexOf('TrustManager') !== -1 ||
                        className.indexOf('trustmanager') !== -1) {
                        try {
                            var clazz = Java.use(className);
                            var methods = clazz.class.getDeclaredMethods();

                            methods.forEach(function(method) {
                                if (method.getName() === 'checkServerTrusted') {
                                    customTrustManagers.push(className);
                                    send({
                                        type: 'custom_trustmanager',
                                        class: className
                                    });
                                }
                            });
                        } catch(e) {}
                    }
                },
                onComplete: function() {
                    send({
                        type: 'trustmanager_scan_complete',
                        found: customTrustManagers.length
                    });
                }
            });

            // Check for TrustAllCertificates pattern
            try {
                var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
                // Any implementation that doesn't throw in checkServerTrusted is insecure
            } catch(e) {}
        });
        """

        result = self.mcp.start_frida(self.package, cert_validation_script)

        self.add_finding(Finding(
            id=generate_finding_id("NETWORK", "cert_validation"),
            title="Certificate Validation Analysis Active",
            severity=Severity.INFO,
            category=FindingCategory.NETWORK,
            description="Analyzing custom TrustManager implementations for validation bypass.",
            evidence=["Custom TrustManager classes scanned", "checkServerTrusted implementations analyzed"],
            affected_component="Certificate Validation",
            remediation="Use default certificate validation. Implement pinning for additional security.",
            mastg_id="MASTG-TEST-0020"
        ))

    def step_generate_report(self) -> None:
        """Generate network security report."""
        self.progress.info("Generating network security report...")

        report = {
            "scan_type": "Network Security Scanner",
            "package": self.package,
            "proxy_configured": self.proxy,
            "summary": {
                "total_findings": len(self.findings),
                "pinning_detected": self.pinning_detected,
                "pinning_bypassed": self.pinning_bypassed,
                "endpoints_discovered": len(self.endpoints_discovered)
            },
            "endpoints": self.endpoints_discovered,
            "recommendations": [
                "Use HTTPS for all communications",
                "Implement certificate pinning",
                "Disable cleartext traffic in manifest",
                "Use TLS 1.2+ only",
                "Implement proper certificate validation",
                "Don't transmit sensitive data in URLs",
                "Use certificate transparency"
            ],
            "findings": [f.to_dict() for f in self.findings]
        }

        report_path = self.output_dir / f"{self.package}_network_security_report.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        self.progress.info(f"Report saved to: {report_path}")

        # Clean up proxy if we set it
        if self.proxy:
            self.progress.info("Clearing proxy settings...")
            self.mcp.shell("settings put global http_proxy :0")


def main():
    parser = parse_common_args()
    parser.add_argument('--proxy', help='Proxy address (host:port)')
    args = parser.parse_args()

    workflow = NetworkSecurityScanner(
        package=args.package,
        output_dir=Path(args.output),
        apk_path=Path(args.apk) if args.apk else None,
        resume=args.resume,
        verbose=args.verbose,
        proxy=args.proxy
    )

    findings = workflow.run()

    print(f"\n{'='*60}")
    print(f"Network Security Scan Complete: {len(findings)} findings")
    print(f"{'='*60}")

    return 0


if __name__ == "__main__":
    exit(main())
