#!/usr/bin/env python3
"""
Cryptography Auditor
Hooks and analyzes all cryptographic operations during app runtime.

Usage:
    python crypto_auditor.py --package com.target.app
    python crypto_auditor.py -p com.target.app --duration 60
"""

import argparse
import base64
import json
import time
from pathlib import Path
from typing import Callable

from base import (
    BaseWorkflow, Finding, Severity, FindingCategory,
    generate_finding_id, parse_common_args
)


class CryptoAuditor(BaseWorkflow):
    """Automated cryptography auditor."""

    @property
    def name(self) -> str:
        return "crypto_auditor"

    @property
    def description(self) -> str:
        return "Hook and analyze cryptographic operations"

    @property
    def steps(self) -> list[tuple[str, Callable]]:
        return [
            ("Initialize Auditor", self.step_initialize),
            ("Install Crypto Hooks", self.step_install_hooks),
            ("Detect Weak Ciphers", self.step_detect_weak_ciphers),
            ("Detect Weak Hashing", self.step_detect_weak_hashing),
            ("Check Random Number Generation", self.step_check_random),
            ("Analyze Key Storage", self.step_analyze_key_storage),
            ("Check Hardcoded Keys", self.step_check_hardcoded_keys),
            ("Monitor Crypto Operations", self.step_monitor_operations),
            ("Generate Crypto Report", self.step_generate_report),
        ]

    def __init__(self, *args, duration: int = 30, **kwargs):
        super().__init__(*args, **kwargs)
        self.duration = duration
        self.crypto_operations: list[dict] = []
        self.weak_algorithms: list[dict] = []
        self.key_findings: list[dict] = []

    # Weak algorithm classifications
    WEAK_CIPHERS = ['DES', 'DESede', '3DES', 'RC2', 'RC4', 'Blowfish', 'IDEA']
    WEAK_MODES = ['ECB']
    WEAK_PADDING = ['NoPadding']  # For block ciphers
    WEAK_HASHES = ['MD5', 'MD4', 'SHA1', 'SHA-1']
    MIN_KEY_SIZE = {'AES': 128, 'RSA': 2048}

    def step_initialize(self) -> None:
        """Initialize the crypto auditor."""
        devices = self.mcp.list_devices()
        if not devices:
            raise RuntimeError("No Android device connected")

        self.progress.info(f"Target package: {self.package}")
        self.progress.info(f"Monitoring duration: {self.duration}s")

    def step_install_hooks(self) -> None:
        """Install comprehensive crypto hooks."""
        self.progress.info("Installing cryptographic operation hooks...")

        # Comprehensive crypto hooking script
        crypto_hooks = """
        Java.perform(function() {
            var cryptoOps = [];

            // ==================== CIPHER HOOKS ====================
            var Cipher = Java.use('javax.crypto.Cipher');

            Cipher.getInstance.overload('java.lang.String').implementation = function(transformation) {
                send({
                    type: 'cipher_init',
                    transformation: transformation,
                    timestamp: Date.now()
                });
                return this.getInstance(transformation);
            };

            Cipher.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function(transformation, provider) {
                send({
                    type: 'cipher_init',
                    transformation: transformation,
                    provider: provider,
                    timestamp: Date.now()
                });
                return this.getInstance(transformation, provider);
            };

            Cipher.init.overload('int', 'java.security.Key').implementation = function(opmode, key) {
                var keyInfo = {
                    algorithm: key.getAlgorithm(),
                    format: key.getFormat(),
                    encoded_length: key.getEncoded() ? key.getEncoded().length : 0
                };
                send({
                    type: 'cipher_key',
                    operation: opmode === 1 ? 'ENCRYPT' : 'DECRYPT',
                    key: keyInfo,
                    timestamp: Date.now()
                });
                return this.init(opmode, key);
            };

            Cipher.doFinal.overload('[B').implementation = function(input) {
                var result = this.doFinal(input);
                send({
                    type: 'cipher_operation',
                    algorithm: this.getAlgorithm(),
                    input_length: input.length,
                    output_length: result.length,
                    timestamp: Date.now()
                });
                return result;
            };

            // ==================== MESSAGE DIGEST HOOKS ====================
            var MessageDigest = Java.use('java.security.MessageDigest');

            MessageDigest.getInstance.overload('java.lang.String').implementation = function(algorithm) {
                send({
                    type: 'hash_init',
                    algorithm: algorithm,
                    timestamp: Date.now()
                });
                return this.getInstance(algorithm);
            };

            MessageDigest.digest.overload('[B').implementation = function(input) {
                var result = this.digest(input);
                send({
                    type: 'hash_operation',
                    algorithm: this.getAlgorithm(),
                    input_length: input.length,
                    output_length: result.length,
                    timestamp: Date.now()
                });
                return result;
            };

            // ==================== MAC HOOKS ====================
            var Mac = Java.use('javax.crypto.Mac');

            Mac.getInstance.overload('java.lang.String').implementation = function(algorithm) {
                send({
                    type: 'mac_init',
                    algorithm: algorithm,
                    timestamp: Date.now()
                });
                return this.getInstance(algorithm);
            };

            // ==================== SECURE RANDOM HOOKS ====================
            var SecureRandom = Java.use('java.security.SecureRandom');

            SecureRandom.$init.overload().implementation = function() {
                send({type: 'securerandom_init', seeded: false, timestamp: Date.now()});
                return this.$init();
            };

            SecureRandom.$init.overload('[B').implementation = function(seed) {
                send({
                    type: 'securerandom_init',
                    seeded: true,
                    seed_length: seed.length,
                    timestamp: Date.now()
                });
                return this.$init(seed);
            };

            SecureRandom.setSeed.overload('[B').implementation = function(seed) {
                send({
                    type: 'securerandom_seed',
                    seed_length: seed.length,
                    timestamp: Date.now()
                });
                return this.setSeed(seed);
            };

            SecureRandom.setSeed.overload('long').implementation = function(seed) {
                send({
                    type: 'securerandom_seed_static',
                    seed_value: seed,
                    timestamp: Date.now()
                });
                return this.setSeed(seed);
            };

            // ==================== KEY GENERATOR HOOKS ====================
            var KeyGenerator = Java.use('javax.crypto.KeyGenerator');

            KeyGenerator.getInstance.overload('java.lang.String').implementation = function(algorithm) {
                send({
                    type: 'keygen_init',
                    algorithm: algorithm,
                    timestamp: Date.now()
                });
                return this.getInstance(algorithm);
            };

            KeyGenerator.init.overload('int').implementation = function(keysize) {
                send({
                    type: 'keygen_size',
                    keysize: keysize,
                    timestamp: Date.now()
                });
                return this.init(keysize);
            };

            // ==================== KEY PAIR GENERATOR HOOKS ====================
            var KeyPairGenerator = Java.use('java.security.KeyPairGenerator');

            KeyPairGenerator.getInstance.overload('java.lang.String').implementation = function(algorithm) {
                send({
                    type: 'keypairgen_init',
                    algorithm: algorithm,
                    timestamp: Date.now()
                });
                return this.getInstance(algorithm);
            };

            KeyPairGenerator.initialize.overload('int').implementation = function(keysize) {
                send({
                    type: 'keypairgen_size',
                    keysize: keysize,
                    timestamp: Date.now()
                });
                return this.initialize(keysize);
            };

            // ==================== KEYSTORE HOOKS ====================
            try {
                var KeyStore = Java.use('java.security.KeyStore');

                KeyStore.getInstance.overload('java.lang.String').implementation = function(type) {
                    send({
                        type: 'keystore_init',
                        store_type: type,
                        timestamp: Date.now()
                    });
                    return this.getInstance(type);
                };

                KeyStore.getKey.implementation = function(alias, password) {
                    send({
                        type: 'keystore_access',
                        alias: alias,
                        timestamp: Date.now()
                    });
                    return this.getKey(alias, password);
                };
            } catch(e) {}

            // ==================== ANDROID KEYSTORE HOOKS ====================
            try {
                var AndroidKeyStore = Java.use('android.security.keystore.KeyGenParameterSpec$Builder');

                AndroidKeyStore.$init.overload('java.lang.String', 'int').implementation = function(alias, purposes) {
                    send({
                        type: 'android_keystore',
                        alias: alias,
                        purposes: purposes,
                        timestamp: Date.now()
                    });
                    return this.$init(alias, purposes);
                };
            } catch(e) {}

            send({type: 'crypto_hooks_ready'});
        });
        """

        result = self.mcp.start_frida(self.package, crypto_hooks, spawn=True)

        if result.get('success'):
            self.progress.info("Crypto hooks installed successfully")
        else:
            self.progress.warning("Failed to install some crypto hooks")

    def step_detect_weak_ciphers(self) -> None:
        """Detect usage of weak cipher algorithms."""
        self.progress.info("Monitoring for weak cipher usage...")

        # Check decompiled code for weak algorithms
        if self.apk_path and self.apk_path.exists():
            # Would scan decompiled source
            pass

        # Check for weak algorithms in Frida output
        # This is handled by the hooks already installed

        # Add informational finding
        weak_cipher_info = {
            'weak_ciphers': self.WEAK_CIPHERS,
            'weak_modes': self.WEAK_MODES,
            'note': 'Real-time monitoring active'
        }

        self.add_finding(Finding(
            id=generate_finding_id("CRYPTO", "cipher_monitor"),
            title="Cipher Algorithm Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.CRYPTO,
            description="Monitoring cipher algorithm usage. Exercise app functionality to capture crypto operations.",
            evidence=[f"Weak ciphers monitored: {', '.join(self.WEAK_CIPHERS)}", f"Weak modes monitored: {', '.join(self.WEAK_MODES)}"],
            affected_component="javax.crypto.Cipher",
            remediation="Use AES-256-GCM or ChaCha20-Poly1305 for symmetric encryption.",
            mastg_id="MASTG-TEST-0013"
        ))

    def step_detect_weak_hashing(self) -> None:
        """Detect usage of weak hashing algorithms."""
        self.progress.info("Monitoring for weak hash algorithms...")

        # Weak hash detection is handled by installed hooks
        self.add_finding(Finding(
            id=generate_finding_id("CRYPTO", "hash_monitor"),
            title="Hash Algorithm Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.CRYPTO,
            description="Monitoring hash algorithm usage for weak algorithms like MD5 and SHA1.",
            evidence=[f"Weak hashes monitored: {', '.join(self.WEAK_HASHES)}"],
            affected_component="java.security.MessageDigest",
            remediation="Use SHA-256 or SHA-3 for hashing. Use bcrypt/scrypt/Argon2 for passwords.",
            mastg_id="MASTG-TEST-0014"
        ))

    def step_check_random(self) -> None:
        """Check for insecure random number generation."""
        self.progress.info("Checking random number generation...")

        # Hook java.util.Random (insecure)
        insecure_random_script = """
        Java.perform(function() {
            var Random = Java.use('java.util.Random');

            Random.$init.overload().implementation = function() {
                send({type: 'insecure_random', seeded: false, timestamp: Date.now()});

                // Get call stack
                var stack = Java.use('java.lang.Thread').currentThread().getStackTrace();
                var caller = '';
                for (var i = 2; i < Math.min(stack.length, 6); i++) {
                    caller += stack[i].toString() + '\\n';
                }
                send({type: 'random_stack', stack: caller});

                return this.$init();
            };

            Random.$init.overload('long').implementation = function(seed) {
                send({
                    type: 'insecure_random',
                    seeded: true,
                    seed_value: seed,
                    timestamp: Date.now()
                });
                return this.$init(seed);
            };

            // Hook Math.random()
            var Math = Java.use('java.lang.Math');
            Math.random.implementation = function() {
                send({type: 'math_random', timestamp: Date.now()});
                return this.random();
            };
        });
        """

        self.mcp.start_frida(self.package, insecure_random_script)

        self.add_finding(Finding(
            id=generate_finding_id("CRYPTO", "random_monitor"),
            title="Random Number Generation Monitoring Active",
            severity=Severity.INFO,
            category=FindingCategory.CRYPTO,
            description="Monitoring for insecure random number generation (java.util.Random, Math.random).",
            evidence=["java.util.Random hooked", "Math.random hooked"],
            affected_component="Random Number Generation",
            remediation="Use java.security.SecureRandom for cryptographic operations.",
            mastg_id="MASTG-TEST-0015"
        ))

    def step_analyze_key_storage(self) -> None:
        """Analyze how cryptographic keys are stored."""
        self.progress.info("Analyzing key storage mechanisms...")

        # Check SharedPreferences for keys
        prefs_result = self.mcp.dump_prefs(self.package)

        if prefs_result.get('success'):
            prefs = prefs_result.get('output', '')

            import re
            key_patterns = [
                (r'["\']?(?:aes|des|rsa)[_-]?key["\']?\s*[:=]\s*["\']([a-zA-Z0-9+/=]{16,})', 'Symmetric/Asymmetric Key'),
                (r'["\']?(?:private|secret)[_-]?key["\']?\s*[:=]\s*["\']([a-zA-Z0-9+/=]{16,})', 'Private Key'),
                (r'["\']?(?:encryption|crypto)[_-]?key["\']?\s*[:=]\s*["\']([a-zA-Z0-9+/=]{16,})', 'Encryption Key'),
                (r'([a-fA-F0-9]{32,})', 'Potential Hex Key'),
            ]

            for pattern, key_type in key_patterns:
                matches = re.findall(pattern, prefs, re.IGNORECASE)
                if matches:
                    self.key_findings.append({
                        'type': key_type,
                        'location': 'SharedPreferences',
                        'count': len(matches)
                    })

                    self.add_finding(Finding(
                        id=generate_finding_id("CRYPTO", f"key_storage_{key_type.lower().replace(' ', '_')}"),
                        title=f"{key_type} Found in SharedPreferences",
                        severity=Severity.CRITICAL,
                        category=FindingCategory.CRYPTO,
                        description=f"Cryptographic key material found in plaintext SharedPreferences.",
                        evidence=[f"Found {len(matches)} potential keys"],
                        affected_component="Key Storage",
                        remediation="Store keys in Android Keystore. Never store raw key material in SharedPreferences.",
                        mastg_id="MASTG-TEST-0016"
                    ))

        # Check for hardcoded keys in databases
        db_result = self.mcp.dump_databases(self.package)

        if db_result.get('success'):
            db_content = db_result.get('output', '')

            if 'key' in db_content.lower() or 'secret' in db_content.lower():
                import re
                # Look for base64-encoded keys
                b64_pattern = r'[A-Za-z0-9+/]{32,}={0,2}'
                matches = re.findall(b64_pattern, db_content)

                for match in matches[:5]:
                    try:
                        decoded = base64.b64decode(match)
                        if len(decoded) in [16, 24, 32]:  # Common key sizes
                            self.add_finding(Finding(
                                id=generate_finding_id("CRYPTO", "db_key"),
                                title="Potential Cryptographic Key in Database",
                                severity=Severity.HIGH,
                                category=FindingCategory.CRYPTO,
                                description="Found base64-encoded data of common key length in database.",
                                evidence=[f"Data length: {len(decoded)} bytes (matches AES key size)"],
                                affected_component="SQLite Database",
                                remediation="Store keys only in Android Keystore.",
                                mastg_id="MASTG-TEST-0016"
                            ))
                            break
                    except Exception:
                        pass

    def step_check_hardcoded_keys(self) -> None:
        """Check for hardcoded cryptographic keys in code."""
        self.progress.info("Checking for hardcoded keys...")

        # Hook SecretKeySpec to catch hardcoded keys
        key_detection_script = """
        Java.perform(function() {
            var SecretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');

            SecretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function(key, algorithm) {
                // Convert key bytes to hex for analysis
                var hexKey = '';
                for (var i = 0; i < key.length; i++) {
                    hexKey += ('0' + (key[i] & 0xFF).toString(16)).slice(-2);
                }

                // Check for suspicious patterns (all zeros, sequential, repeating)
                var isWeak = false;
                var pattern = '';

                if (hexKey.match(/^0+$/)) {
                    isWeak = true;
                    pattern = 'all_zeros';
                } else if (hexKey.match(/^(.)\\1+$/)) {
                    isWeak = true;
                    pattern = 'repeating_byte';
                } else if (hexKey === '0123456789abcdef0123456789abcdef') {
                    isWeak = true;
                    pattern = 'sequential';
                }

                send({
                    type: 'secret_key_created',
                    algorithm: algorithm,
                    key_length: key.length,
                    key_hex: hexKey.substring(0, 16) + '...',
                    weak_key: isWeak,
                    weak_pattern: pattern,
                    timestamp: Date.now()
                });

                // Get stack trace
                var stack = Java.use('java.lang.Thread').currentThread().getStackTrace();
                var caller = '';
                for (var i = 2; i < Math.min(stack.length, 8); i++) {
                    caller += stack[i].toString() + '\\n';
                }
                send({type: 'key_stack', stack: caller});

                return this.$init(key, algorithm);
            };

            // Hook PBEKeySpec for password-based keys
            var PBEKeySpec = Java.use('javax.crypto.spec.PBEKeySpec');

            PBEKeySpec.$init.overload('[C').implementation = function(password) {
                var pw = '';
                for (var i = 0; i < Math.min(password.length, 10); i++) {
                    pw += String.fromCharCode(password[i]);
                }
                send({
                    type: 'pbe_key',
                    password_preview: pw + (password.length > 10 ? '...' : ''),
                    password_length: password.length,
                    timestamp: Date.now()
                });
                return this.$init(password);
            };

            PBEKeySpec.$init.overload('[C', '[B', 'int', 'int').implementation = function(password, salt, iterations, keyLength) {
                send({
                    type: 'pbkdf',
                    salt_length: salt.length,
                    iterations: iterations,
                    key_length: keyLength,
                    timestamp: Date.now()
                });

                // Check for weak iterations
                if (iterations < 10000) {
                    send({type: 'weak_pbkdf', iterations: iterations});
                }

                return this.$init(password, salt, iterations, keyLength);
            };
        });
        """

        result = self.mcp.start_frida(self.package, key_detection_script)

        if result.get('success'):
            self.add_finding(Finding(
                id=generate_finding_id("CRYPTO", "key_detection"),
                title="Hardcoded Key Detection Active",
                severity=Severity.INFO,
                category=FindingCategory.CRYPTO,
                description="Monitoring SecretKeySpec and PBEKeySpec for hardcoded or weak keys.",
                evidence=["SecretKeySpec.$init hooked", "PBEKeySpec.$init hooked"],
                affected_component="Key Generation",
                remediation="Generate keys using KeyGenerator with secure parameters.",
                mastg_id="MASTG-TEST-0017"
            ))

    def step_monitor_operations(self) -> None:
        """Monitor crypto operations for the specified duration."""
        self.progress.info(f"Monitoring crypto operations for {self.duration} seconds...")
        self.progress.info("Exercise app functionality to capture operations...")

        # In a real implementation, we would collect Frida messages here
        time.sleep(min(self.duration, 10))  # Wait a reasonable time

        self.progress.info("Monitoring period complete")

    def step_generate_report(self) -> None:
        """Generate cryptography audit report."""
        self.progress.info("Generating crypto audit report...")

        report = {
            "audit_type": "Cryptography Auditor",
            "package": self.package,
            "duration": self.duration,
            "summary": {
                "total_findings": len(self.findings),
                "critical_issues": len([f for f in self.findings if f.severity == Severity.CRITICAL]),
                "weak_algorithms_detected": len(self.weak_algorithms),
                "key_storage_issues": len(self.key_findings)
            },
            "weak_algorithms": {
                "ciphers": self.WEAK_CIPHERS,
                "modes": self.WEAK_MODES,
                "hashes": self.WEAK_HASHES
            },
            "recommendations": [
                "Use AES-256-GCM for symmetric encryption",
                "Use RSA-2048+ or ECDSA for asymmetric operations",
                "Use SHA-256 or SHA-3 for hashing",
                "Use bcrypt/scrypt/Argon2 for password hashing",
                "Store keys in Android Keystore",
                "Use SecureRandom for cryptographic randomness",
                "Implement certificate pinning for network security"
            ],
            "findings": [f.to_dict() for f in self.findings]
        }

        report_path = self.output_dir / f"{self.package}_crypto_audit.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        self.progress.info(f"Report saved to: {report_path}")


def main():
    parser = parse_common_args()
    parser.add_argument('--duration', '-dur', type=int, default=30,
                       help='Duration to monitor crypto operations (seconds)')
    args = parser.parse_args()

    workflow = CryptoAuditor(
        package=args.package,
        output_dir=Path(args.output),
        apk_path=Path(args.apk) if args.apk else None,
        resume=args.resume,
        verbose=args.verbose,
        duration=args.duration
    )

    findings = workflow.run()

    print(f"\n{'='*60}")
    print(f"Crypto Audit Complete: {len(findings)} findings")
    print(f"{'='*60}")

    return 0


if __name__ == "__main__":
    exit(main())
