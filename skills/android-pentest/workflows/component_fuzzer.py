#!/usr/bin/env python3
"""
Component Fuzzer
Enumerate and fuzz exported Android components (Activities, Services, Providers, Receivers).

Usage:
    python component_fuzzer.py --package com.target.app
    python component_fuzzer.py -p com.target.app --components activities,providers
"""

import argparse
import json
import re
import time
from pathlib import Path
from typing import Callable

from base import (
    BaseWorkflow, Finding, Severity, FindingCategory,
    generate_finding_id, load_payloads, parse_common_args
)


class ComponentFuzzer(BaseWorkflow):
    """Automated component fuzzer."""

    @property
    def name(self) -> str:
        return "component_fuzzer"

    @property
    def description(self) -> str:
        return "Enumerate and fuzz exported Android components"

    @property
    def steps(self) -> list[tuple[str, Callable]]:
        return [
            ("Initialize Fuzzer", self.step_initialize),
            ("Enumerate Components", self.step_enumerate_components),
            ("Fuzz Activities", self.step_fuzz_activities),
            ("Fuzz Services", self.step_fuzz_services),
            ("Fuzz Content Providers", self.step_fuzz_providers),
            ("Fuzz Broadcast Receivers", self.step_fuzz_receivers),
            ("Test Deep Links", self.step_test_deep_links),
            ("Monitor Crashes", self.step_monitor_crashes),
            ("Generate Fuzzing Report", self.step_generate_report),
        ]

    def __init__(self, *args, components: list[str] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.components = components or ['all']
        self.exported_activities: list[str] = []
        self.exported_services: list[str] = []
        self.exported_providers: list[str] = []
        self.exported_receivers: list[str] = []
        self.deep_links: list[str] = []
        self.crashes_detected: list[dict] = []

    def step_initialize(self) -> None:
        """Initialize the fuzzer."""
        devices = self.mcp.list_devices()
        if not devices:
            raise RuntimeError("No Android device connected")

        self.progress.info(f"Target package: {self.package}")
        self.progress.info(f"Components to fuzz: {', '.join(self.components)}")

        # Install crash monitoring
        self._install_crash_monitor()

    def _install_crash_monitor(self) -> None:
        """Install crash monitoring hooks."""
        crash_script = """
        Java.perform(function() {
            // Hook UncaughtExceptionHandler
            var Thread = Java.use('java.lang.Thread');
            var UncaughtExceptionHandler = Java.use('java.lang.Thread$UncaughtExceptionHandler');

            var originalHandler = Thread.getDefaultUncaughtExceptionHandler();

            Thread.setDefaultUncaughtExceptionHandler(Java.registerClass({
                name: 'com.fuzzer.CrashHandler',
                implements: [UncaughtExceptionHandler],
                methods: {
                    uncaughtException: function(thread, throwable) {
                        send({
                            type: 'crash',
                            thread: thread.getName(),
                            exception: throwable.getClass().getName(),
                            message: throwable.getMessage(),
                            stack: throwable.getStackTrace().toString()
                        });

                        if (originalHandler) {
                            originalHandler.uncaughtException(thread, throwable);
                        }
                    }
                }
            }).$new());

            // Hook Activity lifecycle for crash detection
            try {
                var Activity = Java.use('android.app.Activity');
                Activity.onCreate.overload('android.os.Bundle').implementation = function(bundle) {
                    try {
                        return this.onCreate(bundle);
                    } catch(e) {
                        send({
                            type: 'activity_crash',
                            activity: this.getClass().getName(),
                            exception: e.toString()
                        });
                        throw e;
                    }
                };
            } catch(e) {}

            send({type: 'crash_monitor_ready'});
        });
        """

        self.mcp.start_frida(self.package, crash_script, spawn=True)

    def step_enumerate_components(self) -> None:
        """Enumerate all exported components."""
        self.progress.info("Enumerating exported components...")

        result = self.mcp.get_app_info(self.package)

        if not result.get('success'):
            self.progress.warning("Could not get app info")
            return

        info = result.get('output', '')

        # Parse activities
        activity_pattern = r'Activity\s*\{[^}]*name=([^\s}]+)[^}]*exported=(true|false)'
        for match in re.finditer(activity_pattern, info, re.IGNORECASE):
            activity_name = match.group(1)
            exported = match.group(2).lower() == 'true'
            if exported:
                self.exported_activities.append(activity_name)

        # Parse services
        service_pattern = r'Service\s*\{[^}]*name=([^\s}]+)[^}]*exported=(true|false)'
        for match in re.finditer(service_pattern, info, re.IGNORECASE):
            service_name = match.group(1)
            exported = match.group(2).lower() == 'true'
            if exported:
                self.exported_services.append(service_name)

        # Parse providers
        provider_pattern = r'Provider\s*\{[^}]*name=([^\s}]+)[^}]*authorities=([^\s}]+)'
        for match in re.finditer(provider_pattern, info, re.IGNORECASE):
            provider_name = match.group(1)
            authorities = match.group(2)
            # Check if exported (default varies by SDK)
            if 'exported=true' in info[match.start():match.end()+100]:
                self.exported_providers.append({'name': provider_name, 'authority': authorities})

        # Parse receivers
        receiver_pattern = r'Receiver\s*\{[^}]*name=([^\s}]+)[^}]*exported=(true|false)'
        for match in re.finditer(receiver_pattern, info, re.IGNORECASE):
            receiver_name = match.group(1)
            exported = match.group(2).lower() == 'true'
            if exported:
                self.exported_receivers.append(receiver_name)

        # Parse deep links
        deeplink_pattern = r'<data[^>]*scheme="([^"]+)"[^>]*host="([^"]*)"'
        for match in re.finditer(deeplink_pattern, info, re.IGNORECASE):
            scheme = match.group(1)
            host = match.group(2)
            self.deep_links.append(f"{scheme}://{host}")

        self.progress.info(f"Found: {len(self.exported_activities)} activities, "
                          f"{len(self.exported_services)} services, "
                          f"{len(self.exported_providers)} providers, "
                          f"{len(self.exported_receivers)} receivers, "
                          f"{len(self.deep_links)} deep links")

        if self.checkpoint:
            self.checkpoint.state['exported_activities'] = self.exported_activities
            self.checkpoint.state['exported_services'] = self.exported_services
            self.checkpoint.state['exported_providers'] = [p['name'] for p in self.exported_providers]
            self.checkpoint.state['exported_receivers'] = self.exported_receivers
            self.checkpoint.state['deep_links'] = self.deep_links

    def step_fuzz_activities(self) -> None:
        """Fuzz exported activities with malicious intents."""
        if 'all' not in self.components and 'activities' not in self.components:
            self.progress.info("Skipping activity fuzzing")
            return

        self.progress.info(f"Fuzzing {len(self.exported_activities)} exported activities...")

        # Load intent injection payloads
        intent_payloads = load_payloads("intent_injection.txt")

        for activity in self.exported_activities:
            full_activity = activity if '.' in activity else f"{self.package}.{activity}"
            self.progress.info(f"  Testing: {activity}")

            # Test basic launch
            result = self.mcp.send_intent(component=f"{self.package}/{full_activity}")

            if result.get('success'):
                # Test with various extras
                test_extras = [
                    {'debug': True},
                    {'admin': True},
                    {'user_id': -1},
                    {'bypass_auth': True},
                    {'redirect': 'http://evil.com'},
                    {'file': '../../../etc/passwd'},
                ]

                for extras in test_extras:
                    result = self.mcp.send_intent(
                        component=f"{self.package}/{full_activity}",
                        extras=extras
                    )
                    time.sleep(0.5)  # Allow time for crash detection

                # Check for sensitive activity access
                sensitive_keywords = ['admin', 'debug', 'settings', 'config', 'internal', 'hidden']
                if any(kw in activity.lower() for kw in sensitive_keywords):
                    self.add_finding(Finding(
                        id=generate_finding_id("PLATFORM", f"sensitive_activity_{activity}"),
                        title=f"Sensitive Activity Exported: {activity}",
                        severity=Severity.MEDIUM,
                        category=FindingCategory.PLATFORM,
                        description=f"Potentially sensitive activity '{activity}' is exported and accessible.",
                        evidence=[f"Activity: {full_activity}", "Successfully launched via intent"],
                        affected_component=full_activity,
                        remediation="Set android:exported=\"false\" for sensitive activities.",
                        mastg_id="MASTG-TEST-0022"
                    ))

    def step_fuzz_services(self) -> None:
        """Fuzz exported services."""
        if 'all' not in self.components and 'services' not in self.components:
            self.progress.info("Skipping service fuzzing")
            return

        self.progress.info(f"Fuzzing {len(self.exported_services)} exported services...")

        for service in self.exported_services:
            full_service = service if '.' in service else f"{self.package}.{service}"
            self.progress.info(f"  Testing: {service}")

            # Try to start the service
            result = self.mcp.shell(f"am startservice -n {self.package}/{full_service}")

            if result.get('success') and 'error' not in result.get('output', '').lower():
                # Service is accessible
                sensitive_keywords = ['sync', 'upload', 'download', 'background', 'data']
                if any(kw in service.lower() for kw in sensitive_keywords):
                    self.add_finding(Finding(
                        id=generate_finding_id("PLATFORM", f"exported_service_{service}"),
                        title=f"Exported Service: {service}",
                        severity=Severity.LOW,
                        category=FindingCategory.PLATFORM,
                        description=f"Service '{service}' is exported and can be started by other apps.",
                        evidence=[f"Service: {full_service}", "Successfully started"],
                        affected_component=full_service,
                        remediation="Add permission requirements or set exported=\"false\".",
                        mastg_id="MASTG-TEST-0023"
                    ))

            # Stop the service
            self.mcp.shell(f"am stopservice -n {self.package}/{full_service}")

    def step_fuzz_providers(self) -> None:
        """Fuzz content providers for SQL injection and path traversal."""
        if 'all' not in self.components and 'providers' not in self.components:
            self.progress.info("Skipping provider fuzzing")
            return

        self.progress.info(f"Fuzzing {len(self.exported_providers)} exported providers...")

        # Load payloads
        sqli_payloads = load_payloads("sql_injection.txt")[:20]
        traversal_payloads = load_payloads("path_traversal.txt")[:20]

        for provider in self.exported_providers:
            authority = provider.get('authority', '')
            self.progress.info(f"  Testing: {authority}")

            # Test SQL injection
            for payload in sqli_payloads:
                uri = f"content://{authority}/data{payload}"

                result = self.mcp.query_provider(uri)

                if result.get('success'):
                    output = result.get('output', '')
                    # Check for SQL error messages indicating vulnerability
                    if any(err in output.lower() for err in ['syntax error', 'sqlite', 'sql']):
                        self.add_finding(Finding(
                            id=generate_finding_id("PLATFORM", f"sqli_{authority}"),
                            title=f"SQL Injection in Content Provider: {authority}",
                            severity=Severity.CRITICAL,
                            category=FindingCategory.PLATFORM,
                            description="Content provider is vulnerable to SQL injection.",
                            evidence=[f"URI: {uri}", f"Response: {output[:200]}"],
                            affected_component=f"content://{authority}",
                            remediation="Use parameterized queries. Validate and sanitize input.",
                            mastg_id="MASTG-TEST-0024"
                        ))
                        break

            # Test path traversal
            for payload in traversal_payloads:
                uri = f"content://{authority}/files/{payload}"

                result = self.mcp.query_provider(uri)

                if result.get('success'):
                    output = result.get('output', '')
                    # Check for signs of successful traversal
                    if 'root:' in output or 'passwd' in output or '/data/' in output:
                        self.add_finding(Finding(
                            id=generate_finding_id("PLATFORM", f"traversal_{authority}"),
                            title=f"Path Traversal in Content Provider: {authority}",
                            severity=Severity.HIGH,
                            category=FindingCategory.PLATFORM,
                            description="Content provider is vulnerable to path traversal.",
                            evidence=[f"URI: {uri}", f"Response indicates file access"],
                            affected_component=f"content://{authority}",
                            remediation="Validate file paths. Use canonical path comparison.",
                            mastg_id="MASTG-TEST-0025"
                        ))
                        break

            # Test projection injection
            result = self.mcp.query_provider(
                f"content://{authority}/data",
                projection="* FROM sqlite_master;--"
            )

            if result.get('success') and 'table' in result.get('output', '').lower():
                self.add_finding(Finding(
                    id=generate_finding_id("PLATFORM", f"projection_injection_{authority}"),
                    title=f"Projection Injection in Content Provider: {authority}",
                    severity=Severity.HIGH,
                    category=FindingCategory.PLATFORM,
                    description="Content provider is vulnerable to projection injection.",
                    evidence=[f"Authority: {authority}", "Database schema leaked"],
                    affected_component=f"content://{authority}",
                    remediation="Whitelist allowed projection columns.",
                    mastg_id="MASTG-TEST-0024"
                ))

    def step_fuzz_receivers(self) -> None:
        """Fuzz broadcast receivers."""
        if 'all' not in self.components and 'receivers' not in self.components:
            self.progress.info("Skipping receiver fuzzing")
            return

        self.progress.info(f"Fuzzing {len(self.exported_receivers)} exported receivers...")

        # Common broadcast actions to test
        test_actions = [
            'android.intent.action.BOOT_COMPLETED',
            'android.net.conn.CONNECTIVITY_CHANGE',
            f'{self.package}.CUSTOM_ACTION',
            f'{self.package}.DEBUG',
            f'{self.package}.ADMIN',
        ]

        for receiver in self.exported_receivers:
            full_receiver = receiver if '.' in receiver else f"{self.package}.{receiver}"
            self.progress.info(f"  Testing: {receiver}")

            # Send test broadcasts
            for action in test_actions:
                result = self.mcp.shell(
                    f"am broadcast -a {action} -n {self.package}/{full_receiver}"
                )
                time.sleep(0.3)

            # Test with extras
            test_extras_cmd = f"am broadcast -n {self.package}/{full_receiver} --es command 'test' --ei admin 1"
            self.mcp.shell(test_extras_cmd)

            # Check for sensitive receivers
            sensitive_keywords = ['admin', 'push', 'command', 'action', 'update']
            if any(kw in receiver.lower() for kw in sensitive_keywords):
                self.add_finding(Finding(
                    id=generate_finding_id("PLATFORM", f"sensitive_receiver_{receiver}"),
                    title=f"Sensitive Broadcast Receiver Exported: {receiver}",
                    severity=Severity.MEDIUM,
                    category=FindingCategory.PLATFORM,
                    description=f"Broadcast receiver '{receiver}' is exported and can receive broadcasts from any app.",
                    evidence=[f"Receiver: {full_receiver}"],
                    affected_component=full_receiver,
                    remediation="Add signature-level permission or set exported=\"false\".",
                    mastg_id="MASTG-TEST-0026"
                ))

    def step_test_deep_links(self) -> None:
        """Test deep link handling for vulnerabilities."""
        if 'all' not in self.components and 'deeplinks' not in self.components:
            self.progress.info("Skipping deep link testing")
            return

        self.progress.info(f"Testing {len(self.deep_links)} deep link schemes...")

        # XSS and injection payloads for deep links
        deeplink_payloads = [
            '?redirect=http://evil.com',
            '?url=javascript:alert(1)',
            '?file=../../../etc/passwd',
            '?cmd=;id',
            '?debug=true',
            '?admin=true',
            '/../../etc/passwd',
            '/<script>alert(1)</script>',
        ]

        for deep_link in self.deep_links:
            self.progress.info(f"  Testing: {deep_link}")

            for payload in deeplink_payloads:
                test_url = f"{deep_link}{payload}"

                result = self.mcp.shell(
                    f"am start -a android.intent.action.VIEW -d '{test_url}'"
                )
                time.sleep(0.5)

                # Monitor for crash or unexpected behavior
                if self.crashes_detected:
                    self.add_finding(Finding(
                        id=generate_finding_id("PLATFORM", f"deeplink_crash_{deep_link}"),
                        title=f"Deep Link Crash: {deep_link}",
                        severity=Severity.MEDIUM,
                        category=FindingCategory.PLATFORM,
                        description=f"Deep link handler crashed with payload: {payload}",
                        evidence=[f"URL: {test_url}", f"Crash: {self.crashes_detected[-1]}"],
                        affected_component=deep_link,
                        remediation="Implement proper input validation for deep link parameters.",
                        mastg_id="MASTG-TEST-0027"
                    ))

            # Test for open redirect
            redirect_url = f"{deep_link}?redirect=http://evil.com"
            result = self.mcp.shell(f"am start -a android.intent.action.VIEW -d '{redirect_url}'")

            self.add_finding(Finding(
                id=generate_finding_id("PLATFORM", f"deeplink_tested_{deep_link}"),
                title=f"Deep Link Tested: {deep_link}",
                severity=Severity.INFO,
                category=FindingCategory.PLATFORM,
                description=f"Deep link scheme tested with {len(deeplink_payloads)} payloads.",
                evidence=[f"Scheme: {deep_link}"],
                affected_component=deep_link,
                remediation="Validate all deep link parameters. Implement allowlist for redirects.",
                mastg_id="MASTG-TEST-0027"
            ))

    def step_monitor_crashes(self) -> None:
        """Collect crash monitoring results."""
        self.progress.info("Collecting crash monitoring data...")

        # Allow some time for any pending crashes to be reported
        time.sleep(2)

        if self.crashes_detected:
            self.add_finding(Finding(
                id=generate_finding_id("CODE", "crashes_detected"),
                title=f"Application Crashes Detected During Fuzzing",
                severity=Severity.MEDIUM,
                category=FindingCategory.CODE,
                description=f"Detected {len(self.crashes_detected)} crashes during component fuzzing.",
                evidence=[str(c)[:200] for c in self.crashes_detected[:5]],
                affected_component="Exception Handling",
                remediation="Review crash logs. Implement proper input validation and error handling.",
                mastg_id="MASTG-TEST-0028"
            ))

    def step_generate_report(self) -> None:
        """Generate component fuzzing report."""
        self.progress.info("Generating fuzzing report...")

        report = {
            "scan_type": "Component Fuzzer",
            "package": self.package,
            "components_tested": self.components,
            "enumeration": {
                "exported_activities": self.exported_activities,
                "exported_services": self.exported_services,
                "exported_providers": [p['name'] for p in self.exported_providers],
                "exported_receivers": self.exported_receivers,
                "deep_links": self.deep_links
            },
            "summary": {
                "total_findings": len(self.findings),
                "critical_issues": len([f for f in self.findings if f.severity == Severity.CRITICAL]),
                "crashes_detected": len(self.crashes_detected),
                "total_components": (len(self.exported_activities) + len(self.exported_services) +
                                    len(self.exported_providers) + len(self.exported_receivers))
            },
            "crashes": self.crashes_detected,
            "findings": [f.to_dict() for f in self.findings]
        }

        report_path = self.output_dir / f"{self.package}_component_fuzzing_report.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        self.progress.info(f"Report saved to: {report_path}")


def main():
    parser = parse_common_args()
    parser.add_argument('--components', '-c', default='all',
                       help='Comma-separated components: all,activities,services,providers,receivers,deeplinks')
    args = parser.parse_args()

    components = args.components.split(',')

    workflow = ComponentFuzzer(
        package=args.package,
        output_dir=Path(args.output),
        apk_path=Path(args.apk) if args.apk else None,
        resume=args.resume,
        verbose=args.verbose,
        components=components
    )

    findings = workflow.run()

    print(f"\n{'='*60}")
    print(f"Component Fuzzing Complete: {len(findings)} findings")
    print(f"{'='*60}")

    return 0


if __name__ == "__main__":
    exit(main())
