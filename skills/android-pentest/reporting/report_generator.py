#!/usr/bin/env python3
"""
Android Penetration Test Report Generator
Generates professional security assessment reports in multiple formats.

Usage:
    python report_generator.py \
        --findings ./results/findings.json \
        --evidence ./results/evidence/ \
        --output ./reports/final_report \
        --format html,pdf \
        --client "ACME Corp" \
        --app-name "Target App" \
        --app-version "1.2.3"
"""

import argparse
import json
import os
import shutil
import subprocess
import sys
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional

try:
    from jinja2 import Environment, FileSystemLoader, select_autoescape
except ImportError:
    print("Error: jinja2 is required. Install with: pip install jinja2")
    sys.exit(1)

try:
    import markdown
except ImportError:
    markdown = None

from severity_calculator import (
    CVSSCalculator, CVSSVector, severity_to_color, severity_to_badge,
    COMMON_VECTORS, get_common_cvss
)


@dataclass
class ReportConfig:
    """Report configuration."""
    title: str = "Android Penetration Test Report"
    client_name: str = "Client"
    app_name: str = "Application"
    app_version: str = "1.0.0"
    package_name: str = ""
    assessor: str = "Security Team"
    assessment_start: str = ""
    assessment_end: str = ""
    target_sdk: int = 0
    min_sdk: int = 0
    test_device: str = ""
    android_version: str = ""
    root_status: str = ""
    scope_included: list = field(default_factory=list)
    scope_excluded: list = field(default_factory=list)


class ReportGenerator:
    """Generates penetration test reports from findings."""

    def __init__(self, config: ReportConfig, output_dir: Path):
        self.config = config
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Set up Jinja2 environment
        template_dir = Path(__file__).parent / "templates"
        self.env = Environment(
            loader=FileSystemLoader(str(template_dir)),
            autoescape=select_autoescape(['html', 'xml'])
        )

        # Load remediation database
        self.remediation_db = self._load_remediation_db()

        # Findings and evidence
        self.findings: list[dict] = []
        self.evidence: list[dict] = []
        self.timeline: list[dict] = []

    def _load_remediation_db(self) -> dict:
        """Load remediation database."""
        db_path = Path(__file__).parent / "remediation_db.json"
        if db_path.exists():
            with open(db_path) as f:
                data = json.load(f)
                return data.get('remediations', {})
        return {}

    def load_findings(self, findings_path: Path) -> None:
        """Load findings from JSON file."""
        with open(findings_path) as f:
            data = json.load(f)

        # Handle different JSON structures
        if isinstance(data, list):
            self.findings = data
        elif isinstance(data, dict):
            if 'findings' in data:
                self.findings = data['findings']
            elif 'all_findings' in data:
                self.findings = data['all_findings']
            else:
                # Assume single finding
                self.findings = [data]

        # Enrich findings with remediation data
        self._enrich_findings()

        # Sort by severity
        severity_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3, 'info': 4}
        self.findings.sort(key=lambda f: severity_order.get(f.get('severity', 'info'), 5))

    def load_evidence(self, evidence_dir: Path) -> None:
        """Load evidence from directory."""
        catalog_path = evidence_dir / "catalog.json"
        if catalog_path.exists():
            with open(catalog_path) as f:
                data = json.load(f)
                self.evidence = data.get('evidence', [])
                self.timeline = data.get('timeline', [])

    def _enrich_findings(self) -> None:
        """Enrich findings with remediation data and CVSS calculations."""
        for finding in self.findings:
            # Add remediation if not present
            if 'remediation' not in finding or not finding['remediation']:
                remediation_key = self._get_remediation_key(finding)
                if remediation_key and remediation_key in self.remediation_db:
                    finding['remediation'] = self.remediation_db[remediation_key]

            # Calculate CVSS if not present
            if 'cvss' not in finding or not finding.get('cvss', {}).get('score'):
                cvss_data = self._calculate_cvss_for_finding(finding)
                finding['cvss'] = cvss_data

            # Add evidence references
            finding_id = finding.get('id', '')
            finding['evidence'] = finding.get('evidence', [])
            for ev in self.evidence:
                if finding_id in ev.get('finding_ids', []):
                    if ev not in finding['evidence']:
                        finding['evidence'].append(ev)

    def _get_remediation_key(self, finding: dict) -> Optional[str]:
        """Map finding to remediation database key."""
        title = finding.get('title', '').lower()
        category = finding.get('category', '')

        # Map common findings to remediation keys
        mappings = {
            'insecure data storage': 'insecure_data_storage',
            'plaintext': 'insecure_data_storage',
            'sharedpreferences': 'insecure_data_storage',
            'weak crypto': 'weak_cryptography',
            'md5': 'weak_cryptography',
            'sha1': 'weak_cryptography',
            'des': 'weak_cryptography',
            'ecb': 'weak_cryptography',
            'certificate pinning': 'missing_certificate_pinning',
            'ssl pinning': 'missing_certificate_pinning',
            'exported': 'exported_components',
            'sql injection': 'sql_injection',
            'debuggable': 'debuggable_application',
            'backup': 'backup_enabled',
            'cleartext': 'cleartext_traffic',
            'http': 'cleartext_traffic',
            'biometric': 'insecure_biometric',
            'webview': 'webview_vulnerabilities',
            'log': 'logging_sensitive_data',
            'hardcoded': 'hardcoded_secrets',
            'api key': 'hardcoded_secrets',
            'random': 'insecure_random',
            'path traversal': 'path_traversal',
            'intent redirect': 'intent_redirection',
        }

        for keyword, key in mappings.items():
            if keyword in title:
                return key

        return None

    def _calculate_cvss_for_finding(self, finding: dict) -> dict:
        """Calculate CVSS score for a finding based on its characteristics."""
        severity = finding.get('severity', 'info')
        category = finding.get('category', '')
        title = finding.get('title', '').lower()

        # Try to match common vulnerability types
        for vuln_type, vector in COMMON_VECTORS.items():
            if vuln_type.replace('_', ' ') in title:
                result = CVSSCalculator.calculate(vector)
                return {
                    'score': result['score'],
                    'vector': result['vector'],
                    'severity': result['severity']
                }

        # Default based on severity
        default_scores = {
            'critical': 9.5,
            'high': 7.5,
            'medium': 5.5,
            'low': 3.0,
            'info': 0.0
        }

        return {
            'score': default_scores.get(severity, 0.0),
            'vector': None,
            'severity': severity
        }

    def _build_report_data(self) -> dict:
        """Build the complete report data structure."""
        # Calculate summary statistics
        summary = {
            'critical': len([f for f in self.findings if f.get('severity') == 'critical']),
            'high': len([f for f in self.findings if f.get('severity') == 'high']),
            'medium': len([f for f in self.findings if f.get('severity') == 'medium']),
            'low': len([f for f in self.findings if f.get('severity') == 'low']),
            'info': len([f for f in self.findings if f.get('severity') == 'info'])
        }

        # Calculate risk level
        if summary['critical'] > 0:
            risk_level = 'CRITICAL'
        elif summary['high'] > 2:
            risk_level = 'HIGH'
        elif summary['high'] > 0 or summary['medium'] > 3:
            risk_level = 'MEDIUM'
        elif summary['medium'] > 0:
            risk_level = 'LOW'
        else:
            risk_level = 'MINIMAL'

        # Group findings by category
        by_category = {}
        for finding in self.findings:
            cat = finding.get('category', 'Other')
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(finding)

        # Category labels for charts
        category_labels = list(by_category.keys())
        category_values = [len(findings) for findings in by_category.values()]

        # Generate executive summary
        executive_summary = self._generate_executive_summary(summary, risk_level)

        # Generate recommendations
        recommendations = self._generate_recommendations()

        # Category descriptions
        category_descriptions = {
            'MASVS-STORAGE': 'Data storage and privacy',
            'MASVS-CRYPTO': 'Cryptographic implementations',
            'MASVS-AUTH': 'Authentication and session management',
            'MASVS-NETWORK': 'Network communication security',
            'MASVS-PLATFORM': 'Platform interaction and IPC',
            'MASVS-CODE': 'Code quality and security',
            'MASVS-RESILIENCE': 'Anti-tampering and resilience',
            'MASVS-PRIVACY': 'Privacy controls'
        }

        categories = {
            cat: {
                'description': category_descriptions.get(cat, cat),
                'finding_count': len(findings)
            }
            for cat, findings in by_category.items()
        }

        return {
            'title': self.config.title,
            'client_name': self.config.client_name,
            'app_name': self.config.app_name,
            'app_version': self.config.app_version,
            'package_name': self.config.package_name,
            'assessor': self.config.assessor,
            'assessment_date': self.config.assessment_start or datetime.now().strftime('%Y-%m-%d'),
            'assessment_start': self.config.assessment_start or datetime.now().strftime('%Y-%m-%d'),
            'assessment_end': self.config.assessment_end or datetime.now().strftime('%Y-%m-%d'),
            'generated_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'version': '1.0',
            'target_sdk': self.config.target_sdk,
            'min_sdk': self.config.min_sdk,
            'test_device': self.config.test_device or 'Android Device',
            'android_version': self.config.android_version or 'Unknown',
            'root_status': self.config.root_status or 'Unknown',
            'risk_level': risk_level,
            'total_findings': len(self.findings),
            'summary': summary,
            'executive_summary': executive_summary,
            'findings': self.findings,
            'critical_findings': [f for f in self.findings if f.get('severity') == 'critical'],
            'high_findings': [f for f in self.findings if f.get('severity') == 'high'],
            'categories': categories,
            'category_labels': category_labels,
            'category_values': category_values,
            'recommendations': recommendations,
            'immediate_recommendations': [r for r in recommendations if '[CRITICAL]' in r or '[HIGH]' in r][:10],
            'shortterm_recommendations': [r for r in recommendations if '[MEDIUM]' in r][:10],
            'longterm_recommendations': [r for r in recommendations if '[LOW]' in r or '[INFO]' in r][:5],
            'scope': {
                'included': self.config.scope_included or [
                    'Android application security assessment',
                    'Static code analysis',
                    'Dynamic runtime testing',
                    'Network traffic analysis',
                    'Local data storage review'
                ],
                'excluded': self.config.scope_excluded or []
            },
            'timeline': self.timeline,
            'conclusion': self._generate_conclusion(summary, risk_level)
        }

    def _generate_executive_summary(self, summary: dict, risk_level: str) -> str:
        """Generate executive summary text."""
        total = sum(summary.values())

        parts = [
            f"A comprehensive security assessment was conducted on {self.config.app_name} "
            f"version {self.config.app_version} (package: {self.config.package_name}). "
            f"The assessment identified {total} security findings across multiple categories."
        ]

        if summary['critical'] > 0:
            parts.append(
                f"CRITICAL: {summary['critical']} critical vulnerability{'s' if summary['critical'] > 1 else ''} "
                f"{'were' if summary['critical'] > 1 else 'was'} discovered that require immediate remediation."
            )

        if summary['high'] > 0:
            parts.append(
                f"{summary['high']} high-severity issue{'s' if summary['high'] > 1 else ''} "
                f"should be addressed as a priority."
            )

        if summary['medium'] > 0:
            parts.append(
                f"{summary['medium']} medium-severity finding{'s' if summary['medium'] > 1 else ''} "
                f"{'were' if summary['medium'] > 1 else 'was'} identified for short-term remediation."
            )

        parts.append(f"The overall security posture is assessed as {risk_level}.")

        return ' '.join(parts)

    def _generate_recommendations(self) -> list[str]:
        """Generate prioritized recommendations."""
        recommendations = []

        for finding in self.findings:
            severity = finding.get('severity', 'info').upper()
            remediation = finding.get('remediation', {})

            if isinstance(remediation, dict):
                summary = remediation.get('summary', '')
            else:
                summary = str(remediation)

            if summary:
                recommendations.append(f"[{severity}] {summary}")

        return recommendations

    def _generate_conclusion(self, summary: dict, risk_level: str) -> str:
        """Generate conclusion text."""
        if risk_level in ['CRITICAL', 'HIGH']:
            return (
                f"The assessment revealed significant security concerns that require immediate attention. "
                f"We strongly recommend prioritizing the remediation of critical and high-severity findings "
                f"before the application is deployed to production or continues in active use."
            )
        elif risk_level == 'MEDIUM':
            return (
                f"The application demonstrates a moderate security posture with several areas for improvement. "
                f"We recommend addressing the identified findings according to the priority recommendations "
                f"to enhance the overall security of the application."
            )
        else:
            return (
                f"The application demonstrates a reasonable security posture. "
                f"The identified findings are primarily low-risk or informational and can be addressed "
                f"as part of regular development cycles."
            )

    def generate_html(self, template_name: str = 'technical_report.html.jinja2') -> Path:
        """Generate HTML report."""
        report_data = self._build_report_data()

        template = self.env.get_template(template_name)
        html_content = template.render(report=report_data)

        # Copy CSS file
        css_source = Path(__file__).parent / "templates" / "styles.css"
        css_dest = self.output_dir / "styles.css"
        shutil.copy2(css_source, css_dest)

        # Write HTML
        output_path = self.output_dir / f"report.html"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)

        return output_path

    def generate_executive_html(self) -> Path:
        """Generate executive summary HTML."""
        report_data = self._build_report_data()

        template = self.env.get_template('executive_report.html.jinja2')
        html_content = template.render(report=report_data)

        output_path = self.output_dir / f"executive_summary.html"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)

        return output_path

    def generate_markdown(self) -> Path:
        """Generate Markdown report."""
        report_data = self._build_report_data()

        md_content = self._render_markdown(report_data)

        output_path = self.output_dir / f"report.md"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(md_content)

        return output_path

    def _render_markdown(self, report: dict) -> str:
        """Render report as Markdown."""
        lines = []

        # Header
        lines.append(f"# {report['title']}")
        lines.append("")
        lines.append(f"**Client:** {report['client_name']}")
        lines.append(f"**Application:** {report['app_name']} v{report['app_version']}")
        lines.append(f"**Package:** {report['package_name']}")
        lines.append(f"**Assessment Date:** {report['assessment_date']}")
        lines.append(f"**Report Generated:** {report['generated_date']}")
        lines.append("")

        # Executive Summary
        lines.append("## Executive Summary")
        lines.append("")
        lines.append(f"**Overall Risk Level:** {report['risk_level']}")
        lines.append("")
        lines.append(report['executive_summary'])
        lines.append("")

        # Summary table
        lines.append("### Findings Summary")
        lines.append("")
        lines.append("| Severity | Count |")
        lines.append("|----------|-------|")
        lines.append(f"| Critical | {report['summary']['critical']} |")
        lines.append(f"| High | {report['summary']['high']} |")
        lines.append(f"| Medium | {report['summary']['medium']} |")
        lines.append(f"| Low | {report['summary']['low']} |")
        lines.append(f"| Info | {report['summary']['info']} |")
        lines.append(f"| **Total** | **{report['total_findings']}** |")
        lines.append("")

        # Findings
        lines.append("## Detailed Findings")
        lines.append("")

        for i, finding in enumerate(report['findings'], 1):
            lines.append(f"### {i}. [{finding.get('severity', 'INFO').upper()}] {finding.get('title', 'Untitled')}")
            lines.append("")
            lines.append(f"**ID:** {finding.get('id', 'N/A')}")
            lines.append(f"**Category:** {finding.get('category', 'N/A')}")

            if finding.get('cvss', {}).get('score'):
                lines.append(f"**CVSS Score:** {finding['cvss']['score']}")
                if finding['cvss'].get('vector'):
                    lines.append(f"**CVSS Vector:** `{finding['cvss']['vector']}`")

            lines.append("")
            lines.append("#### Description")
            lines.append(finding.get('description', 'No description provided.'))
            lines.append("")

            if finding.get('affected_component'):
                lines.append("#### Affected Component")
                lines.append(f"`{finding['affected_component']}`")
                lines.append("")

            if finding.get('reproduction_steps'):
                lines.append("#### Steps to Reproduce")
                for step in finding['reproduction_steps']:
                    lines.append(f"{step.get('step_number', '-')}. {step.get('description', '')}")
                    if step.get('command'):
                        lines.append(f"   ```")
                        lines.append(f"   {step['command']}")
                        lines.append(f"   ```")
                lines.append("")

            if finding.get('evidence'):
                lines.append("#### Evidence")
                for ev in finding['evidence']:
                    if isinstance(ev, dict):
                        lines.append(f"- {ev.get('description', ev.get('content', str(ev)))}")
                    else:
                        lines.append(f"- `{ev}`")
                lines.append("")

            if finding.get('remediation'):
                lines.append("#### Remediation")
                remediation = finding['remediation']
                if isinstance(remediation, dict):
                    lines.append(remediation.get('summary', ''))
                    if remediation.get('detailed_steps'):
                        lines.append("")
                        for step in remediation['detailed_steps']:
                            lines.append(f"- {step}")
                else:
                    lines.append(str(remediation))
                lines.append("")

            lines.append("---")
            lines.append("")

        # Recommendations
        lines.append("## Recommendations")
        lines.append("")
        for i, rec in enumerate(report['recommendations'][:15], 1):
            lines.append(f"{i}. {rec}")
        lines.append("")

        # Conclusion
        lines.append("## Conclusion")
        lines.append("")
        lines.append(report['conclusion'])
        lines.append("")

        # Footer
        lines.append("---")
        lines.append(f"*Confidential - {report['client_name']}*")

        return '\n'.join(lines)

    def generate_pdf(self) -> Optional[Path]:
        """Generate PDF report using weasyprint or wkhtmltopdf."""
        # First generate HTML
        html_path = self.generate_html()

        pdf_path = self.output_dir / "report.pdf"

        # Try weasyprint first
        try:
            from weasyprint import HTML
            HTML(filename=str(html_path)).write_pdf(str(pdf_path))
            return pdf_path
        except ImportError:
            pass

        # Try wkhtmltopdf
        try:
            result = subprocess.run(
                ['wkhtmltopdf', '--enable-local-file-access', str(html_path), str(pdf_path)],
                capture_output=True,
                timeout=120
            )
            if result.returncode == 0:
                return pdf_path
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

        # Try Chrome/Chromium headless
        for chrome in ['google-chrome', 'chromium', 'chromium-browser']:
            try:
                result = subprocess.run(
                    [chrome, '--headless', '--disable-gpu', f'--print-to-pdf={pdf_path}', str(html_path)],
                    capture_output=True,
                    timeout=120
                )
                if result.returncode == 0:
                    return pdf_path
            except (subprocess.TimeoutExpired, FileNotFoundError):
                continue

        print("Warning: PDF generation requires weasyprint, wkhtmltopdf, or Chrome/Chromium")
        print("Install with: pip install weasyprint")
        return None

    def generate_docx(self) -> Optional[Path]:
        """Generate DOCX report using python-docx."""
        try:
            from docx import Document
            from docx.shared import Inches, Pt, RGBColor
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            from docx.enum.style import WD_STYLE_TYPE
        except ImportError:
            print("Warning: DOCX generation requires python-docx")
            print("Install with: pip install python-docx")
            return None

        report_data = self._build_report_data()
        doc = Document()

        # Title
        title = doc.add_heading(report_data['title'], 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Subtitle
        subtitle = doc.add_paragraph()
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = subtitle.add_run(f"Security Assessment Report")
        run.font.size = Pt(14)

        # Meta information
        doc.add_paragraph()
        meta_table = doc.add_table(rows=5, cols=2)
        meta_table.style = 'Table Grid'
        meta_data = [
            ('Client', report_data['client_name']),
            ('Application', f"{report_data['app_name']} v{report_data['app_version']}"),
            ('Package', report_data['package_name']),
            ('Assessment Date', report_data['assessment_date']),
            ('Report Generated', report_data['generated_date'])
        ]
        for i, (label, value) in enumerate(meta_data):
            meta_table.rows[i].cells[0].text = label
            meta_table.rows[i].cells[1].text = value

        # Executive Summary
        doc.add_heading('Executive Summary', level=1)

        risk_para = doc.add_paragraph()
        risk_para.add_run('Overall Risk Level: ').bold = True
        risk_run = risk_para.add_run(report_data['risk_level'])
        risk_run.bold = True

        severity_colors = {
            'CRITICAL': RGBColor(139, 0, 0),
            'HIGH': RGBColor(255, 69, 0),
            'MEDIUM': RGBColor(255, 165, 0),
            'LOW': RGBColor(65, 105, 225),
            'MINIMAL': RGBColor(34, 139, 34)
        }
        risk_run.font.color.rgb = severity_colors.get(report_data['risk_level'], RGBColor(0, 0, 0))

        doc.add_paragraph(report_data['executive_summary'])

        # Summary Table
        doc.add_heading('Findings Summary', level=2)
        summary_table = doc.add_table(rows=6, cols=2)
        summary_table.style = 'Table Grid'
        summary_data = [
            ('Critical', str(report_data['summary']['critical'])),
            ('High', str(report_data['summary']['high'])),
            ('Medium', str(report_data['summary']['medium'])),
            ('Low', str(report_data['summary']['low'])),
            ('Informational', str(report_data['summary']['info'])),
            ('Total', str(report_data['total_findings']))
        ]
        for i, (label, value) in enumerate(summary_data):
            summary_table.rows[i].cells[0].text = label
            summary_table.rows[i].cells[1].text = value

        # Detailed Findings
        doc.add_page_break()
        doc.add_heading('Detailed Findings', level=1)

        for i, finding in enumerate(report_data['findings'], 1):
            severity = finding.get('severity', 'info').upper()
            title_text = f"{i}. [{severity}] {finding.get('title', 'Untitled')}"
            finding_heading = doc.add_heading(title_text, level=2)

            # Metadata
            meta_para = doc.add_paragraph()
            meta_para.add_run(f"ID: ").bold = True
            meta_para.add_run(f"{finding.get('id', 'N/A')} | ")
            meta_para.add_run(f"Category: ").bold = True
            meta_para.add_run(f"{finding.get('category', 'N/A')}")
            if finding.get('cvss', {}).get('score'):
                meta_para.add_run(f" | ")
                meta_para.add_run(f"CVSS: ").bold = True
                meta_para.add_run(f"{finding['cvss']['score']}")

            # Description
            doc.add_heading('Description', level=3)
            doc.add_paragraph(finding.get('description', 'No description'))

            # Remediation
            if finding.get('remediation'):
                doc.add_heading('Remediation', level=3)
                remediation = finding['remediation']
                if isinstance(remediation, dict):
                    doc.add_paragraph(remediation.get('summary', ''))
                else:
                    doc.add_paragraph(str(remediation))

        # Recommendations
        doc.add_page_break()
        doc.add_heading('Recommendations', level=1)
        for i, rec in enumerate(report_data['recommendations'][:15], 1):
            doc.add_paragraph(f"{i}. {rec}")

        # Save
        docx_path = self.output_dir / "report.docx"
        doc.save(str(docx_path))

        return docx_path

    def generate_json(self) -> Path:
        """Generate JSON report."""
        report_data = self._build_report_data()

        output_path = self.output_dir / "report.json"
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, default=str)

        return output_path

    def generate_all(self, formats: list[str]) -> dict[str, Optional[Path]]:
        """Generate reports in multiple formats."""
        results = {}

        format_methods = {
            'html': self.generate_html,
            'executive': self.generate_executive_html,
            'pdf': self.generate_pdf,
            'docx': self.generate_docx,
            'md': self.generate_markdown,
            'markdown': self.generate_markdown,
            'json': self.generate_json
        }

        for fmt in formats:
            fmt = fmt.lower().strip()
            if fmt in format_methods:
                print(f"Generating {fmt.upper()} report...")
                try:
                    results[fmt] = format_methods[fmt]()
                    if results[fmt]:
                        print(f"  ✓ Generated: {results[fmt]}")
                    else:
                        print(f"  ✗ Failed to generate {fmt}")
                except Exception as e:
                    print(f"  ✗ Error generating {fmt}: {e}")
                    results[fmt] = None
            else:
                print(f"  ✗ Unknown format: {fmt}")

        return results


def main():
    parser = argparse.ArgumentParser(
        description='Generate Android penetration test reports',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python report_generator.py -f findings.json -o ./reports --format html,pdf
  python report_generator.py -f findings.json --client "ACME Corp" --app-name "MyApp"
  python report_generator.py -f findings.json -e ./evidence --format all
        """
    )

    parser.add_argument('--findings', '-f', required=True, help='Path to findings JSON file')
    parser.add_argument('--evidence', '-e', help='Path to evidence directory')
    parser.add_argument('--output', '-o', default='./report_output', help='Output directory')
    parser.add_argument('--format', default='html', help='Output formats (comma-separated): html,pdf,docx,md,json,executive,all')
    parser.add_argument('--title', default='Android Penetration Test Report', help='Report title')
    parser.add_argument('--client', default='Client', help='Client name')
    parser.add_argument('--app-name', default='Application', help='Application name')
    parser.add_argument('--app-version', default='1.0.0', help='Application version')
    parser.add_argument('--package', default='', help='Package name')
    parser.add_argument('--assessor', default='Security Team', help='Assessor name')

    args = parser.parse_args()

    # Parse formats
    if args.format.lower() == 'all':
        formats = ['html', 'executive', 'pdf', 'docx', 'md', 'json']
    else:
        formats = [f.strip() for f in args.format.split(',')]

    # Create config
    config = ReportConfig(
        title=args.title,
        client_name=args.client,
        app_name=args.app_name,
        app_version=args.app_version,
        package_name=args.package,
        assessor=args.assessor
    )

    # Create generator
    generator = ReportGenerator(config, Path(args.output))

    # Load data
    print(f"Loading findings from: {args.findings}")
    generator.load_findings(Path(args.findings))
    print(f"  Loaded {len(generator.findings)} findings")

    if args.evidence:
        print(f"Loading evidence from: {args.evidence}")
        generator.load_evidence(Path(args.evidence))
        print(f"  Loaded {len(generator.evidence)} evidence items")

    # Generate reports
    print(f"\nGenerating reports...")
    results = generator.generate_all(formats)

    # Summary
    print(f"\n{'='*60}")
    print("Report Generation Complete")
    print(f"{'='*60}")
    print(f"Output directory: {args.output}")
    for fmt, path in results.items():
        status = f"✓ {path.name}" if path else "✗ Failed"
        print(f"  {fmt.upper():10}: {status}")

    return 0


if __name__ == "__main__":
    exit(main())
