{
  "version": "1.0.0",
  "last_updated": "2025-01-01",
  "remediations": {
    "insecure_data_storage": {
      "title": "Insecure Data Storage",
      "category": "MASVS-STORAGE",
      "summary": "Store sensitive data using encrypted storage mechanisms",
      "detailed_steps": [
        "Identify all locations where sensitive data is stored",
        "Replace SharedPreferences with EncryptedSharedPreferences",
        "Implement SQLCipher for database encryption",
        "Use Android Keystore for cryptographic key storage",
        "Ensure files are stored in internal storage with appropriate permissions"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "val prefs = getSharedPreferences(\"auth\", MODE_PRIVATE)\nprefs.edit().putString(\"password\", password).apply()",
          "secure": "val masterKey = MasterKey.Builder(context)\n    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n    .build()\n\nval encryptedPrefs = EncryptedSharedPreferences.create(\n    context,\n    \"secure_prefs\",\n    masterKey,\n    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n)\n\nencryptedPrefs.edit().putString(\"token\", token).apply()"
        },
        "java": {
          "vulnerable": "SharedPreferences prefs = getSharedPreferences(\"auth\", MODE_PRIVATE);\nprefs.edit().putString(\"password\", password).apply();",
          "secure": "MasterKey masterKey = new MasterKey.Builder(context)\n    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n    .build();\n\nSharedPreferences encryptedPrefs = EncryptedSharedPreferences.create(\n    context,\n    \"secure_prefs\",\n    masterKey,\n    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n);\n\nencryptedPrefs.edit().putString(\"token\", token).apply();"
        }
      },
      "effort": "Medium",
      "priority": "Immediate",
      "references": [
        {
          "title": "EncryptedSharedPreferences Documentation",
          "url": "https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences"
        },
        {
          "title": "OWASP MASTG - Testing Local Storage",
          "url": "https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/"
        }
      ]
    },
    "weak_cryptography": {
      "title": "Weak Cryptographic Algorithms",
      "category": "MASVS-CRYPTO",
      "summary": "Replace weak cryptographic algorithms with industry-standard secure alternatives",
      "detailed_steps": [
        "Audit all cryptographic operations in the codebase",
        "Replace MD5/SHA1 with SHA-256 or SHA-3",
        "Replace DES/3DES with AES-256-GCM",
        "Replace ECB mode with GCM or CBC with proper IV",
        "Use SecureRandom for cryptographic random number generation",
        "Implement proper key derivation with PBKDF2, scrypt, or Argon2"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "val md = MessageDigest.getInstance(\"MD5\")\nval cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\")",
          "secure": "// For hashing\nval md = MessageDigest.getInstance(\"SHA-256\")\n\n// For encryption\nval cipher = Cipher.getInstance(\"AES/GCM/NoPadding\")\nval keyGenerator = KeyGenerator.getInstance(\"AES\")\nkeyGenerator.init(256, SecureRandom())\nval secretKey = keyGenerator.generateKey()\n\nval iv = ByteArray(12)\nSecureRandom().nextBytes(iv)\nval gcmSpec = GCMParameterSpec(128, iv)\n\ncipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmSpec)"
        }
      },
      "effort": "Medium",
      "priority": "Short-term",
      "references": [
        {
          "title": "Android Cryptography Guide",
          "url": "https://developer.android.com/guide/topics/security/cryptography"
        },
        {
          "title": "OWASP Cryptographic Failures",
          "url": "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
        }
      ]
    },
    "missing_certificate_pinning": {
      "title": "Missing Certificate Pinning",
      "category": "MASVS-NETWORK",
      "summary": "Implement certificate pinning to prevent man-in-the-middle attacks",
      "detailed_steps": [
        "Generate SHA-256 hash of your server's public key",
        "Implement pinning using OkHttp CertificatePinner or Network Security Configuration",
        "Include backup pins for certificate rotation",
        "Test pinning implementation with proxy tools",
        "Plan for certificate rotation without app updates"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "val client = OkHttpClient.Builder().build()",
          "secure": "val certificatePinner = CertificatePinner.Builder()\n    .add(\"api.example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n    .add(\"api.example.com\", \"sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=\") // Backup pin\n    .build()\n\nval client = OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build()"
        },
        "xml": {
          "network_security_config": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <domain-config>\n        <domain includeSubdomains=\"true\">api.example.com</domain>\n        <pin-set expiration=\"2025-12-31\">\n            <pin digest=\"SHA-256\">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</pin>\n            <pin digest=\"SHA-256\">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=</pin>\n        </pin-set>\n    </domain-config>\n</network-security-config>"
        }
      },
      "effort": "Low",
      "priority": "Short-term",
      "references": [
        {
          "title": "Network Security Configuration",
          "url": "https://developer.android.com/training/articles/security-config"
        },
        {
          "title": "OkHttp Certificate Pinning",
          "url": "https://square.github.io/okhttp/features/https/#certificate-pinning"
        }
      ]
    },
    "exported_components": {
      "title": "Insecurely Exported Components",
      "category": "MASVS-PLATFORM",
      "summary": "Restrict access to exported components using permissions or explicit export=false",
      "detailed_steps": [
        "Audit all components (activities, services, receivers, providers) in AndroidManifest.xml",
        "Set android:exported=\"false\" for components not requiring external access",
        "Define custom signature-level permissions for components requiring controlled access",
        "Validate all input received through exported components",
        "Implement proper authorization checks within exported components"
      ],
      "code_examples": {
        "xml": {
          "vulnerable": "<activity\n    android:name=\".AdminActivity\"\n    android:exported=\"true\" />",
          "secure": "<!-- Option 1: Disable export -->\n<activity\n    android:name=\".AdminActivity\"\n    android:exported=\"false\" />\n\n<!-- Option 2: Require permission -->\n<permission\n    android:name=\"com.example.permission.ADMIN_ACCESS\"\n    android:protectionLevel=\"signature\" />\n\n<activity\n    android:name=\".AdminActivity\"\n    android:exported=\"true\"\n    android:permission=\"com.example.permission.ADMIN_ACCESS\" />"
        }
      },
      "effort": "Low",
      "priority": "Immediate",
      "references": [
        {
          "title": "Android App Components Security",
          "url": "https://developer.android.com/guide/topics/manifest/activity-element#exported"
        },
        {
          "title": "OWASP MASTG - Testing Platform Interaction",
          "url": "https://mas.owasp.org/MASTG/Android/0x05h-Testing-Platform-Interaction/"
        }
      ]
    },
    "sql_injection": {
      "title": "SQL Injection in Content Provider",
      "category": "MASVS-PLATFORM",
      "summary": "Use parameterized queries and input validation to prevent SQL injection",
      "detailed_steps": [
        "Replace string concatenation in SQL queries with parameterized queries",
        "Use Room database with type-safe queries",
        "Implement input validation for all user-supplied data",
        "Use projection and selection whitelisting in content providers",
        "Consider using SQLCipher for encrypted database access"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "val cursor = db.rawQuery(\n    \"SELECT * FROM users WHERE username = '$username'\",\n    null\n)",
          "secure": "// Using parameterized query\nval cursor = db.rawQuery(\n    \"SELECT * FROM users WHERE username = ?\",\n    arrayOf(username)\n)\n\n// Or using Room\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users WHERE username = :username\")\n    fun findByUsername(username: String): User?\n}"
        },
        "java": {
          "vulnerable": "Cursor cursor = db.rawQuery(\n    \"SELECT * FROM users WHERE username = '\" + username + \"'\",\n    null\n);",
          "secure": "// Using parameterized query\nCursor cursor = db.rawQuery(\n    \"SELECT * FROM users WHERE username = ?\",\n    new String[]{username}\n);\n\n// Content Provider with validation\n@Override\npublic Cursor query(Uri uri, String[] projection, String selection,\n                    String[] selectionArgs, String sortOrder) {\n    // Whitelist allowed columns\n    String[] allowedColumns = {\"id\", \"name\", \"email\"};\n    if (projection != null) {\n        for (String col : projection) {\n            if (!Arrays.asList(allowedColumns).contains(col)) {\n                throw new IllegalArgumentException(\"Invalid column: \" + col);\n            }\n        }\n    }\n    // Use parameterized query\n    return db.query(TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);\n}"
        }
      },
      "effort": "Medium",
      "priority": "Immediate",
      "references": [
        {
          "title": "Android Room Persistence Library",
          "url": "https://developer.android.com/training/data-storage/room"
        },
        {
          "title": "OWASP SQL Injection Prevention",
          "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        }
      ]
    },
    "debuggable_application": {
      "title": "Debuggable Application",
      "category": "MASVS-CODE",
      "summary": "Disable debugging in release builds",
      "detailed_steps": [
        "Ensure android:debuggable is not set to true in release builds",
        "Use build variants to manage debug/release configurations",
        "Implement build pipeline checks to verify debuggable is false",
        "Remove all debug logs and breakpoints from release code"
      ],
      "code_examples": {
        "gradle": {
          "vulnerable": "android {\n    buildTypes {\n        release {\n            debuggable true\n        }\n    }\n}",
          "secure": "android {\n    buildTypes {\n        release {\n            debuggable false\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n        debug {\n            debuggable true\n        }\n    }\n}"
        }
      },
      "effort": "Low",
      "priority": "Immediate",
      "references": [
        {
          "title": "Configure Build Variants",
          "url": "https://developer.android.com/studio/build/build-variants"
        }
      ]
    },
    "backup_enabled": {
      "title": "Application Backup Enabled",
      "category": "MASVS-STORAGE",
      "summary": "Disable backup or implement encrypted backup with proper exclusions",
      "detailed_steps": [
        "Set android:allowBackup=\"false\" if backup is not required",
        "If backup is needed, implement BackupAgent with encryption",
        "Define backup rules to exclude sensitive files",
        "Test backup contents to ensure no sensitive data is included"
      ],
      "code_examples": {
        "xml": {
          "vulnerable": "<application\n    android:allowBackup=\"true\"\n    ...>",
          "secure": "<!-- Option 1: Disable backup -->\n<application\n    android:allowBackup=\"false\"\n    ...>\n\n<!-- Option 2: Define backup rules -->\n<application\n    android:allowBackup=\"true\"\n    android:fullBackupContent=\"@xml/backup_rules\"\n    android:dataExtractionRules=\"@xml/data_extraction_rules\"\n    ...>\n\n<!-- res/xml/backup_rules.xml -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<full-backup-content>\n    <exclude domain=\"sharedpref\" path=\"credentials.xml\" />\n    <exclude domain=\"database\" path=\"secrets.db\" />\n    <exclude domain=\"file\" path=\"private/\" />\n</full-backup-content>"
        }
      },
      "effort": "Low",
      "priority": "Short-term",
      "references": [
        {
          "title": "Back Up User Data",
          "url": "https://developer.android.com/guide/topics/data/autobackup"
        }
      ]
    },
    "cleartext_traffic": {
      "title": "Cleartext Traffic Allowed",
      "category": "MASVS-NETWORK",
      "summary": "Disable cleartext (HTTP) traffic and enforce HTTPS",
      "detailed_steps": [
        "Set android:usesCleartextTraffic=\"false\" in manifest",
        "Configure Network Security Config to block cleartext",
        "Update all API endpoints to use HTTPS",
        "Implement HSTS on server side"
      ],
      "code_examples": {
        "xml": {
          "vulnerable": "<application\n    android:usesCleartextTraffic=\"true\"\n    ...>",
          "secure": "<application\n    android:usesCleartextTraffic=\"false\"\n    android:networkSecurityConfig=\"@xml/network_security_config\"\n    ...>\n\n<!-- res/xml/network_security_config.xml -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <base-config cleartextTrafficPermitted=\"false\">\n        <trust-anchors>\n            <certificates src=\"system\" />\n        </trust-anchors>\n    </base-config>\n</network-security-config>"
        }
      },
      "effort": "Low",
      "priority": "Short-term",
      "references": [
        {
          "title": "Network Security Configuration",
          "url": "https://developer.android.com/training/articles/security-config"
        }
      ]
    },
    "insecure_biometric": {
      "title": "Insecure Biometric Implementation",
      "category": "MASVS-AUTH",
      "summary": "Implement biometric authentication with cryptographic binding",
      "detailed_steps": [
        "Use BiometricPrompt with CryptoObject for sensitive operations",
        "Generate keys in Android Keystore with biometric binding",
        "Set setUserAuthenticationRequired(true) on key generation",
        "Implement proper fallback authentication",
        "Handle biometric enrollment changes"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "biometricPrompt.authenticate(promptInfo)\n// Then proceed without crypto binding",
          "secure": "// Generate biometric-bound key\nval keyGenerator = KeyGenerator.getInstance(\n    KeyProperties.KEY_ALGORITHM_AES,\n    \"AndroidKeyStore\"\n)\n\nval keyGenParameterSpec = KeyGenParameterSpec.Builder(\n    \"biometric_key\",\n    KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT\n)\n    .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n    .setUserAuthenticationRequired(true)\n    .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG)\n    .setInvalidatedByBiometricEnrollment(true)\n    .build()\n\nkeyGenerator.init(keyGenParameterSpec)\nval secretKey = keyGenerator.generateKey()\n\n// Use CryptoObject with biometric\nval cipher = Cipher.getInstance(\"AES/GCM/NoPadding\")\ncipher.init(Cipher.ENCRYPT_MODE, secretKey)\n\nval cryptoObject = BiometricPrompt.CryptoObject(cipher)\nbiometricPrompt.authenticate(promptInfo, cryptoObject)"
        }
      },
      "effort": "Medium",
      "priority": "Short-term",
      "references": [
        {
          "title": "Biometric Authentication",
          "url": "https://developer.android.com/training/sign-in/biometric-auth"
        },
        {
          "title": "Android Keystore System",
          "url": "https://developer.android.com/training/articles/keystore"
        }
      ]
    },
    "webview_vulnerabilities": {
      "title": "WebView Security Issues",
      "category": "MASVS-PLATFORM",
      "summary": "Secure WebView configuration to prevent JavaScript injection and file access",
      "detailed_steps": [
        "Disable JavaScript if not required",
        "Disable file access methods",
        "Implement proper URL validation",
        "Use WebViewClient to intercept and validate URLs",
        "Remove JavaScript interfaces if not needed"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "webView.settings.apply {\n    javaScriptEnabled = true\n    allowFileAccess = true\n    allowFileAccessFromFileURLs = true\n    allowUniversalAccessFromFileURLs = true\n}\nwebView.addJavascriptInterface(JSBridge(), \"Android\")",
          "secure": "webView.settings.apply {\n    javaScriptEnabled = true // Only if required\n    allowFileAccess = false\n    allowFileAccessFromFileURLs = false\n    allowUniversalAccessFromFileURLs = false\n    allowContentAccess = false\n    domStorageEnabled = false\n    databaseEnabled = false\n}\n\n// Validate URLs before loading\nwebView.webViewClient = object : WebViewClient() {\n    override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {\n        val url = request?.url?.toString() ?: return true\n        val allowedDomains = listOf(\"example.com\", \"api.example.com\")\n        val host = Uri.parse(url).host ?: return true\n        \n        return !allowedDomains.any { host.endsWith(it) }\n    }\n    \n    override fun onReceivedSslError(view: WebView?, handler: SslErrorHandler?, error: SslError?) {\n        handler?.cancel() // Don't proceed on SSL errors\n    }\n}"
        }
      },
      "effort": "Medium",
      "priority": "Short-term",
      "references": [
        {
          "title": "WebView Security Best Practices",
          "url": "https://developer.android.com/develop/ui/views/layout/webapps/webview"
        },
        {
          "title": "OWASP WebView Guidelines",
          "url": "https://mas.owasp.org/MASTG/Android/0x05h-Testing-Platform-Interaction/#testing-webview-protocol-handlers-mstg-platform-6"
        }
      ]
    },
    "logging_sensitive_data": {
      "title": "Sensitive Data in Logs",
      "category": "MASVS-CODE",
      "summary": "Remove sensitive data from application logs",
      "detailed_steps": [
        "Audit all Log.* statements in codebase",
        "Remove or redact sensitive data from logs",
        "Use ProGuard to strip logging in release builds",
        "Implement a custom logging wrapper with data sanitization"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "Log.d(TAG, \"User login: $username, password: $password\")\nLog.d(TAG, \"API Response: $response\")",
          "secure": "// Custom logger with sanitization\nobject SecureLog {\n    private val SENSITIVE_PATTERNS = listOf(\n        \"password\", \"token\", \"key\", \"secret\", \"auth\"\n    )\n    \n    fun d(tag: String, message: String) {\n        if (BuildConfig.DEBUG) {\n            Log.d(tag, sanitize(message))\n        }\n    }\n    \n    private fun sanitize(message: String): String {\n        var sanitized = message\n        SENSITIVE_PATTERNS.forEach { pattern ->\n            sanitized = sanitized.replace(\n                Regex(\"$pattern[=:\\\"']?[^\\\\s,\\\"']+\", RegexOption.IGNORE_CASE),\n                \"$pattern=[REDACTED]\"\n            )\n        }\n        return sanitized\n    }\n}\n\n// ProGuard rules to strip logs\n// -assumenosideeffects class android.util.Log {\n//     public static int d(...);\n//     public static int v(...);\n// }"
        }
      },
      "effort": "Medium",
      "priority": "Short-term",
      "references": [
        {
          "title": "Remove Log Statements",
          "url": "https://developer.android.com/studio/build/shrink-code"
        }
      ]
    },
    "hardcoded_secrets": {
      "title": "Hardcoded Secrets/API Keys",
      "category": "MASVS-STORAGE",
      "summary": "Remove hardcoded secrets and implement secure key management",
      "detailed_steps": [
        "Audit codebase for hardcoded credentials and API keys",
        "Move secrets to secure backend or key management service",
        "Use BuildConfig for non-sensitive configuration",
        "Implement secure API key delivery mechanism",
        "Consider using Firebase Remote Config or similar for dynamic configuration"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "const val API_KEY = \"sk_live_AbC123XyZ789\"\nconst val DB_PASSWORD = \"super_secret_password\"",
          "secure": "// Option 1: Fetch from secure backend\nsuspend fun getApiKey(): String {\n    return secureApi.fetchApiKey(deviceAttestation())\n}\n\n// Option 2: Use Android Keystore for local secrets\nfun storeSecret(alias: String, secret: String) {\n    val keyStore = KeyStore.getInstance(\"AndroidKeyStore\").apply { load(null) }\n    \n    val keyGenerator = KeyGenerator.getInstance(\n        KeyProperties.KEY_ALGORITHM_AES,\n        \"AndroidKeyStore\"\n    )\n    keyGenerator.init(\n        KeyGenParameterSpec.Builder(alias, PURPOSE_ENCRYPT or PURPOSE_DECRYPT)\n            .setBlockModes(BLOCK_MODE_GCM)\n            .setEncryptionPaddings(ENCRYPTION_PADDING_NONE)\n            .build()\n    )\n    val secretKey = keyGenerator.generateKey()\n    \n    // Encrypt and store\n    val cipher = Cipher.getInstance(\"AES/GCM/NoPadding\")\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey)\n    val encrypted = cipher.doFinal(secret.toByteArray())\n    // Store encrypted value and IV\n}\n\n// Option 3: Build-time injection (less secure)\n// In build.gradle:\n// buildConfigField \"String\", \"API_KEY\", \"\\\"${System.getenv('API_KEY')}\\\"\""
        }
      },
      "effort": "High",
      "priority": "Immediate",
      "references": [
        {
          "title": "Secure Secret Storage",
          "url": "https://developer.android.com/training/articles/keystore"
        }
      ]
    },
    "insecure_random": {
      "title": "Insecure Random Number Generation",
      "category": "MASVS-CRYPTO",
      "summary": "Use SecureRandom for cryptographic operations",
      "detailed_steps": [
        "Replace java.util.Random with java.security.SecureRandom",
        "Do not seed SecureRandom with predictable values",
        "Use appropriate SecureRandom algorithms for the platform"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "val random = Random()\nval token = (1..32).map { random.nextInt(256).toByte() }.toByteArray()",
          "secure": "val secureRandom = SecureRandom()\nval token = ByteArray(32)\nsecureRandom.nextBytes(token)\n\n// For generating secure tokens\nfun generateSecureToken(length: Int = 32): String {\n    val bytes = ByteArray(length)\n    SecureRandom().nextBytes(bytes)\n    return Base64.encodeToString(bytes, Base64.URL_SAFE or Base64.NO_WRAP)\n}"
        }
      },
      "effort": "Low",
      "priority": "Short-term",
      "references": [
        {
          "title": "SecureRandom Documentation",
          "url": "https://developer.android.com/reference/java/security/SecureRandom"
        }
      ]
    },
    "path_traversal": {
      "title": "Path Traversal Vulnerability",
      "category": "MASVS-PLATFORM",
      "summary": "Validate and sanitize file paths to prevent directory traversal",
      "detailed_steps": [
        "Validate all user-supplied file paths",
        "Use canonical path comparison",
        "Implement allowlist for permitted directories",
        "Use FileProvider for sharing files with other apps"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "fun getFile(filename: String): File {\n    return File(dataDir, filename)\n}",
          "secure": "fun getFile(filename: String): File? {\n    val baseDir = File(dataDir).canonicalFile\n    val requestedFile = File(baseDir, filename).canonicalFile\n    \n    // Verify the file is within allowed directory\n    if (!requestedFile.path.startsWith(baseDir.path)) {\n        Log.e(TAG, \"Path traversal attempt detected: $filename\")\n        return null\n    }\n    \n    // Additional validation\n    if (filename.contains(\"..\") || filename.contains(\":\")) {\n        Log.e(TAG, \"Invalid filename: $filename\")\n        return null\n    }\n    \n    return requestedFile\n}\n\n// For Content Providers\noverride fun openFile(uri: Uri, mode: String): ParcelFileDescriptor? {\n    val path = uri.lastPathSegment ?: return null\n    val file = getFile(path) ?: throw SecurityException(\"Access denied\")\n    return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)\n}"
        }
      },
      "effort": "Low",
      "priority": "Immediate",
      "references": [
        {
          "title": "Path Traversal Prevention",
          "url": "https://owasp.org/www-community/attacks/Path_Traversal"
        }
      ]
    },
    "intent_redirection": {
      "title": "Intent Redirection Vulnerability",
      "category": "MASVS-PLATFORM",
      "summary": "Validate incoming intents and avoid forwarding untrusted intent data",
      "detailed_steps": [
        "Validate intent sources when possible",
        "Never forward untrusted intents to sensitive components",
        "Sanitize and validate all intent extras",
        "Use explicit intents for internal navigation"
      ],
      "code_examples": {
        "kotlin": {
          "vulnerable": "// Dangerous: forwards untrusted intent\nval nextIntent = intent.getParcelableExtra<Intent>(\"next_intent\")\nstartActivity(nextIntent)",
          "secure": "// Validate and sanitize intent data\nfun handleIntentSafely(intent: Intent) {\n    // Option 1: Only allow specific components\n    val nextIntent = intent.getParcelableExtra<Intent>(\"next_intent\")\n    if (nextIntent != null) {\n        // Only allow navigation to whitelisted activities\n        val allowedComponents = setOf(\n            ComponentName(packageName, \"${packageName}.MainActivity\"),\n            ComponentName(packageName, \"${packageName}.SettingsActivity\")\n        )\n        \n        if (nextIntent.component in allowedComponents) {\n            startActivity(nextIntent)\n        } else {\n            Log.w(TAG, \"Blocked redirect to: ${nextIntent.component}\")\n        }\n    }\n    \n    // Option 2: Extract only specific expected data\n    val targetAction = intent.getStringExtra(\"action\")\n    when (targetAction) {\n        \"settings\" -> startActivity(Intent(this, SettingsActivity::class.java))\n        \"profile\" -> startActivity(Intent(this, ProfileActivity::class.java))\n        else -> Log.w(TAG, \"Unknown action: $targetAction\")\n    }\n}"
        }
      },
      "effort": "Medium",
      "priority": "Short-term",
      "references": [
        {
          "title": "Intent Security",
          "url": "https://developer.android.com/guide/components/intents-filters#Receiving"
        }
      ]
    }
  }
}
